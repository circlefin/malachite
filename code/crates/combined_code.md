# Combined Code Files

## TOC
- [`app/Cargo.toml`](#file-1)
- [`app/src/lib.rs`](#file-2)
- [`app/src/node.rs`](#file-3)
- [`app/src/part_store.rs`](#file-4)
- [`app/src/spawn.rs`](#file-5)
- [`app/src/types.rs`](#file-6)
- [`app-channel/Cargo.toml`](#file-7)
- [`app-channel/src/connector.rs`](#file-8)
- [`app-channel/src/lib.rs`](#file-9)
- [`app-channel/src/msgs.rs`](#file-10)
- [`app-channel/src/run.rs`](#file-11)
- [`app-channel/src/spawn.rs`](#file-12)
- [`codec/Cargo.toml`](#file-13)
- [`codec/src/lib.rs`](#file-14)
- [`config/Cargo.toml`](#file-15)
- [`config/src/lib.rs`](#file-16)
- [`core-consensus/Cargo.toml`](#file-17)
- [`core-consensus/src/effect.rs`](#file-18)
- [`core-consensus/src/error.rs`](#file-19)
- [`core-consensus/src/full_proposal.rs`](#file-20)
- [`core-consensus/src/gen.rs`](#file-21)
- [`core-consensus/src/handle/decide.rs`](#file-22)
- [`core-consensus/src/handle/driver.rs`](#file-23)
- [`core-consensus/src/handle/liveness.rs`](#file-24)
- [`core-consensus/src/handle/proposal.rs`](#file-25)
- [`core-consensus/src/handle/propose.rs`](#file-26)
- [`core-consensus/src/handle/proposed_value.rs`](#file-27)
- [`core-consensus/src/handle/rebroadcast_timeout.rs`](#file-28)
- [`core-consensus/src/handle/signature.rs`](#file-29)
- [`core-consensus/src/handle/start_height.rs`](#file-30)
- [`core-consensus/src/handle/sync.rs`](#file-31)
- [`core-consensus/src/handle/timeout.rs`](#file-32)
- [`core-consensus/src/handle/validator_set.rs`](#file-33)
- [`core-consensus/src/handle/vote.rs`](#file-34)
- [`core-consensus/src/handle.rs`](#file-35)
- [`core-consensus/src/input.rs`](#file-36)
- [`core-consensus/src/lib.rs`](#file-37)
- [`core-consensus/src/macros.rs`](#file-38)
- [`core-consensus/src/params.rs`](#file-39)
- [`core-consensus/src/prelude.rs`](#file-40)
- [`core-consensus/src/state.rs`](#file-41)
- [`core-consensus/src/types.rs`](#file-42)
- [`core-consensus/src/util/max_queue.rs`](#file-43)
- [`core-consensus/src/util/mod.rs`](#file-44)
- [`core-consensus/src/util/pretty.rs`](#file-45)
- [`core-consensus/tests/full_proposal.rs`](#file-46)
- [`core-driver/Cargo.toml`](#file-47)
- [`core-driver/src/driver.rs`](#file-48)
- [`core-driver/src/error.rs`](#file-49)
- [`core-driver/src/input.rs`](#file-50)
- [`core-driver/src/lib.rs`](#file-51)
- [`core-driver/src/mux.rs`](#file-52)
- [`core-driver/src/output.rs`](#file-53)
- [`core-driver/src/proposal_keeper.rs`](#file-54)
- [`core-driver/tests/it/basic.rs`](#file-55)
- [`core-driver/tests/it/extra.rs`](#file-56)
- [`core-driver/tests/it/main.rs`](#file-57)
- [`core-driver/tests/it/utils.rs`](#file-58)
- [`core-state-machine/Cargo.toml`](#file-59)
- [`core-state-machine/src/input.rs`](#file-60)
- [`core-state-machine/src/lib.rs`](#file-61)
- [`core-state-machine/src/output.rs`](#file-62)
- [`core-state-machine/src/state.rs`](#file-63)
- [`core-state-machine/src/state_machine.rs`](#file-64)
- [`core-state-machine/src/traces/line.rs`](#file-65)
- [`core-state-machine/src/traces/mod.rs`](#file-66)
- [`core-state-machine/src/traces/trace.rs`](#file-67)
- [`core-state-machine/src/transition.rs`](#file-68)
- [`core-types/Cargo.toml`](#file-69)
- [`core-types/src/certificate.rs`](#file-70)
- [`core-types/src/context.rs`](#file-71)
- [`core-types/src/height.rs`](#file-72)
- [`core-types/src/lib.rs`](#file-73)
- [`core-types/src/proposal.rs`](#file-74)
- [`core-types/src/proposal_part.rs`](#file-75)
- [`core-types/src/round.rs`](#file-76)
- [`core-types/src/signed_message.rs`](#file-77)
- [`core-types/src/signing.rs`](#file-78)
- [`core-types/src/threshold.rs`](#file-79)
- [`core-types/src/timeout.rs`](#file-80)
- [`core-types/src/validator_set.rs`](#file-81)
- [`core-types/src/value.rs`](#file-82)
- [`core-types/src/vote.rs`](#file-83)
- [`core-types/src/vote_extension.rs`](#file-84)
- [`core-votekeeper/Cargo.toml`](#file-85)
- [`core-votekeeper/src/count.rs`](#file-86)
- [`core-votekeeper/src/evidence.rs`](#file-87)
- [`core-votekeeper/src/keeper.rs`](#file-88)
- [`core-votekeeper/src/lib.rs`](#file-89)
- [`core-votekeeper/src/round_votes.rs`](#file-90)
- [`core-votekeeper/src/round_weights.rs`](#file-91)
- [`core-votekeeper/src/value_weights.rs`](#file-92)
- [`core-votekeeper/tests/round_votes.rs`](#file-93)
- [`core-votekeeper/tests/vote_count.rs`](#file-94)
- [`core-votekeeper/tests/vote_keeper.rs`](#file-95)
- [`discovery/Cargo.toml`](#file-96)
- [`discovery/src/behaviour.rs`](#file-97)
- [`discovery/src/config.rs`](#file-98)
- [`discovery/src/connection.rs`](#file-99)
- [`discovery/src/controller.rs`](#file-100)
- [`discovery/src/handlers/bootstrap.rs`](#file-101)
- [`discovery/src/handlers/close.rs`](#file-102)
- [`discovery/src/handlers/connect_request.rs`](#file-103)
- [`discovery/src/handlers/dial.rs`](#file-104)
- [`discovery/src/handlers/extension.rs`](#file-105)
- [`discovery/src/handlers/helpers.rs`](#file-106)
- [`discovery/src/handlers/identify.rs`](#file-107)
- [`discovery/src/handlers/mod.rs`](#file-108)
- [`discovery/src/handlers/peers_management.rs`](#file-109)
- [`discovery/src/handlers/peers_request.rs`](#file-110)
- [`discovery/src/handlers/selection/kademlia.rs`](#file-111)
- [`discovery/src/handlers/selection/mod.rs`](#file-112)
- [`discovery/src/handlers/selection/random.rs`](#file-113)
- [`discovery/src/handlers/selection/selector.rs`](#file-114)
- [`discovery/src/lib.rs`](#file-115)
- [`discovery/src/metrics.rs`](#file-116)
- [`discovery/src/request.rs`](#file-117)
- [`discovery/src/util.rs`](#file-118)
- [`engine/Cargo.toml`](#file-119)
- [`engine/src/consensus.rs`](#file-120)
- [`engine/src/host.rs`](#file-121)
- [`engine/src/lib.rs`](#file-122)
- [`engine/src/network.rs`](#file-123)
- [`engine/src/node.rs`](#file-124)
- [`engine/src/sync.rs`](#file-125)
- [`engine/src/util/events.rs`](#file-126)
- [`engine/src/util/mod.rs`](#file-127)
- [`engine/src/util/msg_buffer.rs`](#file-128)
- [`engine/src/util/output_port.rs`](#file-129)
- [`engine/src/util/streaming.rs`](#file-130)
- [`engine/src/util/ticker.rs`](#file-131)
- [`engine/src/util/timers.rs`](#file-132)
- [`engine/src/wal/entry.rs`](#file-133)
- [`engine/src/wal/iter.rs`](#file-134)
- [`engine/src/wal/thread.rs`](#file-135)
- [`engine/src/wal.rs`](#file-136)
- [`metrics/Cargo.toml`](#file-137)
- [`metrics/src/lib.rs`](#file-138)
- [`metrics/src/metrics.rs`](#file-139)
- [`metrics/src/registry.rs`](#file-140)
- [`network/Cargo.toml`](#file-141)
- [`network/src/behaviour.rs`](#file-142)
- [`network/src/channel.rs`](#file-143)
- [`network/src/handle.rs`](#file-144)
- [`network/src/lib.rs`](#file-145)
- [`network/src/pubsub.rs`](#file-146)
- [`network/test/Cargo.toml`](#file-147)
- [`network/test/src/lib.rs`](#file-148)
- [`network/test/tests/discovery.rs`](#file-149)
- [`peer/Cargo.toml`](#file-150)
- [`peer/src/lib.rs`](#file-151)
- [`proto/Cargo.toml`](#file-152)
- [`proto/src/lib.rs`](#file-153)
- [`signing-ed25519/Cargo.toml`](#file-154)
- [`signing-ed25519/src/lib.rs`](#file-155)
- [`signing-ed25519/src/serializers/base64string.rs`](#file-156)
- [`signing-ed25519/src/serializers/mod.rs`](#file-157)
- [`signing-ed25519/src/serializers/signing_key.rs`](#file-158)
- [`signing-ed25519/src/serializers/verification_key.rs`](#file-159)
- [`starknet/app/Cargo.toml`](#file-160)
- [`starknet/app/src/main.rs`](#file-161)
- [`starknet/host/Cargo.toml`](#file-162)
- [`starknet/host/src/actor.rs`](#file-163)
- [`starknet/host/src/block_store/keys.rs`](#file-164)
- [`starknet/host/src/block_store.rs`](#file-165)
- [`starknet/host/src/codec.rs`](#file-166)
- [`starknet/host/src/config.rs`](#file-167)
- [`starknet/host/src/host/proposal.rs`](#file-168)
- [`starknet/host/src/host/starknet.rs`](#file-169)
- [`starknet/host/src/host/state.rs`](#file-170)
- [`starknet/host/src/host.rs`](#file-171)
- [`starknet/host/src/lib.rs`](#file-172)
- [`starknet/host/src/mempool/network.rs`](#file-173)
- [`starknet/host/src/mempool.rs`](#file-174)
- [`starknet/host/src/mempool_load.rs`](#file-175)
- [`starknet/host/src/node.rs`](#file-176)
- [`starknet/host/src/spawn.rs`](#file-177)
- [`starknet/host/src/streaming.rs`](#file-178)
- [`starknet/p2p-proto/Cargo.toml`](#file-179)
- [`starknet/p2p-proto/build.rs`](#file-180)
- [`starknet/p2p-proto/export-proto.sh`](#file-181)
- [`starknet/p2p-proto/src/lib.rs`](#file-182)
- [`starknet/p2p-types/Cargo.toml`](#file-183)
- [`starknet/p2p-types/src/address.rs`](#file-184)
- [`starknet/p2p-types/src/block.rs`](#file-185)
- [`starknet/p2p-types/src/block_info.rs`](#file-186)
- [`starknet/p2p-types/src/block_proof.rs`](#file-187)
- [`starknet/p2p-types/src/context/impls.rs`](#file-188)
- [`starknet/p2p-types/src/context.rs`](#file-189)
- [`starknet/p2p-types/src/felt.rs`](#file-190)
- [`starknet/p2p-types/src/hash.rs`](#file-191)
- [`starknet/p2p-types/src/height.rs`](#file-192)
- [`starknet/p2p-types/src/lib.rs`](#file-193)
- [`starknet/p2p-types/src/proposal.rs`](#file-194)
- [`starknet/p2p-types/src/proposal_commitment.rs`](#file-195)
- [`starknet/p2p-types/src/proposal_part.rs`](#file-196)
- [`starknet/p2p-types/src/signing/provider.rs`](#file-197)
- [`starknet/p2p-types/src/signing.rs`](#file-198)
- [`starknet/p2p-types/src/streaming.rs`](#file-199)
- [`starknet/p2p-types/src/transaction.rs`](#file-200)
- [`starknet/p2p-types/src/validator.rs`](#file-201)
- [`starknet/p2p-types/src/validator_set.rs`](#file-202)
- [`starknet/p2p-types/src/vote.rs`](#file-203)
- [`starknet/test/Cargo.toml`](#file-204)
- [`starknet/test/mbt/Cargo.toml`](#file-205)
- [`starknet/test/mbt/src/deserializers.rs`](#file-206)
- [`starknet/test/mbt/src/lib.rs`](#file-207)
- [`starknet/test/mbt/src/streaming.rs`](#file-208)
- [`starknet/test/mbt/src/tests/streaming/runner.rs`](#file-209)
- [`starknet/test/mbt/src/tests/streaming/utils.rs`](#file-210)
- [`starknet/test/mbt/src/tests/streaming.rs`](#file-211)
- [`starknet/test/mbt/src/tests.rs`](#file-212)
- [`starknet/test/mbt/src/utils.rs`](#file-213)
- [`starknet/test/src/lib.rs`](#file-214)
- [`starknet/test/src/tests/full_nodes.rs`](#file-215)
- [`starknet/test/src/tests/mod.rs`](#file-216)
- [`starknet/test/src/tests/n3f0.rs`](#file-217)
- [`starknet/test/src/tests/n3f0_pubsub_protocol.rs`](#file-218)
- [`starknet/test/src/tests/n3f1.rs`](#file-219)
- [`starknet/test/src/tests/value_sync.rs`](#file-220)
- [`starknet/test/src/tests/vote_rebroadcast.rs`](#file-221)
- [`starknet/test/src/tests/wal.rs`](#file-222)
- [`sync/Cargo.toml`](#file-223)
- [`sync/src/behaviour.rs`](#file-224)
- [`sync/src/co.rs`](#file-225)
- [`sync/src/handle.rs`](#file-226)
- [`sync/src/lib.rs`](#file-227)
- [`sync/src/macros.rs`](#file-228)
- [`sync/src/metrics.rs`](#file-229)
- [`sync/src/rpc.rs`](#file-230)
- [`sync/src/state.rs`](#file-231)
- [`sync/src/types.rs`](#file-232)
- [`test/Cargo.toml`](#file-233)
- [`test/app/Cargo.toml`](#file-234)
- [`test/app/config.toml`](#file-235)
- [`test/app/src/app.rs`](#file-236)
- [`test/app/src/config.rs`](#file-237)
- [`test/app/src/lib.rs`](#file-238)
- [`test/app/src/node.rs`](#file-239)
- [`test/app/src/state.rs`](#file-240)
- [`test/app/src/store/keys.rs`](#file-241)
- [`test/app/src/store.rs`](#file-242)
- [`test/app/src/streaming.rs`](#file-243)
- [`test/build.rs`](#file-244)
- [`test/cli/Cargo.toml`](#file-245)
- [`test/cli/src/args.rs`](#file-246)
- [`test/cli/src/cmd/distributed_testnet.rs`](#file-247)
- [`test/cli/src/cmd/dump_wal.rs`](#file-248)
- [`test/cli/src/cmd/init.rs`](#file-249)
- [`test/cli/src/cmd/mod.rs`](#file-250)
- [`test/cli/src/cmd/start.rs`](#file-251)
- [`test/cli/src/cmd/testnet.rs`](#file-252)
- [`test/cli/src/error.rs`](#file-253)
- [`test/cli/src/file.rs`](#file-254)
- [`test/cli/src/lib.rs`](#file-255)
- [`test/cli/src/logging.rs`](#file-256)
- [`test/cli/src/metrics.rs`](#file-257)
- [`test/cli/src/new.rs`](#file-258)
- [`test/cli/src/runtime.rs`](#file-259)
- [`test/framework/Cargo.toml`](#file-260)
- [`test/framework/src/expected.rs`](#file-261)
- [`test/framework/src/lib.rs`](#file-262)
- [`test/framework/src/logging.rs`](#file-263)
- [`test/framework/src/node.rs`](#file-264)
- [`test/framework/src/params.rs`](#file-265)
- [`test/mbt/Cargo.toml`](#file-266)
- [`test/mbt/src/consensus.rs`](#file-267)
- [`test/mbt/src/deserializers.rs`](#file-268)
- [`test/mbt/src/lib.rs`](#file-269)
- [`test/mbt/src/tests/consensus/runner.rs`](#file-270)
- [`test/mbt/src/tests/consensus/utils.rs`](#file-271)
- [`test/mbt/src/tests/consensus.rs`](#file-272)
- [`test/mbt/src/tests/votekeeper/runner.rs`](#file-273)
- [`test/mbt/src/tests/votekeeper/utils.rs`](#file-274)
- [`test/mbt/src/tests/votekeeper.rs`](#file-275)
- [`test/mbt/src/tests.rs`](#file-276)
- [`test/mbt/src/types.rs`](#file-277)
- [`test/mbt/src/utils.rs`](#file-278)
- [`test/mbt/src/votekeeper.rs`](#file-279)
- [`test/mempool/Cargo.toml`](#file-280)
- [`test/mempool/build.rs`](#file-281)
- [`test/mempool/src/behaviour.rs`](#file-282)
- [`test/mempool/src/handle.rs`](#file-283)
- [`test/mempool/src/lib.rs`](#file-284)
- [`test/mempool/src/msg.rs`](#file-285)
- [`test/mempool/src/proto.rs`](#file-286)
- [`test/mempool/src/types.rs`](#file-287)
- [`test/src/address.rs`](#file-288)
- [`test/src/codec/json/mod.rs`](#file-289)
- [`test/src/codec/json/raw.rs`](#file-290)
- [`test/src/codec/mod.rs`](#file-291)
- [`test/src/codec/proto/mod.rs`](#file-292)
- [`test/src/context.rs`](#file-293)
- [`test/src/genesis.rs`](#file-294)
- [`test/src/height.rs`](#file-295)
- [`test/src/lib.rs`](#file-296)
- [`test/src/middleware.rs`](#file-297)
- [`test/src/proposal.rs`](#file-298)
- [`test/src/proposal_part.rs`](#file-299)
- [`test/src/proposer_selector.rs`](#file-300)
- [`test/src/proto.rs`](#file-301)
- [`test/src/signing.rs`](#file-302)
- [`test/src/utils/mod.rs`](#file-303)
- [`test/src/utils/validators.rs`](#file-304)
- [`test/src/validator_set.rs`](#file-305)
- [`test/src/value.rs`](#file-306)
- [`test/src/vote.rs`](#file-307)
- [`test/tests/it/full_nodes.rs`](#file-308)
- [`test/tests/it/liveness.rs`](#file-309)
- [`test/tests/it/main.rs`](#file-310)
- [`test/tests/it/middlewares.rs`](#file-311)
- [`test/tests/it/n3f0.rs`](#file-312)
- [`test/tests/it/n3f0_consensus_mode.rs`](#file-313)
- [`test/tests/it/n3f0_pubsub_protocol.rs`](#file-314)
- [`test/tests/it/n3f1.rs`](#file-315)
- [`test/tests/it/reset.rs`](#file-316)
- [`test/tests/it/validator_set.rs`](#file-317)
- [`test/tests/it/value_sync.rs`](#file-318)
- [`test/tests/it/vote_rebroadcast.rs`](#file-319)
- [`test/tests/it/wal.rs`](#file-320)
- [`test/tests/unit/certificates/commit.rs`](#file-321)
- [`test/tests/unit/certificates/mod.rs`](#file-322)
- [`test/tests/unit/certificates/polka.rs`](#file-323)
- [`test/tests/unit/main.rs`](#file-324)
- [`wal/Cargo.toml`](#file-325)
- [`wal/benches/wal.rs`](#file-326)
- [`wal/src/ext.rs`](#file-327)
- [`wal/src/file.rs`](#file-328)
- [`wal/src/lib.rs`](#file-329)
- [`wal/src/log.rs`](#file-330)
- [`wal/src/ops.rs`](#file-331)
- [`wal/src/storage.rs`](#file-332)
- [`wal/src/version.rs`](#file-333)
- [`wal/tests/it/basic.rs`](#file-334)
- [`wal/tests/it/compression.rs`](#file-335)
- [`wal/tests/it/corruption.rs`](#file-336)
- [`wal/tests/it/crashes.rs`](#file-337)
- [`wal/tests/it/main.rs`](#file-338)
- [`wal/tests/it/stress.rs`](#file-339)

---

### `app/Cargo.toml`
*2025-05-18 23:58:49 | 2 KB*
```toml
[package]
name = "informalsystems-malachitebft-app"
description = "High-level interface for building applications on top of the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
malachitebft-codec.workspace = true
malachitebft-config.workspace = true
malachitebft-core-consensus.workspace = true
malachitebft-core-types.workspace = true
malachitebft-engine.workspace = true
malachitebft-metrics.workspace = true
malachitebft-network.workspace = true
malachitebft-peer.workspace = true
malachitebft-sync.workspace = true
malachitebft-wal.workspace = true

async-trait = { workspace = true }
derive-where = { workspace = true }
eyre = { workspace = true }
libp2p-identity = { workspace = true }
ractor = { workspace = true }
rand = { workspace = true }
serde = { workspace = true }
tokio = { workspace = true }
tracing = { workspace = true }

[lints]
workspace = true

```
---
### `app/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
// TODO: Enforce proper documentation
// #![warn(
//     missing_docs,
//     clippy::empty_docs,
//     clippy::missing_errors_doc,
//     rustdoc::broken_intra_doc_links,
//     rustdoc::missing_crate_level_docs,
//     rustdoc::missing_doc_code_examples
// )]

pub mod node;
pub mod part_store;
pub mod spawn;
pub mod types;
pub mod events {
    pub use malachitebft_engine::util::events::{RxEvent, TxEvent};
}

pub use malachitebft_config as config;
pub use malachitebft_core_consensus as consensus;
pub use malachitebft_engine as engine;
pub use malachitebft_engine::util::streaming;
pub use malachitebft_metrics as metrics;
pub use malachitebft_wal as wal;

```
---
### `app/src/node.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
#![allow(clippy::too_many_arguments)]

use std::path::PathBuf;

use async_trait::async_trait;
use rand::{CryptoRng, RngCore};
use serde::de::DeserializeOwned;
use serde::Serialize;
use tokio::task::JoinHandle;

use malachitebft_config::{
    ConsensusConfig, DiscoveryConfig, RuntimeConfig, TransportProtocol, ValueSyncConfig,
};
use malachitebft_core_types::SigningProvider;
use malachitebft_engine::node::NodeRef;
use malachitebft_engine::util::events::RxEvent;

use crate::types::core::{Context, PrivateKey, PublicKey, VotingPower};
use crate::types::Keypair;

pub struct EngineHandle {
    pub actor: NodeRef,
    pub handle: JoinHandle<()>,
}

#[async_trait]
pub trait NodeHandle<Ctx>
where
    Self: Send + Sync + 'static,
    Ctx: Context,
{
    fn subscribe(&self) -> RxEvent<Ctx>;
    async fn kill(&self, reason: Option<String>) -> eyre::Result<()>;
}

pub trait NodeConfig {
    fn moniker(&self) -> &str;
    fn consensus(&self) -> &ConsensusConfig;
    fn value_sync(&self) -> &ValueSyncConfig;
}

#[async_trait]
pub trait Node {
    type Context: Context;
    type Config: NodeConfig + Serialize + DeserializeOwned;
    type Genesis: Serialize + DeserializeOwned;
    type PrivateKeyFile: Serialize + DeserializeOwned;
    type SigningProvider: SigningProvider<Self::Context>;
    type NodeHandle: NodeHandle<Self::Context>;

    async fn start(&self) -> eyre::Result<Self::NodeHandle>;

    async fn run(self) -> eyre::Result<()>;

    fn get_home_dir(&self) -> PathBuf;

    fn load_config(&self) -> eyre::Result<Self::Config>;

    fn get_address(&self, pk: &PublicKey<Self::Context>) -> <Self::Context as Context>::Address;

    fn get_public_key(&self, pk: &PrivateKey<Self::Context>) -> PublicKey<Self::Context>;

    fn get_keypair(&self, pk: PrivateKey<Self::Context>) -> Keypair;

    fn load_private_key(&self, file: Self::PrivateKeyFile) -> PrivateKey<Self::Context>;

    fn load_private_key_file(&self) -> eyre::Result<Self::PrivateKeyFile>;

    fn load_genesis(&self) -> eyre::Result<Self::Genesis>;

    fn get_signing_provider(&self, private_key: PrivateKey<Self::Context>)
        -> Self::SigningProvider;
}

#[derive(Copy, Clone, Debug)]
pub struct MakeConfigSettings {
    pub runtime: RuntimeConfig,
    pub transport: TransportProtocol,
    pub discovery: DiscoveryConfig,
}

pub trait CanMakeConfig: Node {
    fn make_config(index: usize, total: usize, settings: MakeConfigSettings) -> Self::Config;
}

pub trait CanMakeDistributedConfig: Node {
    fn make_distributed_config(
        index: usize,
        total: usize,
        machines: Vec<String>,
        bootstrap_set_size: usize,
        settings: MakeConfigSettings,
    ) -> Self::Config;
}

pub trait CanGeneratePrivateKey: Node {
    fn generate_private_key<R>(&self, rng: R) -> PrivateKey<Self::Context>
    where
        R: RngCore + CryptoRng;
}

pub trait CanMakePrivateKeyFile: Node {
    fn make_private_key_file(&self, private_key: PrivateKey<Self::Context>)
        -> Self::PrivateKeyFile;
}

pub trait CanMakeGenesis: Node {
    fn make_genesis(
        &self,
        validators: Vec<(PublicKey<Self::Context>, VotingPower)>,
    ) -> Self::Genesis;
}

```
---
### `app/src/part_store.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::collections::BTreeMap;
use std::sync::Arc;

use derive_where::derive_where;

use malachitebft_core_types::{Context, Round, ValueId};
use malachitebft_engine::util::streaming::StreamId;

// This is a temporary store implementation for proposal parts
//
// TODO: Add Address to key
// NOTE: Not sure if this is required as consensus should verify that only the parts signed by the proposer for
//       the height and round should be forwarded here (see the TODOs in consensus)

type Key<Height> = (StreamId, Height, Round);

/// Stores proposal parts for a given stream, height, and round.
/// `value_id` is the value id of the proposal as computed by the proposer. It is also included in one of the parts but stored here for convenience.
/// `parts` is a list of `ProposalPart`s, ordered by the sequence of the `StreamMessage` that delivered them.
#[derive_where(Clone, Debug, Default)]
pub struct Entry<Ctx: Context> {
    pub value_id: Option<ValueId<Ctx>>,
    pub parts: Vec<Arc<<Ctx as Context>::ProposalPart>>,
}
type Store<Ctx> = BTreeMap<Key<<Ctx as Context>::Height>, Entry<Ctx>>;

#[derive_where(Clone, Debug)]
pub struct PartStore<Ctx: Context> {
    store: Store<Ctx>,
}

impl<Ctx: Context> Default for PartStore<Ctx> {
    fn default() -> Self {
        Self::new()
    }
}

impl<Ctx: Context> PartStore<Ctx> {
    pub fn new() -> Self {
        Self {
            store: Default::default(),
        }
    }

    /// Return all the parts for the given `stream_id`, `height` and `round`.
    /// Parts are already sorted by sequence in ascending order.
    pub fn all_parts_by_stream_id(
        &self,
        stream_id: StreamId,
        height: Ctx::Height,
        round: Round,
    ) -> Vec<Arc<Ctx::ProposalPart>> {
        self.store
            .get(&(stream_id, height, round))
            .map(|entry| entry.parts.clone())
            .unwrap_or_default()
    }

    /// Return all the parts for the given `value_id`. If multiple entries with same `value_id` are present, the parts of the first one are returned.
    /// Parts are already sorted by sequence in ascending order.
    pub fn all_parts_by_value_id(&self, value_id: &ValueId<Ctx>) -> Vec<Arc<Ctx::ProposalPart>> {
        self.store
            .values()
            .find(|entry| entry.value_id.as_ref() == Some(value_id))
            .map(|entry| entry.parts.clone())
            .unwrap_or_default()
    }

    /// Store a part for the given `stream_id`, `height` and `round`.
    /// The part is added to the end of the list of parts and is for the next sequence number after the last part.
    pub fn store(
        &mut self,
        stream_id: &StreamId,
        height: Ctx::Height,
        round: Round,
        proposal_part: Ctx::ProposalPart,
    ) {
        let existing = self
            .store
            .entry((stream_id.clone(), height, round))
            .or_default();
        existing.parts.push(Arc::new(proposal_part));
    }

    /// Store the `value_id` of the proposal, as computed by the proposer, for the given `stream_id`, `height` and `round`.
    pub fn store_value_id(
        &mut self,
        stream_id: &StreamId,
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
    ) {
        let existing = self
            .store
            .entry((stream_id.clone(), height, round))
            .or_default();
        existing.value_id = Some(value_id);
    }

    /// Prune the parts for all heights lower than `min_height`.
    /// This is used to prune the parts from the store when a min_height has been finalized.
    /// Parts for higher heights may be present if the node is lagging and are kept.
    pub fn prune(&mut self, min_height: Ctx::Height) {
        self.store.retain(|(_, height, _), _| *height >= min_height);
    }

    /// Return the number of blocks in the store.
    pub fn blocks_count(&self) -> usize {
        self.store.len()
    }
}

```
---
### `app/src/spawn.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
//! Utility functions for spawning the actor system and connecting it to the application.

use std::path::Path;
use std::time::Duration;

use eyre::Result;
use tokio::task::JoinHandle;
use tracing::Span;

use malachitebft_engine::consensus::{Consensus, ConsensusCodec, ConsensusParams, ConsensusRef};
use malachitebft_engine::host::HostRef;
use malachitebft_engine::network::{Network, NetworkRef};
use malachitebft_engine::node::{Node, NodeRef};
use malachitebft_engine::sync::{Params as SyncParams, Sync, SyncCodec, SyncRef};
use malachitebft_engine::util::events::TxEvent;
use malachitebft_engine::wal::{Wal, WalCodec, WalRef};
use malachitebft_network::{Config as NetworkConfig, DiscoveryConfig, GossipSubConfig, Keypair};

use crate::config::{ConsensusConfig, PubSubProtocol, ValueSyncConfig};
use crate::metrics::{Metrics, SharedRegistry};
use crate::types::core::{Context, SigningProvider};
use crate::types::sync;
use crate::types::ValuePayload;

pub async fn spawn_node_actor<Ctx>(
    ctx: Ctx,
    network: NetworkRef<Ctx>,
    consensus: ConsensusRef<Ctx>,
    wal: WalRef<Ctx>,
    sync: Option<SyncRef<Ctx>>,
    host: HostRef<Ctx>,
) -> Result<(NodeRef, JoinHandle<()>)>
where
    Ctx: Context,
{
    // Spawn the node actor
    let node = Node::new(
        ctx,
        network,
        consensus,
        wal,
        sync,
        host,
        tracing::Span::current(),
    );

    let (actor_ref, handle) = node.spawn().await?;
    Ok((actor_ref, handle))
}

pub async fn spawn_network_actor<Ctx, Codec>(
    cfg: &ConsensusConfig,
    keypair: Keypair,
    registry: &SharedRegistry,
    codec: Codec,
) -> Result<NetworkRef<Ctx>>
where
    Ctx: Context,
    Codec: ConsensusCodec<Ctx>,
    Codec: SyncCodec<Ctx>,
{
    let config = make_gossip_config(cfg);

    Network::spawn(keypair, config, registry.clone(), codec, Span::current())
        .await
        .map_err(Into::into)
}

#[allow(clippy::too_many_arguments)]
pub async fn spawn_consensus_actor<Ctx>(
    initial_height: Ctx::Height,
    initial_validator_set: Ctx::ValidatorSet,
    address: Ctx::Address,
    ctx: Ctx,
    cfg: &ConsensusConfig,
    signing_provider: Box<dyn SigningProvider<Ctx>>,
    network: NetworkRef<Ctx>,
    host: HostRef<Ctx>,
    wal: WalRef<Ctx>,
    sync: Option<SyncRef<Ctx>>,
    metrics: Metrics,
    tx_event: TxEvent<Ctx>,
) -> Result<ConsensusRef<Ctx>>
where
    Ctx: Context,
{
    use crate::config;

    let value_payload = match cfg.value_payload {
        config::ValuePayload::PartsOnly => ValuePayload::PartsOnly,
        config::ValuePayload::ProposalOnly => ValuePayload::ProposalOnly,
        config::ValuePayload::ProposalAndParts => ValuePayload::ProposalAndParts,
    };

    let consensus_params = ConsensusParams {
        initial_height,
        initial_validator_set,
        address,
        threshold_params: Default::default(),
        value_payload,
    };

    Consensus::spawn(
        ctx,
        consensus_params,
        cfg.timeouts,
        signing_provider,
        network,
        host,
        wal,
        sync,
        metrics,
        tx_event,
        Span::current(),
    )
    .await
    .map_err(Into::into)
}

pub async fn spawn_wal_actor<Ctx, Codec>(
    ctx: &Ctx,
    codec: Codec,
    home_dir: &Path,
    registry: &SharedRegistry,
) -> Result<WalRef<Ctx>>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    let wal_dir = home_dir.join("wal");
    std::fs::create_dir_all(&wal_dir).unwrap();

    let wal_file = wal_dir.join("consensus.wal");

    Wal::spawn(ctx, codec, wal_file, registry.clone(), Span::current())
        .await
        .map_err(Into::into)
}

pub async fn spawn_sync_actor<Ctx>(
    ctx: Ctx,
    network: NetworkRef<Ctx>,
    host: HostRef<Ctx>,
    config: &ValueSyncConfig,
    registry: &SharedRegistry,
) -> Result<Option<SyncRef<Ctx>>>
where
    Ctx: Context,
{
    if !config.enabled {
        return Ok(None);
    }

    let params = SyncParams {
        status_update_interval: config.status_update_interval,
        request_timeout: config.request_timeout,
    };

    let metrics = sync::Metrics::register(registry);

    let actor_ref = Sync::spawn(ctx, network, host, params, metrics, Span::current()).await?;

    Ok(Some(actor_ref))
}

fn make_gossip_config(cfg: &ConsensusConfig) -> NetworkConfig {
    NetworkConfig {
        listen_addr: cfg.p2p.listen_addr.clone(),
        persistent_peers: cfg.p2p.persistent_peers.clone(),
        discovery: DiscoveryConfig {
            enabled: cfg.p2p.discovery.enabled,
            ..Default::default()
        },
        idle_connection_timeout: Duration::from_secs(15 * 60),
        transport: malachitebft_network::TransportProtocol::from_multiaddr(&cfg.p2p.listen_addr)
            .unwrap_or_else(|| {
                panic!(
                    "No valid transport protocol found in listen address: {}",
                    cfg.p2p.listen_addr
                )
            }),
        pubsub_protocol: match cfg.p2p.protocol {
            PubSubProtocol::GossipSub(_) => malachitebft_network::PubSubProtocol::GossipSub,
            PubSubProtocol::Broadcast => malachitebft_network::PubSubProtocol::Broadcast,
        },
        gossipsub: match cfg.p2p.protocol {
            PubSubProtocol::GossipSub(config) => GossipSubConfig {
                mesh_n: config.mesh_n(),
                mesh_n_high: config.mesh_n_high(),
                mesh_n_low: config.mesh_n_low(),
                mesh_outbound_min: config.mesh_outbound_min(),
            },
            PubSubProtocol::Broadcast => GossipSubConfig::default(),
        },
        rpc_max_size: cfg.p2p.rpc_max_size.as_u64() as usize,
        pubsub_max_size: cfg.p2p.pubsub_max_size.as_u64() as usize,
        enable_sync: true,
    }
}

```
---
### `app/src/types.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Re-export of all types required to build a Malachite application.

pub use libp2p_identity::Keypair;

pub use malachitebft_core_consensus::{
    ConsensusMsg, ProposedValue, SignedConsensusMsg, ValuePayload,
};
pub use malachitebft_engine::host::LocallyProposedValue;
pub use malachitebft_peer::PeerId;

pub mod core {
    pub use malachitebft_core_types::*;
}

pub mod streaming {
    pub use malachitebft_engine::util::streaming::{Sequence, StreamId, StreamMessage};
}

pub mod sync {
    pub use malachitebft_sync::{Metrics, RawDecidedValue, Request, Response, Status};
}

pub mod codec {
    pub use malachitebft_codec::Codec;
    pub use malachitebft_engine::consensus::ConsensusCodec;
    pub use malachitebft_engine::sync::SyncCodec;
    pub use malachitebft_engine::wal::WalCodec;
}

```
---
### `app-channel/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-app-channel"
description = "High-level interface for building channel-based applications on top of the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
bytes.workspace = true
derive-where.workspace = true
eyre.workspace = true
ractor.workspace = true
tokio.workspace = true
tracing.workspace = true

malachitebft-app.workspace = true
malachitebft-engine.workspace = true
malachitebft-config.workspace = true

[lints]
workspace = true

[dev-dependencies]
malachitebft-test.workspace = true
rand.workspace = true

```
---
### `app-channel/src/connector.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
//! Implementation of a host actor for bridiging consensus and the application via a set of channels.

use derive_where::derive_where;
use ractor::{async_trait, Actor, ActorProcessingErr, ActorRef, SpawnErr};
use tokio::sync::mpsc;
use tokio::sync::oneshot;
use tracing::error;

use malachitebft_app::types::core::ValueOrigin;
use malachitebft_engine::consensus::ConsensusMsg;
use malachitebft_engine::host::HostMsg;

use crate::app::metrics::Metrics;
use crate::app::types::core::Context;
use crate::msgs::AppMsg;

/// Actor for bridging consensus and the application via a set of channels.
///
/// This actor is responsible for forwarding messages from the
/// consensus actor to the application over a channel, and vice-versa.
pub struct Connector<Ctx>
where
    Ctx: Context,
{
    sender: mpsc::Sender<AppMsg<Ctx>>,

    // TODO: add some metrics
    #[allow(dead_code)]
    metrics: Metrics,
}

impl<Ctx> Connector<Ctx>
where
    Ctx: Context,
{
    pub fn new(sender: mpsc::Sender<AppMsg<Ctx>>, metrics: Metrics) -> Self {
        Connector { sender, metrics }
    }

    pub async fn spawn(
        sender: mpsc::Sender<AppMsg<Ctx>>,
        metrics: Metrics,
    ) -> Result<ActorRef<HostMsg<Ctx>>, SpawnErr>
    where
        Ctx: Context,
    {
        let (actor_ref, _) = Actor::spawn(None, Self::new(sender, metrics), ()).await?;
        Ok(actor_ref)
    }
}

#[derive_where(Default)]
pub struct State<Ctx: Context> {
    consensus: Option<ActorRef<ConsensusMsg<Ctx>>>,
}

impl<Ctx> Connector<Ctx>
where
    Ctx: Context,
{
    async fn handle_msg(
        &self,
        _myself: ActorRef<HostMsg<Ctx>>,
        msg: HostMsg<Ctx>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        match msg {
            HostMsg::ConsensusReady(consensus_ref) => {
                let (reply, rx) = oneshot::channel();
                self.sender.send(AppMsg::ConsensusReady { reply }).await?;

                let (start_height, validator_set) = rx.await?;
                consensus_ref.cast(ConsensusMsg::StartHeight(start_height, validator_set))?;

                state.consensus = Some(consensus_ref);
            }

            HostMsg::StartedRound {
                height,
                round,
                proposer,
            } => {
                let (reply_value, rx_value) = oneshot::channel();

                self.sender
                    .send(AppMsg::StartedRound {
                        height,
                        round,
                        proposer,
                        reply_value,
                    })
                    .await?;

                let Some(consensus) = &state.consensus else {
                    error!("Consensus actor not set");
                    return Ok(());
                };

                // Do not block processing of other messages while waiting for the values
                tokio::spawn({
                    let consensus = consensus.clone();
                    async move {
                        if let Ok(values) = rx_value.await {
                            for value in values {
                                let msg = ConsensusMsg::ReceivedProposedValue(
                                    value,
                                    ValueOrigin::Consensus,
                                );
                                if let Err(e) = consensus.cast(msg) {
                                    error!("Failed to send back undecided value to consensus: {e}");
                                }
                            }
                        }
                    }
                });
            }

            HostMsg::GetValue {
                height,
                round,
                timeout,
                reply_to,
            } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::GetValue {
                        height,
                        round,
                        timeout,
                        reply,
                    })
                    .await?;

                reply_to.send(rx.await?)?;
            }

            HostMsg::ExtendVote {
                height,
                round,
                value_id,
                reply_to,
            } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::ExtendVote {
                        height,
                        round,
                        value_id,
                        reply,
                    })
                    .await?;

                reply_to.send(rx.await?)?;
            }

            HostMsg::VerifyVoteExtension {
                height,
                round,
                value_id,
                extension,
                reply_to,
            } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::VerifyVoteExtension {
                        height,
                        round,
                        value_id,
                        extension,
                        reply,
                    })
                    .await?;

                reply_to.send(rx.await?)?;
            }

            HostMsg::RestreamValue {
                height,
                round,
                valid_round,
                address,
                value_id,
            } => {
                self.sender
                    .send(AppMsg::RestreamProposal {
                        height,
                        round,
                        valid_round,
                        address,
                        value_id,
                    })
                    .await?
            }

            HostMsg::GetHistoryMinHeight { reply_to } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::GetHistoryMinHeight { reply })
                    .await?;

                reply_to.send(rx.await?)?;
            }

            HostMsg::ReceivedProposalPart {
                from,
                part,
                reply_to,
            } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::ReceivedProposalPart { from, part, reply })
                    .await?;

                if let Some(value) = rx.await? {
                    reply_to.send(value)?;
                }
            }

            HostMsg::GetValidatorSet { height, reply_to } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::GetValidatorSet { height, reply })
                    .await?;

                reply_to.send(rx.await?)?;
            }

            HostMsg::Decided {
                certificate,
                extensions,
                consensus,
            } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::Decided {
                        certificate,
                        extensions,
                        reply,
                    })
                    .await?;

                consensus.cast(rx.await?.into())?;
            }

            HostMsg::GetDecidedValue { height, reply_to } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::GetDecidedValue { height, reply })
                    .await?;

                reply_to.send(rx.await?)?;
            }

            HostMsg::ProcessSyncedValue {
                height,
                round,
                validator_address,
                value_bytes,
                reply_to,
            } => {
                let (reply, rx) = oneshot::channel();

                self.sender
                    .send(AppMsg::ProcessSyncedValue {
                        height,
                        round,
                        proposer: validator_address,
                        value_bytes,
                        reply,
                    })
                    .await?;

                reply_to.send(rx.await?)?;
            }
        };

        Ok(())
    }
}

#[async_trait]
impl<Ctx> Actor for Connector<Ctx>
where
    Ctx: Context,
{
    type Msg = HostMsg<Ctx>;
    type State = State<Ctx>;
    type Arguments = ();

    async fn pre_start(
        &self,
        _myself: ActorRef<Self::Msg>,
        _args: Self::Arguments,
    ) -> Result<Self::State, ActorProcessingErr> {
        Ok(State::default())
    }

    async fn handle(
        &self,
        myself: ActorRef<Self::Msg>,
        msg: Self::Msg,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        if let Err(e) = self.handle_msg(myself, msg, state).await {
            tracing::error!("Error processing message: {e}");
        }

        Ok(())
    }
}

```
---
### `app-channel/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Channel-based interface for Malachite applications.

// TODO: Enforce proper documentation
// #![warn(
//     missing_docs,
//     clippy::empty_docs,
//     clippy::missing_errors_doc,
//     rustdoc::broken_intra_doc_links,
//     rustdoc::missing_crate_level_docs,
//     rustdoc::missing_doc_code_examples
// )]

pub use malachitebft_app as app;

mod connector;
mod spawn;

mod msgs;
pub use msgs::{AppMsg, Channels, ConsensusMsg, NetworkMsg, Reply};

mod run;
pub use run::start_engine;

```
---
### `app-channel/src/msgs.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use std::time::Duration;

use bytes::Bytes;
use derive_where::derive_where;
use malachitebft_app::types::core::ValueOrigin;
use tokio::sync::mpsc;
use tokio::sync::oneshot;

use malachitebft_app::consensus::VoteExtensionError;
use malachitebft_engine::consensus::Msg as ConsensusActorMsg;
use malachitebft_engine::network::Msg as NetworkActorMsg;
use malachitebft_engine::util::events::TxEvent;

use crate::app::types::core::{CommitCertificate, Context, Round, ValueId, VoteExtensions};
use crate::app::types::streaming::StreamMessage;
use crate::app::types::sync::RawDecidedValue;
use crate::app::types::{LocallyProposedValue, PeerId, ProposedValue};

pub type Reply<T> = oneshot::Sender<T>;

/// Channels created for application consumption
pub struct Channels<Ctx: Context> {
    /// Channel for receiving messages from consensus
    pub consensus: mpsc::Receiver<AppMsg<Ctx>>,
    /// Channel for sending messages to the networking layer
    pub network: mpsc::Sender<NetworkMsg<Ctx>>,
    /// Receiver of events, call `subscribe` to receive them
    pub events: TxEvent<Ctx>,
}

/// Messages sent from consensus to the application.
#[derive_where(Debug)]
pub enum AppMsg<Ctx: Context> {
    /// Notifies the application that consensus is ready.
    ///
    /// The application MAY reply with a message to instruct
    /// consensus to start at a given height.
    ConsensusReady {
        /// Channel for sending back the height to start at
        /// and the validator set for that height
        reply: Reply<(Ctx::Height, Ctx::ValidatorSet)>,
    },

    /// Notifies the application that a new consensus round has begun.
    StartedRound {
        /// Current consensus height
        height: Ctx::Height,
        /// Round that was just started
        round: Round,
        /// Proposer for that round
        proposer: Ctx::Address,
        /// Channel for sending back previously received undecided values to consensus
        reply_value: Reply<Vec<ProposedValue<Ctx>>>,
    },

    /// Requests the application to build a value for consensus to run on.
    ///
    /// The application MUST reply to this message with the requested value
    /// within the specified timeout duration.
    GetValue {
        /// Height for which the value is requested
        height: Ctx::Height,
        /// Round for which the value is requested
        round: Round,
        /// Maximum time allowed for the application to respond
        timeout: Duration,
        /// Channel for sending back the value just built to consensus
        reply: Reply<LocallyProposedValue<Ctx>>,
    },

    /// ExtendVote allows the application to extend the pre-commit vote with arbitrary data.
    ///
    /// When consensus is preparing to send a pre-commit vote, it first calls `ExtendVote`.
    /// The application then returns a blob of data called a vote extension.
    /// This data is opaque to the consensus algorithm but can contain application-specific information.
    /// The proposer of the next block will receive all vote extensions along with the commit certificate.
    ExtendVote {
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        reply: Reply<Option<Ctx::Extension>>,
    },

    /// Verify a vote extension
    ///
    /// If the vote extension is deemed invalid, the vote it was part of
    /// will be discarded altogether.
    VerifyVoteExtension {
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        extension: Ctx::Extension,
        reply: Reply<Result<(), VoteExtensionError>>,
    },

    /// Requests the application to re-stream a proposal that it has already seen.
    ///
    /// The application MUST re-publish again all the proposal parts pertaining
    /// to that value by sending [`NetworkMsg::PublishProposalPart`] messages through
    /// the [`Channels::network`] channel.
    RestreamProposal {
        /// Height of the proposal
        height: Ctx::Height,
        /// Round of the proposal
        round: Round,
        /// Rround at which the proposal was locked on
        valid_round: Round,
        /// Address of the original proposer
        address: Ctx::Address,
        /// Unique identifier of the proposed value
        value_id: ValueId<Ctx>,
    },

    /// Requests the earliest height available in the history maintained by the application.
    ///
    /// The application MUST respond with its earliest available height.
    GetHistoryMinHeight { reply: Reply<Ctx::Height> },

    /// Notifies the application that consensus has received a proposal part over the network.
    ///
    /// If this part completes the full proposal, the application MUST respond
    /// with the complete proposed value. Otherwise, it MUST respond with `None`.
    ReceivedProposalPart {
        /// Peer whom the proposal part was received from
        from: PeerId,
        /// Received proposal part, together with its stream metadata
        part: StreamMessage<Ctx::ProposalPart>,
        /// Channel for returning the complete value if the proposal is now complete
        reply: Reply<Option<ProposedValue<Ctx>>>,
    },

    /// Requests the validator set for a specific height
    GetValidatorSet {
        /// Height of the validator set to retrieve
        height: Ctx::Height,
        /// Channel for sending back the validator set
        reply: Reply<Option<Ctx::ValidatorSet>>,
    },

    /// Notifies the application that consensus has decided on a value.
    ///
    /// This message includes a commit certificate containing the ID of
    /// the value that was decided on, the height and round at which it was decided,
    /// and the aggregated signatures of the validators that committed to it.
    /// It also includes to the vote extensions received for that height.
    ///
    /// In response to this message, the application MAY send a [`ConsensusMsg::StartHeight`]
    /// message back to consensus, instructing it to start the next height.
    Decided {
        /// The certificate for the decided value
        certificate: CommitCertificate<Ctx>,

        /// The vote extensions received for that height
        extensions: VoteExtensions<Ctx>,

        /// Channel for instructing consensus to start the next height, if desired
        reply: Reply<ConsensusMsg<Ctx>>,
    },

    /// Requests a previously decided value from the application's storage.
    ///
    /// The application MUST respond with that value if available, or `None` otherwise.
    GetDecidedValue {
        /// Height of the decided value to retrieve
        height: Ctx::Height,
        /// Channel for sending back the decided value
        reply: Reply<Option<RawDecidedValue<Ctx>>>,
    },

    /// Notifies the application that a value has been synced from the network.
    /// This may happen when the node is catching up with the network.
    ///
    /// If a value can be decoded from the bytes provided, then the application MUST reply
    /// to this message with the decoded value.
    ProcessSyncedValue {
        /// Height of the synced value
        height: Ctx::Height,
        /// Round of the synced value
        round: Round,
        /// Address of the original proposer
        proposer: Ctx::Address,
        /// Raw encoded value data
        value_bytes: Bytes,
        /// Channel for sending back the proposed value, if successfully decoded
        reply: Reply<ProposedValue<Ctx>>,
    },
}

/// Messages sent from the application to consensus.
#[derive_where(Debug)]
pub enum ConsensusMsg<Ctx: Context> {
    /// Instructs consensus to start a new height with the given validator set.
    StartHeight(Ctx::Height, Ctx::ValidatorSet),

    /// Previousuly received value proposed by a validator
    ReceivedProposedValue(ProposedValue<Ctx>, ValueOrigin),

    /// Instructs consensus to restart at a given height with the given validator set.
    RestartHeight(Ctx::Height, Ctx::ValidatorSet),
}

impl<Ctx: Context> From<ConsensusMsg<Ctx>> for ConsensusActorMsg<Ctx> {
    fn from(msg: ConsensusMsg<Ctx>) -> ConsensusActorMsg<Ctx> {
        match msg {
            ConsensusMsg::StartHeight(height, validator_set) => {
                ConsensusActorMsg::StartHeight(height, validator_set)
            }
            ConsensusMsg::ReceivedProposedValue(value, origin) => {
                ConsensusActorMsg::ReceivedProposedValue(value, origin)
            }
            ConsensusMsg::RestartHeight(height, validator_set) => {
                ConsensusActorMsg::RestartHeight(height, validator_set)
            }
        }
    }
}

/// Messages sent from the application to the networking layer.
#[derive_where(Debug)]
pub enum NetworkMsg<Ctx: Context> {
    /// Publish a proposal part to the network, within a stream.
    PublishProposalPart(StreamMessage<Ctx::ProposalPart>),
}

impl<Ctx: Context> From<NetworkMsg<Ctx>> for NetworkActorMsg<Ctx> {
    fn from(msg: NetworkMsg<Ctx>) -> NetworkActorMsg<Ctx> {
        match msg {
            NetworkMsg::PublishProposalPart(part) => NetworkActorMsg::PublishProposalPart(part),
        }
    }
}

```
---
### `app-channel/src/run.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
//! Run Malachite consensus with the given configuration and context.
//! Provides the application with a channel for receiving messages from consensus.

use eyre::Result;

use malachitebft_engine::util::events::TxEvent;

use crate::app::metrics::{Metrics, SharedRegistry};
use crate::app::node::{self, EngineHandle, NodeConfig};
use crate::app::spawn::{
    spawn_consensus_actor, spawn_node_actor, spawn_sync_actor, spawn_wal_actor,
};
use crate::app::types::codec::{ConsensusCodec, SyncCodec, WalCodec};
use crate::app::types::core::Context;
use crate::spawn::{spawn_host_actor, spawn_network_actor};
use crate::Channels;

pub async fn start_engine<Node, Ctx, Codec>(
    ctx: Ctx,
    codec: Codec,
    node: Node,
    cfg: Node::Config,
    start_height: Option<Ctx::Height>,
    initial_validator_set: Ctx::ValidatorSet,
) -> Result<(Channels<Ctx>, EngineHandle)>
where
    Ctx: Context,
    Node: node::Node<Context = Ctx>,
    Codec: WalCodec<Ctx> + Clone,
    Codec: ConsensusCodec<Ctx>,
    Codec: SyncCodec<Ctx>,
{
    let start_height = start_height.unwrap_or_default();

    let registry = SharedRegistry::global().with_moniker(cfg.moniker());
    let metrics = Metrics::register(&registry);

    let private_key_file = node.load_private_key_file()?;
    let private_key = node.load_private_key(private_key_file);
    let public_key = node.get_public_key(&private_key);
    let address = node.get_address(&public_key);
    let keypair = node.get_keypair(private_key.clone());
    let signing_provider = node.get_signing_provider(private_key);

    // Spawn consensus gossip
    let (network, tx_network) =
        spawn_network_actor(cfg.consensus(), keypair, &registry, codec.clone()).await?;

    let wal = spawn_wal_actor(&ctx, codec, &node.get_home_dir(), &registry).await?;

    // Spawn the host actor
    let (connector, rx_consensus) = spawn_host_actor(metrics.clone()).await?;

    let sync = spawn_sync_actor(
        ctx.clone(),
        network.clone(),
        connector.clone(),
        cfg.value_sync(),
        &registry,
    )
    .await?;

    let tx_event = TxEvent::new();

    // Spawn consensus
    let consensus = spawn_consensus_actor(
        start_height,
        initial_validator_set,
        address,
        ctx.clone(),
        cfg.consensus(),
        Box::new(signing_provider),
        network.clone(),
        connector.clone(),
        wal.clone(),
        sync.clone(),
        metrics,
        tx_event.clone(),
    )
    .await?;

    let (node, handle) = spawn_node_actor(ctx, network, consensus, wal, sync, connector).await?;

    let channels = Channels {
        consensus: rx_consensus,
        network: tx_network,
        events: tx_event,
    };

    let handle = EngineHandle {
        actor: node,
        handle,
    };

    Ok((channels, handle))
}

```
---
### `app-channel/src/spawn.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! Utility functions for spawning the actor system and connecting it to the application.

use eyre::Result;
use tokio::sync::mpsc;

use malachitebft_engine::consensus::ConsensusCodec;
use malachitebft_engine::host::HostRef;
use malachitebft_engine::network::NetworkRef;
use malachitebft_engine::sync::SyncCodec;

use crate::app;
use crate::app::config::ConsensusConfig;
use crate::app::metrics::Metrics;
use crate::app::metrics::SharedRegistry;
use crate::app::types::core::Context;
use crate::app::types::Keypair;
use crate::connector::Connector;
use crate::{AppMsg, NetworkMsg};

pub async fn spawn_host_actor<Ctx>(
    metrics: Metrics,
) -> Result<(HostRef<Ctx>, mpsc::Receiver<AppMsg<Ctx>>)>
where
    Ctx: Context,
{
    let (tx, rx) = mpsc::channel(128);
    let actor_ref = Connector::spawn(tx, metrics).await?;
    Ok((actor_ref, rx))
}

pub async fn spawn_network_actor<Ctx, Codec>(
    cfg: &ConsensusConfig,
    keypair: Keypair,
    registry: &SharedRegistry,
    codec: Codec,
) -> Result<(NetworkRef<Ctx>, mpsc::Sender<NetworkMsg<Ctx>>)>
where
    Ctx: Context,
    Codec: ConsensusCodec<Ctx>,
    Codec: SyncCodec<Ctx>,
{
    let (tx, mut rx) = mpsc::channel::<NetworkMsg<Ctx>>(1);

    let actor_ref = app::spawn::spawn_network_actor(cfg, keypair, registry, codec).await?;

    tokio::spawn({
        let actor_ref = actor_ref.clone();
        async move {
            while let Some(msg) = rx.recv().await {
                if let Err(e) = actor_ref.cast(msg.into()) {
                    tracing::error!("Failed to send message to network actor: {e}");
                }
            }
        }
    });

    Ok((actor_ref, tx))
}

```
---
### `codec/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-codec"
description = "Codec abstraction for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
bytes.workspace = true

[lints]
workspace = true

```
---
### `codec/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use core::error::Error;

use bytes::Bytes;

pub trait Codec<T>: Send + Sync + 'static {
    type Error: Error + Send;

    fn decode(&self, bytes: Bytes) -> Result<T, Self::Error>;
    fn encode(&self, msg: &T) -> Result<Bytes, Self::Error>;
}

```
---
### `config/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-config"
description = "Configuration for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[lints]
workspace = true

[dependencies]
malachitebft-core-types.workspace = true

bytesize = { workspace = true, features = ["serde"] }
config = { workspace = true }
humantime-serde = { workspace = true }
multiaddr = { workspace = true }
serde = { workspace = true, features = ["derive"] }

```
---
### `config/src/lib.rs`
*2025-05-18 23:58:49 | 21 KB*
```rust
use core::fmt;
use std::net::{IpAddr, SocketAddr};
use std::str::FromStr;
use std::time::Duration;

use bytesize::ByteSize;
use malachitebft_core_types::TimeoutKind;
use multiaddr::Multiaddr;
use serde::{Deserialize, Serialize};

/// P2P configuration options
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct P2pConfig {
    /// Address to listen for incoming connections
    pub listen_addr: Multiaddr,

    /// List of nodes to keep persistent connections to
    pub persistent_peers: Vec<Multiaddr>,

    /// Peer discovery
    #[serde(default)]
    pub discovery: DiscoveryConfig,

    /// The type of pub-sub protocol to use for consensus
    pub protocol: PubSubProtocol,

    /// The maximum size of messages to send over pub-sub
    pub pubsub_max_size: ByteSize,

    /// The maximum size of messages to send over RPC
    pub rpc_max_size: ByteSize,
}

impl Default for P2pConfig {
    fn default() -> Self {
        P2pConfig {
            listen_addr: Multiaddr::empty(),
            persistent_peers: vec![],
            discovery: Default::default(),
            protocol: Default::default(),
            rpc_max_size: ByteSize::mib(10),
            pubsub_max_size: ByteSize::mib(4),
        }
    }
}

/// Peer Discovery configuration options
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct DiscoveryConfig {
    /// Enable peer discovery
    #[serde(default)]
    pub enabled: bool,

    /// Bootstrap protocol
    #[serde(default)]
    pub bootstrap_protocol: BootstrapProtocol,

    /// Selector
    #[serde(default)]
    pub selector: Selector,

    /// Number of outbound peers
    #[serde(default)]
    pub num_outbound_peers: usize,

    /// Number of inbound peers
    #[serde(default)]
    pub num_inbound_peers: usize,

    /// Ephemeral connection timeout
    #[serde(default)]
    #[serde(with = "humantime_serde")]
    pub ephemeral_connection_timeout: Duration,
}

impl Default for DiscoveryConfig {
    fn default() -> Self {
        DiscoveryConfig {
            enabled: false,
            bootstrap_protocol: Default::default(),
            selector: Default::default(),
            num_outbound_peers: 0,
            num_inbound_peers: 20,
            ephemeral_connection_timeout: Default::default(),
        }
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum BootstrapProtocol {
    #[default]
    Kademlia,
    Full,
}

impl BootstrapProtocol {
    pub fn name(&self) -> &'static str {
        match self {
            Self::Kademlia => "kademlia",
            Self::Full => "full",
        }
    }
}

impl FromStr for BootstrapProtocol {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "kademlia" => Ok(Self::Kademlia),
            "full" => Ok(Self::Full),
            e => Err(format!(
                "unknown bootstrap protocol: {e}, available: kademlia, full"
            )),
        }
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Selector {
    #[default]
    Kademlia,
    Random,
}

impl Selector {
    pub fn name(&self) -> &'static str {
        match self {
            Self::Kademlia => "kademlia",
            Self::Random => "random",
        }
    }
}

impl FromStr for Selector {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "kademlia" => Ok(Self::Kademlia),
            "random" => Ok(Self::Random),
            e => Err(format!(
                "unknown selector: {e}, available: kademlia, random"
            )),
        }
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
pub enum TransportProtocol {
    #[default]
    Tcp,
    Quic,
}

impl TransportProtocol {
    pub fn multiaddr(&self, host: &str, port: usize) -> Multiaddr {
        match self {
            Self::Tcp => format!("/ip4/{host}/tcp/{port}").parse().unwrap(),
            Self::Quic => format!("/ip4/{host}/udp/{port}/quic-v1").parse().unwrap(),
        }
    }
}

impl FromStr for TransportProtocol {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "tcp" => Ok(Self::Tcp),
            "quic" => Ok(Self::Quic),
            e => Err(format!(
                "unknown transport protocol: {e}, available: tcp, quic"
            )),
        }
    }
}

/// The type of pub-sub protocol.
/// If multiple protocols are configured in the configuration file, the first one from this list
/// will be used.
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum PubSubProtocol {
    GossipSub(GossipSubConfig),
    Broadcast,
}

impl Default for PubSubProtocol {
    fn default() -> Self {
        Self::GossipSub(GossipSubConfig::default())
    }
}

/// GossipSub configuration
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(from = "gossipsub::RawConfig", default)]
pub struct GossipSubConfig {
    /// Target number of peers for the mesh network (D in the GossipSub spec)
    mesh_n: usize,

    /// Maximum number of peers in mesh network before removing some (D_high in the GossipSub spec)
    mesh_n_high: usize,

    /// Minimum number of peers in mesh network before adding more (D_low in the spec)
    mesh_n_low: usize,

    /// Minimum number of outbound peers in the mesh network before adding more (D_out in the spec).
    /// This value must be smaller or equal than `mesh_n / 2` and smaller than `mesh_n_low`.
    /// When this value is set to 0 or does not meet the above constraints,
    /// it will be calculated as `max(1, min(mesh_n / 2, mesh_n_low - 1))`
    mesh_outbound_min: usize,
}

impl Default for GossipSubConfig {
    fn default() -> Self {
        Self::new(6, 12, 4, 2)
    }
}

impl GossipSubConfig {
    /// Create a new, valid GossipSub configuration.
    pub fn new(
        mesh_n: usize,
        mesh_n_high: usize,
        mesh_n_low: usize,
        mesh_outbound_min: usize,
    ) -> Self {
        let mut result = Self {
            mesh_n,
            mesh_n_high,
            mesh_n_low,
            mesh_outbound_min,
        };

        result.adjust();
        result
    }

    /// Adjust the configuration values.
    pub fn adjust(&mut self) {
        use std::cmp::{max, min};

        if self.mesh_n == 0 {
            self.mesh_n = 6;
        }

        if self.mesh_n_high == 0 || self.mesh_n_high < self.mesh_n {
            self.mesh_n_high = self.mesh_n * 2;
        }

        if self.mesh_n_low == 0 || self.mesh_n_low > self.mesh_n {
            self.mesh_n_low = self.mesh_n * 2 / 3;
        }

        if self.mesh_outbound_min == 0
            || self.mesh_outbound_min > self.mesh_n / 2
            || self.mesh_outbound_min >= self.mesh_n_low
        {
            self.mesh_outbound_min = max(1, min(self.mesh_n / 2, self.mesh_n_low - 1));
        }
    }

    pub fn mesh_n(&self) -> usize {
        self.mesh_n
    }

    pub fn mesh_n_high(&self) -> usize {
        self.mesh_n_high
    }

    pub fn mesh_n_low(&self) -> usize {
        self.mesh_n_low
    }

    pub fn mesh_outbound_min(&self) -> usize {
        self.mesh_outbound_min
    }
}

mod gossipsub {
    #[derive(serde::Deserialize)]
    pub struct RawConfig {
        #[serde(default)]
        mesh_n: usize,
        #[serde(default)]
        mesh_n_high: usize,
        #[serde(default)]
        mesh_n_low: usize,
        #[serde(default)]
        mesh_outbound_min: usize,
    }

    impl From<RawConfig> for super::GossipSubConfig {
        fn from(raw: RawConfig) -> Self {
            super::GossipSubConfig::new(
                raw.mesh_n,
                raw.mesh_n_high,
                raw.mesh_n_low,
                raw.mesh_outbound_min,
            )
        }
    }
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(tag = "load_type", rename_all = "snake_case")]
pub enum MempoolLoadType {
    NoLoad,
    UniformLoad(mempool_load::UniformLoadConfig),
    NonUniformLoad(mempool_load::NonUniformLoadConfig),
}

impl Default for MempoolLoadType {
    fn default() -> Self {
        Self::NoLoad
    }
}

pub mod mempool_load {
    use super::*;

    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    pub struct NonUniformLoadConfig {
        /// Base transaction count
        pub base_count: i32,

        /// Base transaction size
        pub base_size: i32,

        /// How much the transaction count can vary
        pub count_variation: std::ops::Range<i32>,

        /// How much the transaction size can vary
        pub size_variation: std::ops::Range<i32>,

        /// Chance of generating a spike.
        /// e.g. 0.1 = 10% chance of spike
        pub spike_probability: f64,

        /// Multiplier for spike transactions
        /// e.g. 10 = 10x more transactions during spike
        pub spike_multiplier: usize,

        /// Range of intervals between generating load, in milliseconds
        pub sleep_interval: std::ops::Range<u64>,
    }

    impl Default for NonUniformLoadConfig {
        fn default() -> Self {
            Self {
                base_count: 100,
                base_size: 256,
                count_variation: -100..200,
                size_variation: -64..128,
                spike_probability: 0.10,
                spike_multiplier: 2,
                sleep_interval: 1000..5000,
            }
        }
    }

    #[derive(Copy, Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
    pub struct UniformLoadConfig {
        /// Interval at which to generate load
        #[serde(with = "humantime_serde")]
        pub interval: Duration,

        /// Number of transactions to generate
        pub count: usize,

        /// Size of each generated transaction
        pub size: ByteSize,
    }

    impl Default for UniformLoadConfig {
        fn default() -> Self {
            Self {
                interval: Duration::from_secs(1),
                count: 1000,
                size: ByteSize::b(256),
            }
        }
    }
}

/// Mempool configuration options
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct MempoolLoadConfig {
    /// Mempool loading type
    #[serde(flatten)]
    pub load_type: MempoolLoadType,
}

/// Mempool configuration options
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct MempoolConfig {
    /// P2P configuration options
    pub p2p: P2pConfig,

    /// Maximum number of transactions
    pub max_tx_count: usize,

    /// Maximum number of transactions to gossip at once in a batch
    pub gossip_batch_size: usize,

    /// Mempool load configuration options
    pub load: MempoolLoadConfig,
}

/// ValueSync configuration options
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct ValueSyncConfig {
    /// Enable ValueSync
    pub enabled: bool,

    /// Interval at which to update other peers of our status
    #[serde(with = "humantime_serde")]
    pub status_update_interval: Duration,

    /// Timeout duration for sync requests
    #[serde(with = "humantime_serde")]
    pub request_timeout: Duration,
}

impl Default for ValueSyncConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            status_update_interval: Duration::from_secs(10),
            request_timeout: Duration::from_secs(10),
        }
    }
}

/// Consensus configuration options
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct ConsensusConfig {
    /// Timeouts
    #[serde(flatten)]
    pub timeouts: TimeoutConfig,

    /// P2P configuration options
    pub p2p: P2pConfig,

    /// Message types that can carry values
    pub value_payload: ValuePayload,
}

/// Message types required by consensus to deliver the value being proposed
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
pub enum ValuePayload {
    #[default]
    PartsOnly,
    ProposalOnly, // TODO - add small block app to test this option
    ProposalAndParts,
}

impl ValuePayload {
    pub fn include_parts(&self) -> bool {
        match self {
            Self::ProposalOnly => false,
            Self::PartsOnly | Self::ProposalAndParts => true,
        }
    }

    pub fn include_proposal(&self) -> bool {
        match self {
            Self::PartsOnly => false,
            Self::ProposalOnly | Self::ProposalAndParts => true,
        }
    }
}

/// Timeouts
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TimeoutConfig {
    /// How long we wait for a proposal block before prevoting nil
    #[serde(with = "humantime_serde")]
    pub timeout_propose: Duration,

    /// How much timeout_propose increases with each round
    #[serde(with = "humantime_serde")]
    pub timeout_propose_delta: Duration,

    /// How long we wait after receiving +2/3 prevotes for anything (ie. not a single block or nil)
    #[serde(with = "humantime_serde")]
    pub timeout_prevote: Duration,

    /// How much the timeout_prevote increases with each round
    #[serde(with = "humantime_serde")]
    pub timeout_prevote_delta: Duration,

    /// How long we wait after receiving +2/3 precommits for anything (ie. not a single block or nil)
    #[serde(with = "humantime_serde")]
    pub timeout_precommit: Duration,

    /// How much the timeout_precommit increases with each round
    #[serde(with = "humantime_serde")]
    pub timeout_precommit_delta: Duration,

    /// How long we wait after entering a round before starting
    /// the rebroadcast liveness protocol    
    #[serde(with = "humantime_serde")]
    pub timeout_rebroadcast: Duration,
}

impl TimeoutConfig {
    pub fn timeout_duration(&self, step: TimeoutKind) -> Duration {
        match step {
            TimeoutKind::Propose => self.timeout_propose,
            TimeoutKind::Prevote => self.timeout_prevote,
            TimeoutKind::Precommit => self.timeout_precommit,
            TimeoutKind::Rebroadcast => {
                self.timeout_propose + self.timeout_prevote + self.timeout_precommit
            }
        }
    }

    pub fn delta_duration(&self, step: TimeoutKind) -> Option<Duration> {
        match step {
            TimeoutKind::Propose => Some(self.timeout_propose_delta),
            TimeoutKind::Prevote => Some(self.timeout_prevote_delta),
            TimeoutKind::Precommit => Some(self.timeout_precommit_delta),
            TimeoutKind::Rebroadcast => None,
        }
    }
}

impl Default for TimeoutConfig {
    fn default() -> Self {
        let timeout_propose = Duration::from_secs(3);
        let timeout_prevote = Duration::from_secs(1);
        let timeout_precommit = Duration::from_secs(1);
        let timeout_rebroadcast = timeout_propose + timeout_prevote + timeout_precommit;

        Self {
            timeout_propose,
            timeout_propose_delta: Duration::from_millis(500),
            timeout_prevote,
            timeout_prevote_delta: Duration::from_millis(500),
            timeout_precommit,
            timeout_precommit_delta: Duration::from_millis(500),
            timeout_rebroadcast,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct MetricsConfig {
    /// Enable the metrics server
    pub enabled: bool,

    /// Address at which to serve the metrics at
    pub listen_addr: SocketAddr,
}

impl Default for MetricsConfig {
    fn default() -> Self {
        MetricsConfig {
            enabled: false,
            listen_addr: SocketAddr::new(IpAddr::from([127, 0, 0, 1]), 9000),
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "flavor", rename_all = "snake_case")]
pub enum RuntimeConfig {
    /// Single-threaded runtime
    #[default]
    SingleThreaded,

    /// Multi-threaded runtime
    MultiThreaded {
        /// Number of worker threads
        worker_threads: usize,
    },
}

impl RuntimeConfig {
    pub fn single_threaded() -> Self {
        Self::SingleThreaded
    }

    pub fn multi_threaded(worker_threads: usize) -> Self {
        Self::MultiThreaded { worker_threads }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct VoteExtensionsConfig {
    pub enabled: bool,
    pub size: ByteSize,
}

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TestConfig {
    pub max_block_size: ByteSize,
    pub txs_per_part: usize,
    pub time_allowance_factor: f32,
    #[serde(with = "humantime_serde")]
    pub exec_time_per_tx: Duration,
    pub max_retain_blocks: usize,
    #[serde(default)]
    pub vote_extensions: VoteExtensionsConfig,
    #[serde(default)]
    pub stable_block_times: bool,
}

impl Default for TestConfig {
    fn default() -> Self {
        Self {
            max_block_size: ByteSize::mib(1),
            txs_per_part: 256,
            time_allowance_factor: 0.5,
            exec_time_per_tx: Duration::from_millis(1),
            max_retain_blocks: 1000,
            vote_extensions: VoteExtensionsConfig::default(),
            stable_block_times: false,
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct LoggingConfig {
    pub log_level: LogLevel,
    pub log_format: LogFormat,
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum LogLevel {
    Trace,
    #[default]
    Debug,
    Warn,
    Info,
    Error,
}

impl FromStr for LogLevel {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "trace" => Ok(LogLevel::Trace),
            "debug" => Ok(LogLevel::Debug),
            "warn" => Ok(LogLevel::Warn),
            "info" => Ok(LogLevel::Info),
            "error" => Ok(LogLevel::Error),
            e => Err(format!("Invalid log level: {e}")),
        }
    }
}

impl fmt::Display for LogLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogLevel::Trace => write!(f, "trace"),
            LogLevel::Debug => write!(f, "debug"),
            LogLevel::Warn => write!(f, "warn"),
            LogLevel::Info => write!(f, "info"),
            LogLevel::Error => write!(f, "error"),
        }
    }
}

#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum LogFormat {
    #[default]
    Plaintext,
    Json,
}

impl FromStr for LogFormat {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "plaintext" => Ok(LogFormat::Plaintext),
            "json" => Ok(LogFormat::Json),
            e => Err(format!("Invalid log format: {e}")),
        }
    }
}

impl fmt::Display for LogFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogFormat::Plaintext => write!(f, "plaintext"),
            LogFormat::Json => write!(f, "json"),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn log_format() {
        assert_eq!(
            LogFormat::from_str("yaml"),
            Err("Invalid log format: yaml".to_string())
        )
    }

    #[test]
    fn timeout_durations() {
        let t = TimeoutConfig::default();
        assert_eq!(t.timeout_duration(TimeoutKind::Propose), t.timeout_propose);
        assert_eq!(t.timeout_duration(TimeoutKind::Prevote), t.timeout_prevote);
        assert_eq!(
            t.timeout_duration(TimeoutKind::Precommit),
            t.timeout_precommit
        );
    }

    #[test]
    fn runtime_multi_threaded() {
        assert_eq!(
            RuntimeConfig::multi_threaded(5),
            RuntimeConfig::MultiThreaded { worker_threads: 5 }
        );
    }

    #[test]
    fn log_formatting() {
        assert_eq!(
            format!(
                "{} {} {} {} {}",
                LogLevel::Trace,
                LogLevel::Debug,
                LogLevel::Warn,
                LogLevel::Info,
                LogLevel::Error
            ),
            "trace debug warn info error"
        );

        assert_eq!(
            format!("{} {}", LogFormat::Plaintext, LogFormat::Json),
            "plaintext json"
        );
    }
}

```
---
### `core-consensus/Cargo.toml`
*2025-05-18 23:58:49 | 2 KB*
```toml
[package]
name = "informalsystems-malachitebft-core-consensus"
description = "Core consensus algorithm for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[features]
default = ["std", "metrics"]
std = ["malachitebft-core-driver/std"]
metrics = ["std", "dep:malachitebft-metrics"]
debug = ["std", "malachitebft-core-driver/debug"]

[dependencies]
malachitebft-core-types.workspace = true
malachitebft-core-driver.workspace = true
malachitebft-metrics = { workspace = true, optional = true }
malachitebft-peer.workspace = true

async-recursion = { workspace = true }
genawaiter = { workspace = true }
derive-where = { workspace = true }
multiaddr = { workspace = true }
thiserror = { workspace = true }
tracing = { workspace = true }

[lints]
workspace = true

[dev-dependencies]
malachitebft-test = { workspace = true }

```
---
### `core-consensus/src/effect.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
use derive_where::derive_where;

use malachitebft_core_types::*;

use crate::types::{LivenessMsg, SignedConsensusMsg};
use crate::{ConsensusMsg, VoteExtensionError, WalEntry};

/// Provides a way to construct the appropriate [`Resume`] value to
/// resume execution after handling an [`Effect`].
///
/// Eeach `Effect` embeds a value that implements [`Resumable`]
/// which is used to construct the appropriate [`Resume`] value.
///
/// ## Example
///
/// ```rust,ignore
/// fn effect_handler(effect: Effect<Ctx>) -> Result<Resume<Ctx>, Error> {
/// match effect {
///    Effect::ResetTimeouts(r) => {
///      reset_timeouts();
///      Ok(r.resume_with(()))
///    }
///    Effect::GetValidatorSet(height, r) => {)
///        let validator_set = get_validator_set(height);
///        Ok(r.resume_with(validator_set))
///    }
///    // ...
/// }
/// ```
pub trait Resumable<Ctx: Context> {
    /// The value type that will be used to resume execution
    type Value;

    /// Creates the appropriate [`Resume`] value to resume execution with.
    fn resume_with(self, value: Self::Value) -> Resume<Ctx>;
}

/// An effect which may be yielded by a consensus process.
///
/// Effects are handled by the caller using [`process!`][process]
/// and the consensus process is then resumed with an appropriate [`Resume`] value, as per
/// the documentation for each effect.
///
/// [process]: crate::process
#[must_use]
#[derive_where(Debug)]
pub enum Effect<Ctx>
where
    Ctx: Context,
{
    /// Reset all timeouts to their initial values
    ///
    /// Resume with: [`resume::Continue`]
    ResetTimeouts(resume::Continue),

    /// Cancel all outstanding timeouts
    ///
    /// Resume with: [`resume::Continue`]
    CancelAllTimeouts(resume::Continue),

    /// Cancel a given timeout
    ///
    /// Resume with: [`resume::Continue`]
    CancelTimeout(Timeout, resume::Continue),

    /// Schedule a timeout
    ///
    /// Resume with: [`resume::Continue`]
    ScheduleTimeout(Timeout, resume::Continue),

    /// Get the validator set at the given height, if known.
    ///
    /// Resume with: [`resume::ValidatorSet`]
    GetValidatorSet(Ctx::Height, resume::ValidatorSet),

    /// Consensus is starting a new round with the given proposer
    ///
    /// Resume with: [`resume::Continue`]
    StartRound(Ctx::Height, Round, Ctx::Address, resume::Continue),

    /// Publish a message to peers
    ///
    /// Resume with: [`resume::Continue`]
    PublishConsensusMsg(SignedConsensusMsg<Ctx>, resume::Continue),

    /// Publish a liveness message to peers
    ///
    /// Resume with: [`resume::Continue`]
    PublishLivenessMsg(LivenessMsg<Ctx>, resume::Continue),

    /// Rebroadcast a vote to peers
    ///
    /// Resume with: [`resume::Continue`]
    RebroadcastVote(SignedVote<Ctx>, resume::Continue),

    /// Rebroadcast a round certificate to peers
    ///
    /// Resume with: [`resume::Continue`]
    RebroadcastRoundCertificate(RoundCertificate<Ctx>, resume::Continue),

    /// Requests the application to build a value for consensus to run on.
    ///
    /// Because this operation may be asynchronous, this effect does not expect a resumption
    /// with a value, rather the application is expected to propose a value within the timeout duration.
    ///
    /// The application MUST eventually feed a [`Propose`][crate::input::Input::Propose]
    /// input to consensus within the specified timeout duration.
    ///
    /// Resume with: [`resume::Continue`]
    GetValue(Ctx::Height, Round, Timeout, resume::Continue),

    /// Requests the application to re-stream a proposal that it has already seen.
    ///
    /// The application MUST re-publish again to its peers all
    /// the proposal parts pertaining to that value.
    ///
    /// Resume with: [`resume::Continue`]
    RestreamProposal(
        /// Height of the value
        Ctx::Height,
        /// Round of the value
        Round,
        /// Valid round of the value
        Round,
        /// Address of the proposer for that value
        Ctx::Address,
        /// Value ID of the value to restream
        ValueId<Ctx>,
        /// For resumption
        resume::Continue,
    ),

    /// Notifies the application that consensus has decided on a value.
    ///
    /// This message includes a commit certificate containing the ID of
    /// the value that was decided on, the height and round at which it was decided,
    /// and the aggregated signatures of the validators that committed to it.
    ///
    /// It also includes the vote extensions that were received for this height.
    ///
    /// Resume with: [`resume::Continue`]
    Decide(
        CommitCertificate<Ctx>,
        VoteExtensions<Ctx>,
        resume::Continue,
    ),

    /// Sign a vote with this node's private key
    ///
    /// Resume with: [`resume::SignedVote`]
    SignVote(Ctx::Vote, resume::SignedVote),

    /// Sign a proposal with this node's private key
    ///
    /// Resume with: [`resume::SignedProposal`]
    SignProposal(Ctx::Proposal, resume::SignedProposal),

    /// Verify a signature
    ///
    /// Resume with: [`resume::SignatureValidity`]
    VerifySignature(
        SignedMessage<Ctx, ConsensusMsg<Ctx>>,
        PublicKey<Ctx>,
        resume::SignatureValidity,
    ),

    /// Verify a commit certificate
    ///
    /// Resume with: [`resume::CertificateValidity`]
    VerifyCommitCertificate(
        CommitCertificate<Ctx>,
        Ctx::ValidatorSet,
        ThresholdParams,
        resume::CertificateValidity,
    ),

    /// Verify a polka certificate
    ///
    /// Resume with: [`resume::CertificateValidity`]
    VerifyPolkaCertificate(
        PolkaCertificate<Ctx>,
        Ctx::ValidatorSet,
        ThresholdParams,
        resume::CertificateValidity,
    ),

    /// Append an entry to the Write-Ahead Log for crash recovery
    ///
    /// Resume with: [`resume::Continue`]`
    WalAppend(WalEntry<Ctx>, resume::Continue),

    /// Allows the application to extend the pre-commit vote with arbitrary data.
    ///
    /// When consensus is preparing to send a pre-commit vote, it first calls `ExtendVote`.
    /// The application then returns a blob of data called a vote extension.
    /// This data is opaque to the consensus algorithm but can contain application-specific information.
    /// The proposer of the next block will receive all vote extensions along with the commit certificate.
    ///
    /// Only emitted if vote extensions are enabled.
    ExtendVote(Ctx::Height, Round, ValueId<Ctx>, resume::VoteExtension),

    /// Verify a vote extension
    ///
    /// If the vote extension is deemed invalid, the vote it was part of
    /// will be discarded altogether.
    ///
    ///
    /// Only emitted if vote extensions are enabled.
    ///
    /// Resume with: [`resume::VoteExtensionValidity`]
    VerifyVoteExtension(
        Ctx::Height,
        Round,
        ValueId<Ctx>,
        SignedExtension<Ctx>,
        PublicKey<Ctx>,
        resume::VoteExtensionValidity,
    ),
}

/// A value with which the consensus process can be resumed after yielding an [`Effect`].
#[must_use]
#[allow(clippy::manual_non_exhaustive)]
#[derive_where(Debug)]
pub enum Resume<Ctx>
where
    Ctx: Context,
{
    /// Internal effect to start the coroutine.
    #[doc(hidden)]
    Start,

    /// Resume execution
    Continue,

    /// Resume execution with `Some(Ctx::ValidatorSet)` if a validator set
    /// was successfully fetched, or `None` otherwise.
    ValidatorSet(Option<Ctx::ValidatorSet>),

    /// Resume execution with the validity of the signature
    SignatureValidity(bool),

    /// Resume execution with the signed vote
    SignedVote(SignedMessage<Ctx, Ctx::Vote>),

    /// Resume execution with the signed proposal
    SignedProposal(SignedMessage<Ctx, Ctx::Proposal>),

    /// Resume with an optional vote extension.
    /// See the [`Effect::ExtendVote`] effect for more information.
    VoteExtension(Option<SignedExtension<Ctx>>),

    /// Resume execution with the result of the verification of the [`SignedExtension`]
    VoteExtensionValidity(Result<(), VoteExtensionError>),

    /// Resume execution with the result of the verification of the [`CommitCertificate`]
    CertificateValidity(Result<(), CertificateError<Ctx>>),
}

pub mod resume {
    use crate::VoteExtensionError;

    use super::*;

    #[derive(Debug, Default)]
    pub struct Continue;

    impl<Ctx: Context> Resumable<Ctx> for Continue {
        type Value = ();

        fn resume_with(self, _: ()) -> Resume<Ctx> {
            Resume::Continue
        }
    }

    #[derive(Debug, Default)]
    pub struct ValidatorSet;

    impl<Ctx: Context> Resumable<Ctx> for ValidatorSet {
        type Value = Option<Ctx::ValidatorSet>;

        fn resume_with(self, value: Self::Value) -> Resume<Ctx> {
            Resume::ValidatorSet(value)
        }
    }

    #[derive(Debug, Default)]
    pub struct SignatureValidity;

    impl<Ctx: Context> Resumable<Ctx> for SignatureValidity {
        type Value = bool;

        fn resume_with(self, value: Self::Value) -> Resume<Ctx> {
            Resume::SignatureValidity(value)
        }
    }

    #[derive(Debug, Default)]
    pub struct SignedVote;

    impl<Ctx: Context> Resumable<Ctx> for SignedVote {
        type Value = SignedMessage<Ctx, Ctx::Vote>;

        fn resume_with(self, value: Self::Value) -> Resume<Ctx> {
            Resume::SignedVote(value)
        }
    }

    #[derive(Debug, Default)]
    pub struct SignedProposal;

    impl<Ctx: Context> Resumable<Ctx> for SignedProposal {
        type Value = SignedMessage<Ctx, Ctx::Proposal>;

        fn resume_with(self, a: Self::Value) -> Resume<Ctx> {
            Resume::SignedProposal(a)
        }
    }

    #[derive(Debug, Default)]
    pub struct VoteExtension;

    impl<Ctx: Context> Resumable<Ctx> for VoteExtension {
        type Value = Option<SignedExtension<Ctx>>;

        fn resume_with(self, value: Self::Value) -> Resume<Ctx> {
            Resume::VoteExtension(value)
        }
    }

    #[derive(Debug, Default)]
    pub struct CertificateValidity;

    impl<Ctx: Context> Resumable<Ctx> for CertificateValidity {
        type Value = Result<(), CertificateError<Ctx>>;

        fn resume_with(self, value: Self::Value) -> Resume<Ctx> {
            Resume::CertificateValidity(value)
        }
    }

    #[derive(Debug, Default)]
    pub struct VoteExtensionValidity;

    impl<Ctx: Context> Resumable<Ctx> for VoteExtensionValidity {
        type Value = Result<(), VoteExtensionError>;

        fn resume_with(self, value: Self::Value) -> Resume<Ctx> {
            Resume::VoteExtensionValidity(value)
        }
    }
}

```
---
### `core-consensus/src/error.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use derive_where::derive_where;

use malachitebft_core_driver::Error as DriverError;
use malachitebft_core_types::{CertificateError, CommitCertificate, Context, Round};

use crate::effect::Resume;

/// The types of error that can be emitted by the consensus process.
#[derive_where(Debug)]
#[derive(thiserror::Error)]
#[allow(private_interfaces)]
pub enum Error<Ctx>
where
    Ctx: Context,
{
    /// The consensus process was resumed with a value which
    /// does not match the expected type of resume value.
    #[allow(private_interfaces)]
    #[error("Unexpected resume: {0:?}, expected one of: {1}")]
    UnexpectedResume(Resume<Ctx>, &'static str),

    /// The proposer was not found at the given height and round.
    #[error("Proposer not found at height {0} and round {1}")]
    ProposerNotFound(Ctx::Height, Round),

    /// State machine has no decision in commit step.
    #[error("State machine has no decision in commit step")]
    DecisionNotFound(Ctx::Height, Round),

    /// Driver proposal not found in commit step.
    #[error("Driver proposal not found in commit step")]
    DriverProposalNotFound(Ctx::Height, Round),

    /// Full proposal not found in commit step.
    #[error("Full proposal not found in commit step")]
    FullProposalNotFound(Ctx::Height, Round),

    /// The driver failed to process an input.
    #[error("Driver failed to process input, reason: {0}")]
    DriverProcess(DriverError<Ctx>),

    /// The validator set was not found at the given height.
    #[error("Validator set not found at height {0}")]
    ValidatorSetNotFound(Ctx::Height),

    /// The certificate is invalid.
    #[error("Invalid certificate: {1}")]
    InvalidCommitCertificate(CommitCertificate<Ctx>, CertificateError<Ctx>),
}

```
---
### `core-consensus/src/full_proposal.rs`
*2025-05-18 23:58:49 | 15 KB*
```rust
use std::collections::BTreeMap;

use derive_where::derive_where;

use malachitebft_core_types::{Context, Proposal, Round, SignedProposal, Validity, Value, ValueId};

use crate::ProposedValue;

/// A full proposal, ie. a proposal together with its value and validity.
#[derive_where(Clone, Debug)]
pub struct FullProposal<Ctx: Context> {
    /// Value received from the builder
    pub builder_value: Ctx::Value,
    /// Validity of the proposal
    pub validity: Validity,
    /// Proposal consensus message
    pub proposal: SignedProposal<Ctx>,
}

impl<Ctx: Context> FullProposal<Ctx> {
    pub fn new(
        builder_value: Ctx::Value,
        validity: Validity,
        proposal: SignedProposal<Ctx>,
    ) -> Self {
        Self {
            builder_value,
            validity,
            proposal,
        }
    }
}

/// An entry in the keeper.
#[derive_where(Clone, Debug)]
enum Entry<Ctx: Context> {
    /// The full proposal has been received,i.e. both the value and the proposal.
    Full(FullProposal<Ctx>),

    /// Only the proposal has been received.
    ProposalOnly(SignedProposal<Ctx>),

    /// Only the value has been received.
    ValueOnly(Ctx::Value, Validity),

    // This is a placeholder for converting a partial
    // entry (`ProposalOnly` or `ValueOnly`) to a full entry (`Full`).
    // It is never actually stored in the keeper.
    #[doc(hidden)]
    Empty,
}

impl<Ctx: Context> Entry<Ctx> {
    fn full(value: Ctx::Value, validity: Validity, proposal: SignedProposal<Ctx>) -> Self {
        Entry::Full(FullProposal::new(value, validity, proposal))
    }

    fn id(&self) -> Option<ValueId<Ctx>> {
        match self {
            Entry::Full(p) => Some(p.builder_value.id()),
            Entry::ProposalOnly(p) => Some(p.value().id()),
            Entry::ValueOnly(v, _) => Some(v.id()),
            Entry::Empty => None,
        }
    }
}

#[allow(clippy::derivable_impls)]
impl<Ctx: Context> Default for Entry<Ctx> {
    fn default() -> Self {
        Entry::Empty
    }
}

/// Keeper for collecting proposed values and consensus proposals for a given height and round.
///
/// When a new_value is received from the value builder the following entry is stored:
/// `Entry::ValueOnly(new_value.value, new_value.validity)`
///
/// When a new_proposal is received from consensus gossip the following entry is stored:
/// `Entry::ProposalOnly(new_proposal)`
///
/// When both proposal and values have been received, the entry for `(height, round)` should be:
/// `Entry::Full(FullProposal(value.value, value.validity, proposal))`
///
/// It is possible that a proposer sends two (builder_value, proposal) pairs for same `(height, round)`.
/// In this case both are stored, and we consider that the proposer is equivocating.
/// Currently, the actual equivocation is caught in the driver, through consensus actor
/// propagating both proposals.
///
/// When a new_proposal is received at most one complete proposal can be created. If a value at
/// proposal round is found, they are matched together. Otherwise, a value at the pol_round
/// is looked up and matched to form a full proposal (L28).
///
/// When a new value is received it is matched against the proposal at value round, and any proposal
/// at higher round with pol_round equal to the value round (L28). Therefore when a value is added
/// multiple complete proposals may form.
///
/// Note: For `parts_only` mode there is no explicit proposal wire message, instead
/// one is synthesized by the caller (`on_proposed_value` handler) before it invokes the `store_proposal` method.
#[derive_where(Clone, Debug, Default)]
pub struct FullProposalKeeper<Ctx: Context> {
    keeper: BTreeMap<(Ctx::Height, Round), Vec<Entry<Ctx>>>,
}

/// Replace a value in a mutable reference with a
/// new value if the old one matches the given pattern.
///
/// In our case, it temporarily replaces the entry with `Entry::Empty`,
/// and then replaces it with the new entry if the pattern matches.
macro_rules! replace_with {
    ($e:expr, $p:pat => $r:expr) => {
        *$e = match ::std::mem::take($e) {
            $p => $r,
            e => e,
        };
    };
}

impl<Ctx: Context> FullProposalKeeper<Ctx> {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn proposals_for_value(
        &self,
        proposed_value: &ProposedValue<Ctx>,
    ) -> Vec<SignedProposal<Ctx>> {
        let mut results = vec![];

        let first_key = &(proposed_value.height, proposed_value.round);
        let entries = self.keeper.range(first_key..);

        for (_, proposals) in entries {
            for entry in proposals {
                if let Entry::Full(p) = entry {
                    if p.proposal.value().id() == proposed_value.value.id() {
                        results.push(p.proposal.clone());
                    }
                }
            }
        }

        results
    }

    pub fn full_proposal_at_round_and_value(
        &self,
        height: &Ctx::Height,
        round: Round,
        value_id: &<Ctx::Value as Value>::Id,
    ) -> Option<&FullProposal<Ctx>> {
        let entries = self
            .keeper
            .get(&(*height, round))
            .filter(|entries| !entries.is_empty())?;

        for entry in entries {
            if let Entry::Full(p) = entry {
                if p.proposal.value().id() == *value_id {
                    return Some(p);
                }
            }
        }

        None
    }

    pub fn full_proposal_at_round_and_proposer(
        &self,
        height: &Ctx::Height,
        round: Round,
        proposer: &Ctx::Address,
    ) -> Option<&FullProposal<Ctx>> {
        let entries = self
            .keeper
            .get(&(*height, round))
            .filter(|entries| !entries.is_empty())?;

        for entry in entries {
            if let Entry::Full(p) = entry {
                if p.proposal.validator_address() == proposer {
                    return Some(p);
                }
            }
        }

        None
    }

    pub fn get_value<'a>(
        &self,
        height: &Ctx::Height,
        round: Round,
        value: &'a Ctx::Value,
    ) -> Option<(&'a Ctx::Value, Validity)> {
        let entries = self
            .keeper
            .get(&(*height, round))
            .filter(|entries| !entries.is_empty())?;

        for entry in entries {
            match entry {
                Entry::Full(p) if p.proposal.value().id() == value.id() => {
                    return Some((value, p.validity));
                }
                Entry::ValueOnly(v, validity) if v.id() == value.id() => {
                    return Some((value, *validity));
                }
                _ => continue,
            }
        }

        None
    }

    // Determines a new entry for L28 vs L22, L36, L49.
    // Called when a proposal is received, only if an entry for new_proposal's round and/ or value
    // is not found.
    fn new_entry(&self, new_proposal: SignedProposal<Ctx>) -> Entry<Ctx> {
        // L22, L36, L49
        if new_proposal.pol_round().is_nil() {
            return Entry::ProposalOnly(new_proposal);
        }

        // L28 - check if we have received a value at pol_round
        match self.get_value(
            &new_proposal.height(),
            new_proposal.pol_round(),
            new_proposal.value(),
        ) {
            // No value, create a proposal only entry
            None => Entry::ProposalOnly(new_proposal),

            // There is a value, create a full entry
            Some((v, validity)) => {
                Entry::Full(FullProposal::new(v.clone(), validity, new_proposal))
            }
        }
    }

    pub fn store_proposal(&mut self, new_proposal: SignedProposal<Ctx>) {
        let key = (new_proposal.height(), new_proposal.round());

        match self.keeper.get_mut(&key) {
            None => {
                // First time we see something (a proposal) for this height and round:
                // - if pol_round is Nil then create a partial proposal with just the proposal.
                // - if pol_round is defined and if a value at pol_round is present, add full entry,
                // - else just add the proposal.
                let new_entry = self.new_entry(new_proposal);
                self.keeper.insert(key, vec![new_entry]);
            }
            Some(entries) => {
                // We have seen values and/ or proposals for this height and round.
                // Iterate over the vector of full proposals and determine if a new entry needs
                // to be appended or an existing one has to be modified.
                for entry in entries.iter_mut() {
                    match entry {
                        Entry::Full(full_proposal) => {
                            if full_proposal.proposal.value().id() == new_proposal.value().id() {
                                // Redundant proposal, no need to check the pol_round if same value
                                return;
                            }
                        }
                        Entry::ValueOnly(value, _validity) => {
                            if value == new_proposal.value() {
                                // Found a matching value. Add the proposal
                                replace_with!(entry, Entry::ValueOnly(value, validity) => {
                                    Entry::full(value, validity, new_proposal)
                                });

                                return;
                            }
                        }
                        Entry::ProposalOnly(proposal) => {
                            if proposal.value().id() == new_proposal.value().id() {
                                // Redundant proposal, no need to check the pol_round if same value
                                return;
                            }
                        }
                        Entry::Empty => {
                            // Should not happen
                            panic!("Empty entry found");
                        }
                    }
                }

                // Append new partial proposal
                let new_entry = self.new_entry(new_proposal);
                self.keeper.entry(key).or_default().push(new_entry);
            }
        }
    }

    pub fn store_value(&mut self, new_value: &ProposedValue<Ctx>) {
        self.store_value_at_value_round(new_value);
        self.store_value_at_pol_round(new_value);
    }

    pub fn value_exists(&self, value: &ProposedValue<Ctx>) -> bool {
        match self.keeper.get(&(value.height, value.round)) {
            None => false,
            Some(entries) => entries
                .iter()
                .any(|entry| entry.id() == Some(value.value.id())),
        }
    }

    fn store_value_at_value_round(&mut self, new_value: &ProposedValue<Ctx>) {
        let key = (new_value.height, new_value.round);
        let entries = self.keeper.get_mut(&key);

        match entries {
            None => {
                // First time we see something (a proposed value) for this height and round
                // Create a full proposal with just the proposal
                let entry = Entry::ValueOnly(new_value.value.clone(), new_value.validity);
                self.keeper.insert(key, vec![entry]);
            }
            Some(entries) => {
                // We have seen proposals and/ or values for this height and round.
                // Iterate over the vector of full proposals and determine if a new entry needs
                // to be appended or an existing one has to be modified.
                for entry in entries.iter_mut() {
                    match entry {
                        Entry::ProposalOnly(proposal) => {
                            if proposal.value().id() == new_value.value.id() {
                                // Found a matching proposal. Change the entry at index i
                                replace_with!(entry, Entry::ProposalOnly(proposal) => {
                                    Entry::full(new_value.value.clone(), new_value.validity, proposal)
                                });

                                return;
                            }
                        }
                        Entry::ValueOnly(value, ..) => {
                            if value.id() == new_value.value.id() {
                                // Same value received before, nothing to do.
                                return;
                            }
                        }
                        Entry::Full(full_proposal) => {
                            if full_proposal.proposal.value().id() == new_value.value.id() {
                                // Same value received before, nothing to do.
                                return;
                            }
                        }
                        Entry::Empty => {
                            // Should not happen
                            panic!("Empty entry found");
                        }
                    }
                }

                // Append new value
                entries.push(Entry::ValueOnly(
                    new_value.value.clone(),
                    new_value.validity,
                ));
            }
        }
    }

    fn store_value_at_pol_round(&mut self, new_value: &ProposedValue<Ctx>) {
        let first_key = (new_value.height, new_value.round);

        // Get all entries for rounds higher than the value round, in case
        // there are proposals with pol_round equal to value round.
        let entries = self.keeper.range_mut(first_key..);

        for (_, proposals) in entries {
            // We may have seen proposals and/ or values for this height and round.
            // Iterate over the vector of full proposals and determine if a new entry needs
            // to be appended or an existing one has to be modified.
            for entry in proposals {
                if let Entry::ProposalOnly(proposal) = entry {
                    if proposal.value().id() == new_value.value.id()
                        && (proposal.round() == new_value.round
                            || proposal.pol_round() == new_value.round)
                    {
                        // Found a matching proposal. Change the entry at index i
                        replace_with!(entry, Entry::ProposalOnly(proposal) => {
                            Entry::full(new_value.value.clone(), new_value.validity, proposal)
                        });
                    }
                }
            }
        }
    }

    pub fn clear(&mut self) {
        self.keeper.clear();
    }
}

```
---
### `core-consensus/src/gen.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use genawaiter::sync as gen;
use genawaiter::GeneratorState;

use crate::effect::{Effect, Resume};
use crate::error::Error;

pub use gen::Gen;

#[allow(private_interfaces)]
pub type Co<Ctx> = gen::Co<Effect<Ctx>, Resume<Ctx>>;

pub type CoResult<Ctx> = GeneratorState<Effect<Ctx>, Result<(), Error<Ctx>>>;

```
---
### `core-consensus/src/handle/decide.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use crate::{handle::signature::verify_commit_certificate, prelude::*};

#[cfg_attr(not(feature = "metrics"), allow(unused_variables))]
pub async fn decide<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    assert!(state.driver.step_is_commit());

    let height = state.driver.height();
    let consensus_round = state.driver.round();

    let Some((proposal_round, decided_value)) = state.decided_value() else {
        return Err(Error::DecisionNotFound(height, consensus_round));
    };

    let decided_id = decided_value.id();

    // Look for an existing certificate
    let (certificate, extensions) = state
        .driver
        .commit_certificate(proposal_round, decided_id.clone())
        .cloned()
        .map(|certificate| (certificate, VoteExtensions::default()))
        .unwrap_or_else(|| {
            // Restore the commits. Note that they will be removed from `state`
            let mut commits = state.restore_precommits(height, proposal_round, &decided_value);

            let extensions = extract_vote_extensions(&mut commits);

            let certificate =
                CommitCertificate::new(height, proposal_round, decided_id.clone(), commits);

            (certificate, extensions)
        });

    let Some((proposal, _)) = state.driver.proposal_and_validity_for_round(proposal_round) else {
        return Err(Error::DriverProposalNotFound(height, proposal_round));
    };

    let Some(full_proposal) =
        state.full_proposal_at_round_and_value(&height, proposal_round, &decided_value)
    else {
        return Err(Error::FullProposalNotFound(height, proposal_round));
    };

    if proposal.value().id() != decided_id {
        info!(
            "Decide: driver proposal value id {} does not match the decided value id {}, this may happen if consensus and value sync run in parallel",
            proposal.value().id(),
            decided_id
        );
    }

    assert_eq!(full_proposal.builder_value.id(), decided_id);
    assert_eq!(full_proposal.proposal.value().id(), decided_id);
    assert_eq!(full_proposal.validity, Validity::Valid);

    // The certificate must be valid in Commit step
    assert_eq!(
        verify_commit_certificate(
            co,
            certificate.clone(),
            state.driver.validator_set().clone(),
            state.params.threshold_params,
        )
        .await?,
        Ok(()),
        "Commit certificate is not valid"
    );

    // Update metrics
    #[cfg(feature = "metrics")]
    {
        // We are only interested in consensus time for round 0, ie. in the happy path.
        if consensus_round == Round::new(0) {
            metrics.consensus_end();
        }

        metrics.block_end();
        metrics.finalized_blocks.inc();

        metrics
            .consensus_round
            .observe(consensus_round.as_i64() as f64);

        metrics
            .proposal_round
            .observe(proposal_round.as_i64() as f64);
    }

    #[cfg(feature = "debug")]
    {
        for trace in state.driver.get_traces() {
            debug!(%trace, "Consensus trace");
        }
    }

    perform!(
        co,
        Effect::Decide(certificate, extensions, Default::default())
    );

    Ok(())
}

// Extract vote extensions from a list of votes,
// removing them from each vote in the process.
pub fn extract_vote_extensions<Ctx: Context>(votes: &mut [SignedVote<Ctx>]) -> VoteExtensions<Ctx> {
    let extensions = votes
        .iter_mut()
        .filter_map(|vote| {
            vote.message
                .take_extension()
                .map(|e| (vote.validator_address().clone(), e))
        })
        .collect();

    VoteExtensions::new(extensions)
}

```
---
### `core-consensus/src/handle/driver.rs`
*2025-05-18 23:58:49 | 16 KB*
```rust
use malachitebft_core_driver::Input as DriverInput;
use malachitebft_core_driver::Output as DriverOutput;

use crate::handle::decide::decide;
use crate::handle::on_proposal;
use crate::handle::signature::sign_proposal;
use crate::handle::signature::sign_vote;
use crate::handle::vote::on_vote;
use crate::params::HIDDEN_LOCK_ROUND;
use crate::prelude::*;
use crate::types::{
    LivenessMsg, {LocallyProposedValue, SignedConsensusMsg},
};
use crate::util::pretty::PrettyVal;

use super::propose::on_propose;

#[async_recursion]
pub async fn apply_driver_input<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    input: DriverInput<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    match &input {
        DriverInput::NewRound(height, round, proposer) => {
            #[cfg(feature = "metrics")]
            metrics.round.set(round.as_i64());

            // Publishing the round certificate upon entering round > 0
            // is part of the new round synchronization mechanism, which
            // ensures all validators advance through rounds even in the
            // presence of asynchrony or Byzantine behavior. Moreover,
            // it guarantees that after GST, all correct replicas will receive
            // the round certificate and enter the same round within bounded time.
            if round > &Round::new(0) {
                if let Some(cert) = state.driver.round_certificate() {
                    if cert.enter_round == *round {
                        info!(
                            %cert.certificate.height,
                            %cert.enter_round,
                            number_of_votes = cert.certificate.round_signatures.len(),
                            "Sending round certificate"
                        );
                        perform!(
                            co,
                            Effect::PublishLivenessMsg(
                                LivenessMsg::SkipRoundCertificate(cert.certificate.clone()),
                                Default::default()
                            )
                        );
                    }
                }
            }

            info!(%height, %round, %proposer, "Starting new round");
            state.last_signed_prevote = None;
            state.last_signed_precommit = None;

            perform!(co, Effect::CancelAllTimeouts(Default::default()));
            perform!(
                co,
                Effect::StartRound(*height, *round, proposer.clone(), Default::default())
            );

            #[cfg(feature = "metrics")]
            metrics.rebroadcast_timeouts.inc();

            // Schedule rebroadcast timer
            let timeout = Timeout::rebroadcast(*round);
            perform!(co, Effect::ScheduleTimeout(timeout, Default::default()));
        }

        DriverInput::ProposeValue(round, _) => {
            perform!(
                co,
                Effect::CancelTimeout(Timeout::propose(*round), Default::default())
            );
        }

        DriverInput::Proposal(proposal, _validity) => {
            if proposal.height() != state.driver.height() {
                warn!(
                    "Ignoring proposal for height {}, current height: {}",
                    proposal.height(),
                    state.driver.height()
                );

                return Ok(());
            }
        }

        DriverInput::Vote(vote) => {
            if vote.height() != state.driver.height() {
                warn!(
                    "Ignoring vote for height {}, current height: {}",
                    vote.height(),
                    state.driver.height()
                );

                return Ok(());
            }
        }

        DriverInput::CommitCertificate(certificate) => {
            if certificate.height != state.driver.height() {
                warn!(
                    "Ignoring commit certificate for height {}, current height: {}",
                    certificate.height,
                    state.driver.height()
                );

                return Ok(());
            }
        }

        DriverInput::PolkaCertificate(certificate) => {
            if certificate.height != state.driver.height() {
                warn!(
                    "Ignoring polka certificate for height {}, current height: {}",
                    certificate.height,
                    state.driver.height()
                );

                return Ok(());
            }
        }

        DriverInput::TimeoutElapsed(_) => (),
    }

    // Record the step we were in
    let prev_step = state.driver.step();

    let outputs = state
        .driver
        .process(input)
        .map_err(|e| Error::DriverProcess(e))?;

    // Record the step we are now at
    let new_step = state.driver.step();

    // If the step has changed, update the metrics
    if prev_step != new_step {
        debug!(step.previous = ?prev_step, step.new = ?new_step, "Transitioned to new step");

        if let Some(valid) = &state.driver.valid_value() {
            if state.driver.step_is_propose() {
                info!(
                    round = %valid.round,
                    "Entering Propose step with a valid value"
                );
            }
        }

        #[cfg(feature = "metrics")]
        {
            metrics.step_end(prev_step);
            metrics.step_start(new_step);
        }
    }

    if prev_step != new_step && state.driver.step_is_prevote() {
        // Cancel the Propose timeout since we have moved from Propose to Prevote
        perform!(
            co,
            Effect::CancelTimeout(Timeout::propose(state.driver.round()), Default::default())
        );
    }

    process_driver_outputs(co, state, metrics, outputs).await?;

    Ok(())
}

async fn process_driver_outputs<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    outputs: Vec<DriverOutput<Ctx>>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    for output in outputs {
        process_driver_output(co, state, metrics, output).await?;
    }

    Ok(())
}

async fn process_driver_output<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    output: DriverOutput<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    match output {
        DriverOutput::NewRound(height, round) => {
            let proposer = state.get_proposer(height, round);
            apply_driver_input(
                co,
                state,
                metrics,
                DriverInput::NewRound(height, round, proposer.clone()),
            )
            .await
        }

        DriverOutput::Propose(proposal) => {
            info!(
                id = %proposal.value().id(),
                round = %proposal.round(),
                "Proposing value"
            );

            // Only sign and publish if we're in the validator set
            if state.is_validator() {
                let signed_proposal = sign_proposal(co, proposal.clone()).await?;

                if signed_proposal.pol_round().is_defined() {
                    perform!(
                        co,
                        Effect::RestreamProposal(
                            signed_proposal.height(),
                            signed_proposal.round(),
                            signed_proposal.pol_round(),
                            signed_proposal.validator_address().clone(),
                            signed_proposal.value().id(),
                            Default::default()
                        )
                    );
                }

                on_proposal(co, state, metrics, signed_proposal.clone()).await?;

                // Proposal messages should not be broadcasted if they are implicit,
                // instead they should be inferred from the block parts.
                if state.params.value_payload.include_proposal() {
                    perform!(
                        co,
                        Effect::PublishConsensusMsg(
                            SignedConsensusMsg::Proposal(signed_proposal),
                            Default::default()
                        )
                    );
                };

                // Publishing the polka certificate of the re-proposed value
                // ensures all validators receive it, which is necessary for
                // them to accept the re-proposed value.
                if proposal.pol_round().is_defined() {
                    // Broadcast the polka certificate at pol_round
                    let Some(polka_certificate) =
                        state.polka_certificate_at_round(proposal.pol_round())
                    else {
                        panic!(
                            "Missing polka certificate for pol_round {}",
                            proposal.pol_round()
                        );
                    };
                    perform!(
                        co,
                        Effect::PublishLivenessMsg(
                            LivenessMsg::PolkaCertificate(polka_certificate),
                            Default::default()
                        )
                    );
                }
            }

            Ok(())
        }

        DriverOutput::Vote(vote) => {
            // Upon locking, in addition to publishing a Precommit message,
            // a validator must request the application to restream the proposal,
            // publish the proposal message, and publish the polka certificate.
            // In other words, it must ensure that all validators receive the same events
            // that led it to lock a value. Together with the timeout mechanisms,
            // this guarantees that after GST, all correct validators will update
            // their validValue and validRound to these values in this round.
            // As a result, Malachite ensures liveness, because all validators
            // will be aware of the most recently locked value, and whichever validator
            // becomes the leader in one of the following rounds will propose a value
            // that all correct validators can accept.
            // Importantly, this mechanism does not need to be enabled from round 0,
            // as it is expensive; it can be activated from any round as a last-resort
            // backup to guarantee liveness.
            if vote.vote_type() == VoteType::Precommit
                && vote.value().is_val()
                && state.driver.round() >= HIDDEN_LOCK_ROUND
            {
                if let Some((signed_proposal, Validity::Valid)) =
                    state.driver.proposal_and_validity_for_round(vote.round())
                {
                    perform!(
                        co,
                        Effect::RestreamProposal(
                            signed_proposal.height(),
                            signed_proposal.round(),
                            signed_proposal.pol_round(),
                            signed_proposal.validator_address().clone(),
                            signed_proposal.value().id(),
                            Default::default()
                        )
                    );

                    if state.params.value_payload.include_proposal() {
                        perform!(
                            co,
                            Effect::PublishConsensusMsg(
                                SignedConsensusMsg::Proposal(signed_proposal.clone()),
                                Default::default()
                            )
                        );
                    }

                    let Some(polka_certificate) = state.polka_certificate_at_round(vote.round())
                    else {
                        panic!(
                            "Missing polka certificate for Precommit({:?}) at round {}",
                            vote.value(),
                            vote.round()
                        );
                    };
                    perform!(
                        co,
                        Effect::PublishLivenessMsg(
                            LivenessMsg::PolkaCertificate(polka_certificate),
                            Default::default()
                        )
                    );
                }
            }

            if state.is_validator() {
                info!(
                    vote_type = ?vote.vote_type(),
                    value = %PrettyVal(vote.value().as_ref()),
                    round = %vote.round(),
                    "Voting",
                );

                let extended_vote = extend_vote(co, vote).await?;
                let signed_vote = sign_vote(co, extended_vote).await?;

                on_vote(co, state, metrics, signed_vote.clone()).await?;

                perform!(
                    co,
                    Effect::PublishConsensusMsg(
                        SignedConsensusMsg::Vote(signed_vote.clone()),
                        Default::default()
                    )
                );

                state.set_last_vote(signed_vote);

                // Schedule rebroadcast timer
                let timeout = Timeout::rebroadcast(state.driver.round());
                perform!(co, Effect::ScheduleTimeout(timeout, Default::default()));
            }

            Ok(())
        }

        DriverOutput::Decide(consensus_round, proposal) => {
            info!(
                round = %consensus_round,
                height = %proposal.height(),
                value = %proposal.value().id(),
                "Decided",
            );

            decide(co, state, metrics).await?;

            Ok(())
        }

        DriverOutput::ScheduleTimeout(timeout) => {
            info!(round = %timeout.round, step = ?timeout.kind, "Scheduling timeout");

            perform!(co, Effect::ScheduleTimeout(timeout, Default::default()));

            Ok(())
        }

        DriverOutput::GetValue(height, round, timeout) => {
            if let Some(full_proposal) =
                state.full_proposal_at_round_and_proposer(&height, round, state.address())
            {
                info!(%height, %round, "Using already existing value");

                let local_value = LocallyProposedValue {
                    height: full_proposal.proposal.height(),
                    round: full_proposal.proposal.round(),
                    value: full_proposal.builder_value.clone(),
                };

                on_propose(co, state, metrics, local_value).await?;
            } else {
                info!(%height, %round, "Requesting value from application");

                perform!(
                    co,
                    Effect::GetValue(height, round, timeout, Default::default())
                );
            }

            Ok(())
        }
    }
}

async fn extend_vote<Ctx: Context>(co: &Co<Ctx>, vote: Ctx::Vote) -> Result<Ctx::Vote, Error<Ctx>> {
    let VoteType::Precommit = vote.vote_type() else {
        return Ok(vote);
    };

    let NilOrVal::Val(value_id) = vote.value().as_ref().cloned() else {
        return Ok(vote);
    };

    let extension = perform!(
        co,


        Effect::ExtendVote(vote.height(), vote.round(), value_id, Default::default()),
        Resume::VoteExtension(extension) => extension);

    if let Some(extension) = extension {
        Ok(vote.extend(extension))
    } else {
        Ok(vote)
    }
}

```
---
### `core-consensus/src/handle/liveness.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use crate::handle::validator_set::get_validator_set;
use crate::handle::{driver::apply_driver_input, vote::verify_signed_vote};
use crate::prelude::*;

use super::signature::verify_polka_certificate;

/// Handles the processing of a polka certificate.
///
/// This function is responsible for:
/// 1. Validating that the certificate's height matches the current state height
/// 2. Retrieving and verifying the validator set for the given height
/// 3. Verifying the polka certificate's validity using the validator set
/// 4. Applying the certificate to the consensus state if valid
///
/// Note: The certificate is sent to the driver as a single input to make sure a
/// `ProposalAndPolka...` input is generated and sent to the state machine
/// even in the presence of equivocating votes.
///
/// # Returns
/// * `Result<(), Error<Ctx>>` - Ok(()) if processing completed successfully (even if certificate was invalid),
///   or an error if there was a problem processing the certificate
pub async fn on_polka_certificate<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    certificate: PolkaCertificate<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    info!(%certificate.height, %certificate.round, "Received polka certificate");

    if certificate.height != state.height() {
        warn!(
            %certificate.height,
            consensus.height = %state.height(),
            "Polka certificate height mismatch"
        );

        return Ok(());
    }

    let validator_set = get_validator_set(co, state, certificate.height)
        .await?
        .ok_or_else(|| Error::ValidatorSetNotFound(certificate.height))?;

    let validity = verify_polka_certificate(
        co,
        certificate.clone(),
        validator_set.into_owned(),
        state.params.threshold_params,
    )
    .await?;

    if let Err(e) = validity {
        warn!(?certificate, "Invalid polka certificate: {e}");
        return Ok(());
    }

    apply_driver_input(
        co,
        state,
        metrics,
        DriverInput::PolkaCertificate(certificate),
    )
    .await
}

/// Handles the processing of a round certificate.
///
/// This function is responsible for:
/// 1. Validating that the certificate's height matches the current state height
/// 2. Processing each vote signature in the round certificate
/// 3. Converting signatures into appropriate vote types (Prevote or Precommit)
/// 4. Verifying each vote's validity
/// 5. Applying valid votes to the consensus state
///
/// Note: The round certificate can be of type `2f+1` PrecommitAny or `f+1` SkipRound (*).
/// For round certificates, in contrast to polka certificates, the votes are applied
/// individually to the driver and once the threshold is reached it is sent to the state machine.
/// Presence of equivocating votes is not a problem, as the driver will ignore them while
/// the vote keeper will still be able to generate the threshold output using the existing
/// stored and incoming votes from the certificate.
///
/// (*) There is currently no validation of the correctness of the certificate in this function.
/// A byzantine validator may send a certificate that does not have enough votes to reach the
/// thresholds for `PrecommitAny` or `SkipRound`.
///
/// # Returns
/// * `Result<(), Error<Ctx>>` - Ok(()) if processing completed successfully,
///   or an error if there was a problem processing the certificate
pub async fn on_round_certificate<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    certificate: RoundCertificate<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    info!(
        %certificate.height,
        %certificate.round,
        "Received round certificate"
    );

    if certificate.height != state.height() {
        warn!(
            %certificate.height,
            consensus.height = %state.height(),
            "Round certificate height mismatch"
        );

        return Ok(());
    }

    for signature in certificate.round_signatures {
        let vote_type = signature.vote_type;
        let vote: SignedVote<Ctx> = match vote_type {
            VoteType::Prevote => SignedVote::new(
                state.ctx.new_prevote(
                    certificate.height,
                    certificate.round,
                    signature.value_id,
                    signature.address,
                ),
                signature.signature,
            ),
            VoteType::Precommit => SignedVote::new(
                state.ctx.new_precommit(
                    certificate.height,
                    certificate.round,
                    signature.value_id,
                    signature.address,
                ),
                signature.signature,
            ),
        };

        if !verify_signed_vote(co, state, &vote).await? {
            warn!(?vote, "Invalid vote");
            continue;
        }
        apply_driver_input(co, state, metrics, DriverInput::Vote(vote)).await?;
    }

    // Cancel rebroadcast timer
    // TODO: Should do only if the round certificate is well formed, i.e. either PrecommitAny or SkipRound
    perform!(
        co,
        Effect::CancelTimeout(Timeout::rebroadcast(certificate.round), Default::default())
    );

    Ok(())
}

```
---
### `core-consensus/src/handle/proposal.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use crate::handle::driver::apply_driver_input;
use crate::handle::signature::verify_signature;
use crate::handle::validator_set::get_validator_set;
use crate::input::Input;
use crate::prelude::*;
use crate::types::{ConsensusMsg, ProposedValue, SignedConsensusMsg, WalEntry};
use crate::util::pretty::PrettyProposal;

/// Handles an incoming consensus proposal message.
///
/// This handler processes proposals that can arrive from three sources:
/// 1. Network messages from other nodes
/// 2. Local proposals when this node is the proposer
/// 3. WAL replay during node restart
///
/// When acting as proposer (2), consensus core interacts with the application to get a proposed value for the current height and round.
/// In this case the proposal message is sent out to the network but also back to the consensus core.
///
/// # Arguments
/// * `co` - The context object containing configuration and external dependencies
/// * `state` - The current consensus state
/// * `metrics` - Metrics collection for monitoring
/// * `signed_proposal` - The signed proposal message to process
///
/// # Flow
/// 1. Validates proposal height and signature
/// 2. Queues messages if not ready to process (wrong height/round)
/// 3. Stores valid proposals and updates WAL if needed
/// 4. Processes the proposal through the driver if a full proposal is available
pub async fn on_proposal<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    signed_proposal: SignedProposal<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let consensus_height = state.driver.height();

    let proposal_height = signed_proposal.height();
    let proposal_round = signed_proposal.round();
    let proposer_address = signed_proposal.validator_address();

    if proposal_height < consensus_height {
        warn!(
            consensus.height = %consensus_height,
            proposal.height = %proposal_height,
            proposer = %proposer_address,
            "Received proposal for lower height, dropping"
        );

        return Ok(());
    }

    if !verify_signed_proposal(co, state, &signed_proposal).await? {
        return Ok(());
    }

    info!(
        consensus.height = %consensus_height,
        proposal.height = %proposal_height,
        proposal.round = %proposal_round,
        proposer = %proposer_address,
        message = %PrettyProposal::<Ctx>(&signed_proposal.message),
        "Received proposal"
    );

    // Queue messages if driver is not initialized, or if they are for higher height.
    // Process messages received for the current height.
    // Drop all others.
    if state.driver.round() == Round::Nil {
        debug!("Received proposal at round -1, queuing for later");
        state.buffer_input(proposal_height, Input::Proposal(signed_proposal));

        return Ok(());
    }

    if proposal_height > consensus_height {
        debug!("Received proposal for higher height {proposal_height}, queuing for later",);
        state.buffer_input(proposal_height, Input::Proposal(signed_proposal));

        return Ok(());
    }

    debug_assert_eq!(proposal_height, consensus_height);

    // Store the proposal in the full proposal keeper
    state.store_proposal(signed_proposal.clone());

    // If consensus runs in a mode where it publishes proposals over the network,
    // we need to persist in the Write-Ahead Log before we actually send it over the network.
    if state.params.value_payload.include_proposal() {
        perform!(
            co,
            Effect::WalAppend(
                WalEntry::ConsensusMsg(SignedConsensusMsg::Proposal(signed_proposal.clone())),
                Default::default()
            )
        );
    }

    if state.params.value_payload.proposal_only() {
        // TODO - pass the received value up to the host that will verify and give back validity and extension.
        // Currently starknet Context defines value as BlockHash, we need a PoC app for this.
        let new_value = ProposedValue {
            height: signed_proposal.height(),
            round: signed_proposal.round(),
            valid_round: signed_proposal.pol_round(),
            proposer: signed_proposal.validator_address().clone(),
            value: signed_proposal.value().clone(),
            validity: Validity::Valid,
        };

        state.store_value(&new_value);
    }

    if let Some(full_proposal) = state.full_proposal_at_round_and_value(
        &proposal_height,
        proposal_round,
        signed_proposal.value(),
    ) {
        apply_driver_input(
            co,
            state,
            metrics,
            DriverInput::Proposal(full_proposal.proposal.clone(), full_proposal.validity),
        )
        .await?;
    } else {
        debug!(
            proposal.height = %proposal_height,
            proposal.round = %proposal_round,
            "No full proposal for this round yet, stored proposal for later"
        );
    }

    Ok(())
}

pub async fn verify_signed_proposal<Ctx>(
    co: &Co<Ctx>,
    state: &State<Ctx>,
    signed_proposal: &SignedProposal<Ctx>,
) -> Result<bool, Error<Ctx>>
where
    Ctx: Context,
{
    let consensus_height = state.driver.height();
    let proposal_height = signed_proposal.height();
    let proposal_round = signed_proposal.round();
    let proposer_address = signed_proposal.validator_address();

    let Some(validator_set) = get_validator_set(co, state, proposal_height).await? else {
        debug!(
            consensus.height = %consensus_height,
            proposal.height = %proposal_height,
            proposer = %proposer_address,
            "Received proposal for height without known validator set, dropping"
        );

        return Ok(false);
    };

    let Some(proposer) = validator_set.get_by_address(proposer_address) else {
        warn!(
            consensus.height = %consensus_height,
            proposal.height = %proposal_height,
            proposer = %proposer_address,
            "Received proposal from unknown validator"
        );

        return Ok(false);
    };

    let expected_proposer = state.get_proposer(proposal_height, proposal_round);

    if expected_proposer != proposer_address {
        warn!(
            consensus.height = %consensus_height,
            proposal.height = %proposal_height,
            proposer = %proposer_address,
            expected = %expected_proposer,
            "Received proposal from a non-proposer"
        );

        return Ok(false);
    };

    let signed_msg = signed_proposal.clone().map(ConsensusMsg::Proposal);
    if !verify_signature(co, signed_msg, proposer).await? {
        warn!(
            consensus.height = %consensus_height,
            proposal.height = %proposal_height,
            proposer = %proposer_address,
            "Received invalid signature for proposal: {}",
            PrettyProposal::<Ctx>(&signed_proposal.message)
        );

        return Ok(false);
    }

    Ok(true)
}

```
---
### `core-consensus/src/handle/propose.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use crate::prelude::*;

use crate::handle::driver::apply_driver_input;
use crate::types::{LocallyProposedValue, ProposedValue, WalEntry};

/// Handles a locally proposed value.
/// Called when the application has built a value to propose.
///
/// This function processes a value proposed by the local node:
/// - Validates that the height, round, and proposer match the current state
/// - Creates a ProposedValue with the local node as proposer and initial validity
/// - Appends the value to the WAL if it hasn't been seen before
/// - Stores the value in the state
/// - Applies the proposal to the driver
///
/// # Arguments
/// * `co` - Coordination object for handling effects
/// * `state` - Current consensus state
/// * `metrics` - Metrics collection object
/// * `local_value` - The value being proposed locally
///
/// # Returns
/// `Result<(), Error<Ctx>>` - Ok if the proposal was processed successfully,
///                           including cases where validation fails
pub async fn on_propose<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    local_value: LocallyProposedValue<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    if !verify_propose_value(state, &local_value)? {
        return Ok(());
    }

    let proposed_value = ProposedValue {
        height: local_value.height,
        round: local_value.round,
        valid_round: Round::Nil,
        proposer: state.address().clone(),
        value: local_value.value.clone(),
        validity: Validity::Valid,
    };

    #[cfg(feature = "metrics")]
    metrics.consensus_start();

    // If this is the first time we see this value in the current round, append it to the WAL
    if !state.value_exists(&proposed_value) {
        perform!(
            co,
            Effect::WalAppend(
                WalEntry::ProposedValue(proposed_value.clone()),
                Default::default()
            )
        );
    }

    state.store_value(&proposed_value);

    apply_driver_input(
        co,
        state,
        metrics,
        DriverInput::ProposeValue(local_value.round, local_value.value),
    )
    .await
}

/// Verifies if a locally proposed value matches the current consensus state.
///
/// # Arguments
/// * `co` - Coordination object for handling effects
/// * `state` - Current consensus state
/// * `local_value` - The value being proposed locally
///
/// # Returns
/// * Ok(true) if all of the following conditions are met:
///   - The proposed height matches the current height
///   - The proposed round matches the current round
///   - The local node is the expected proposer for this round
/// * Ok(false) if any of these conditions are not met
fn verify_propose_value<Ctx>(
    state: &State<Ctx>,
    local_value: &LocallyProposedValue<Ctx>,
) -> Result<bool, Error<Ctx>>
where
    Ctx: Context,
{
    if state.driver.height() != local_value.height {
        warn!(
            "Ignoring value for height {}, current height: {}",
            local_value.height,
            state.driver.height()
        );

        return Ok(false);
    }

    if state.driver.round() != local_value.round {
        warn!(
            "Ignoring value for round {}, current round: {}",
            local_value.round,
            state.driver.round()
        );

        return Ok(false);
    }

    let expected_proposer = state.get_proposer(local_value.height, local_value.round);

    if expected_proposer != state.address() {
        warn!(
            "Not the proposer for round {}. Expected proposer: {:?}, we are: {:?}",
            local_value.round,
            expected_proposer,
            state.address()
        );
        return Ok(false);
    }

    Ok(true)
}

```
---
### `core-consensus/src/handle/proposed_value.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use crate::prelude::*;

use crate::handle::driver::apply_driver_input;
use crate::types::{ProposedValue, WalEntry};

use super::signature::sign_proposal;

/// Handles a proposed value that can originate from multiple sources:
/// 1. Application layer:
///    - In 'parts-only' mode
///    - In 'proposal-and-parts' mode
/// 2. WAL (Write-Ahead Log) during node restart recovery
/// 3. Sync service during state synchronization
///
/// This function processes proposed values based on their height and origin:
/// - Drops values from lower heights
/// - Queues values from higher heights for later processing
/// - For parts-only mode or values from Sync, generates and signs internal Proposal messages
/// - Stores the value and appends it to the WAL if new
/// - Applies any associated proposals to the driver
/// - Attempts immediate decision for values from Sync
///
/// # Arguments
/// * `co` - Coordination object for async operations
/// * `state` - Current consensus state
/// * `metrics` - Metrics collection
/// * `proposed_value` - The proposed value to process
/// * `origin` - Origin of the proposed value (e.g., Sync, Network)
///
/// # Returns
/// Result indicating success or failure of processing the proposed value
pub async fn on_proposed_value<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    proposed_value: ProposedValue<Ctx>,
    origin: ValueOrigin,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    if state.driver.height() > proposed_value.height {
        debug!("Received value for lower height, dropping");
        return Ok(());
    }

    if state.driver.height() < proposed_value.height {
        debug!("Received value for higher height, queuing for later");

        state.buffer_input(
            proposed_value.height,
            Input::ProposedValue(proposed_value, origin),
        );

        return Ok(());
    }

    // There are two cases where we need to generate an internal Proposal message for consensus to process the full proposal:
    // a) In parts-only mode, where we do not get a Proposal message but only the proposal parts
    // b) In any mode if the proposed value was provided by Sync, where we do net get a Proposal message but only the full value and the certificate
    if state.params.value_payload.parts_only() || origin == ValueOrigin::Sync {
        let proposal = Ctx::new_proposal(
            &state.ctx,
            proposed_value.height,
            proposed_value.round,
            proposed_value.value.clone(),
            proposed_value.valid_round,
            proposed_value.proposer.clone(),
        );

        // TODO: Keep unsigned proposals in keeper.
        // For now we keep all happy by signing all "implicit" proposals with this node's key
        let signed_proposal = sign_proposal(co, proposal).await?;

        state.store_proposal(signed_proposal);
    }

    // If this is the first time we see this value, append it to the WAL, so it can be used for recovery.
    if !state.value_exists(&proposed_value) {
        perform!(
            co,
            Effect::WalAppend(
                WalEntry::ProposedValue(proposed_value.clone()),
                Default::default()
            )
        );
    }

    state.store_value(&proposed_value);

    let validity = proposed_value.validity;
    let proposals = state.proposals_for_value(&proposed_value);

    for signed_proposal in proposals {
        debug!(
            proposal.height = %signed_proposal.height(),
            proposal.round = %signed_proposal.round(),
            "We have a full proposal for this round, checking..."
        );

        apply_driver_input(
            co,
            state,
            metrics,
            DriverInput::Proposal(signed_proposal, validity),
        )
        .await?;
    }

    Ok(())
}

```
---
### `core-consensus/src/handle/rebroadcast_timeout.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use crate::prelude::*;

#[cfg_attr(not(feature = "metrics"), allow(unused_variables))]
pub async fn on_rebroadcast_timeout<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let (height, round) = (state.driver.height(), state.driver.round());

    if let Some(vote) = state.last_signed_prevote.as_ref() {
        warn!(
            %height, %round, vote_height = %vote.height(), vote_round = %vote.round(),
            "Rebroadcasting vote at {:?} step",
            state.driver.step()
        );

        perform!(
            co,
            Effect::RebroadcastVote(vote.clone(), Default::default())
        );
    };

    if let Some(vote) = state.last_signed_precommit.as_ref() {
        warn!(
            %height, %round, vote_height = %vote.height(), vote_round = %vote.round(),
            "Rebroadcasting vote at {:?} step",
            state.driver.step()
        );
        perform!(
            co,
            Effect::RebroadcastVote(vote.clone(), Default::default())
        );
    };

    if let Some(cert) = state.round_certificate() {
        if cert.enter_round == round {
            warn!(
                %cert.certificate.height,
                %round,
                %cert.certificate.round,
                number_of_votes = cert.certificate.round_signatures.len(),
                "Rebroadcasting round certificate"
            );
            perform!(
                co,
                Effect::RebroadcastRoundCertificate(cert.certificate.clone(), Default::default())
            );
        }
    };

    #[cfg(feature = "metrics")]
    metrics.rebroadcast_timeouts.inc();

    let timeout = Timeout::rebroadcast(round);
    perform!(co, Effect::ScheduleTimeout(timeout, Default::default()));

    Ok(())
}

```
---
### `core-consensus/src/handle/signature.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use crate::prelude::*;

use crate::types::ConsensusMsg;

pub async fn verify_signature<Ctx>(
    co: &Co<Ctx>,
    signed_msg: SignedMessage<Ctx, ConsensusMsg<Ctx>>,
    validator: &Ctx::Validator,
) -> Result<bool, Error<Ctx>>
where
    Ctx: Context,
{
    let valid = perform!(co,
        Effect::VerifySignature(signed_msg, validator.public_key().clone(), Default::default()),
        Resume::SignatureValidity(valid) => valid
    );

    Ok(valid)
}

pub async fn sign_vote<Ctx>(co: &Co<Ctx>, vote: Ctx::Vote) -> Result<SignedVote<Ctx>, Error<Ctx>>
where
    Ctx: Context,
{
    let signed_vote = perform!(co,
        Effect::SignVote(vote, Default::default()),
        Resume::SignedVote(signed_vote) => signed_vote
    );

    Ok(signed_vote)
}

pub async fn sign_proposal<Ctx>(
    co: &Co<Ctx>,
    proposal: Ctx::Proposal,
) -> Result<SignedProposal<Ctx>, Error<Ctx>>
where
    Ctx: Context,
{
    let signed_proposal = perform!(co,
        Effect::SignProposal(proposal, Default::default()),
        Resume::SignedProposal(signed_proposal) => signed_proposal
    );

    Ok(signed_proposal)
}

pub async fn verify_commit_certificate<Ctx>(
    co: &Co<Ctx>,
    certificate: CommitCertificate<Ctx>,
    validator_set: Ctx::ValidatorSet,
    threshold_params: ThresholdParams,
) -> Result<Result<(), CertificateError<Ctx>>, Error<Ctx>>
where
    Ctx: Context,
{
    let result = perform!(co,
        Effect::VerifyCommitCertificate(certificate, validator_set, threshold_params, Default::default()),
        Resume::CertificateValidity(result) => result
    );

    Ok(result)
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub async fn verify_polka_certificate<Ctx>(
    co: &Co<Ctx>,
    certificate: PolkaCertificate<Ctx>,
    validator_set: Ctx::ValidatorSet,
    threshold_params: ThresholdParams,
) -> Result<Result<(), CertificateError<Ctx>>, Error<Ctx>>
where
    Ctx: Context,
{
    let result = perform!(co,
        Effect::VerifyPolkaCertificate(certificate, validator_set, threshold_params, Default::default()),
        Resume::CertificateValidity(result) => result
    );

    Ok(result)
}

```
---
### `core-consensus/src/handle/start_height.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use crate::prelude::*;

use crate::handle::driver::apply_driver_input;
use crate::handle::handle_input;

pub async fn reset_and_start_height<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    height: Ctx::Height,
    validator_set: Ctx::ValidatorSet,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    perform!(co, Effect::CancelAllTimeouts(Default::default()));
    perform!(co, Effect::ResetTimeouts(Default::default()));

    #[cfg(feature = "metrics")]
    metrics.step_end(state.driver.step());

    state.reset_and_start_height(height, validator_set);

    debug_assert_eq!(state.height(), height);
    debug_assert_eq!(state.round(), Round::Nil);

    on_start_height(co, state, metrics, height).await
}

async fn on_start_height<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    height: Ctx::Height,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug_assert_eq!(state.height(), height);
    debug_assert_eq!(state.round(), Round::Nil);

    let round = Round::new(0);
    info!(%height, "Starting new height");

    #[cfg(feature = "metrics")]
    {
        metrics.block_start();
        metrics.height.set(height.as_u64() as i64);
        metrics.round.set(round.as_i64());
    }

    let proposer = state.get_proposer(height, round);

    apply_driver_input(
        co,
        state,
        metrics,
        DriverInput::NewRound(height, round, proposer.clone()),
    )
    .await?;

    replay_pending_msgs(co, state, metrics).await?;

    Ok(())
}

async fn replay_pending_msgs<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let pending_inputs = std::mem::take(&mut state.input_queue);
    debug!(count = pending_inputs.len(), "Replaying inputs");

    for pending_input in pending_inputs {
        handle_input(co, state, metrics, pending_input).await?;
    }

    Ok(())
}

```
---
### `core-consensus/src/handle/sync.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use crate::handle::driver::apply_driver_input;
use crate::handle::signature::verify_commit_certificate;
use crate::handle::validator_set::get_validator_set;
use crate::prelude::*;

pub async fn on_commit_certificate<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    certificate: CommitCertificate<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug!(
        certificate.height = %certificate.height,
        signatures = certificate.commit_signatures.len(),
        "Processing certificate"
    );

    let Some(validator_set) = get_validator_set(co, state, certificate.height).await? else {
        return Err(Error::ValidatorSetNotFound(certificate.height));
    };

    if let Err(e) = verify_commit_certificate(
        co,
        certificate.clone(),
        validator_set.as_ref().clone(),
        state.params.threshold_params,
    )
    .await?
    {
        return Err(Error::InvalidCommitCertificate(certificate, e));
    }

    apply_driver_input(
        co,
        state,
        metrics,
        DriverInput::CommitCertificate(certificate),
    )
    .await
}

```
---
### `core-consensus/src/handle/timeout.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use crate::handle::driver::apply_driver_input;
use crate::handle::rebroadcast_timeout::on_rebroadcast_timeout;
use crate::prelude::*;
use crate::types::WalEntry;

pub async fn on_timeout_elapsed<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    timeout: Timeout,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let height = state.driver.height();
    let round = state.driver.round();

    if timeout.round != round {
        debug!(
            %height,
            %round,
            timeout.round = %timeout.round,
            "Ignoring timeout for different round",
        );

        return Ok(());
    }

    info!(
        step = ?timeout.kind,
        %timeout.round,
        %height,
        %round,
        "Timeout elapsed"
    );

    if matches!(
        timeout.kind,
        TimeoutKind::Propose | TimeoutKind::Prevote | TimeoutKind::Precommit
    ) {
        // Persist the timeout in the Write-ahead Log.
        // Time-limit and rebroadcast timeouts are not persisted because they only occur when consensus is stuck.
        perform!(
            co,
            Effect::WalAppend(WalEntry::Timeout(timeout), Default::default())
        );
    }

    apply_driver_input(co, state, metrics, DriverInput::TimeoutElapsed(timeout)).await?;

    if matches!(timeout.kind, TimeoutKind::Rebroadcast) {
        on_rebroadcast_timeout(co, state, metrics).await?;
    }

    Ok(())
}

```
---
### `core-consensus/src/handle/validator_set.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::borrow::Cow;

use crate::prelude::*;

pub async fn get_validator_set<'a, Ctx>(
    co: &Co<Ctx>,
    state: &'a State<Ctx>,
    height: Ctx::Height,
) -> Result<Option<Cow<'a, Ctx::ValidatorSet>>, Error<Ctx>>
where
    Ctx: Context,
{
    if state.driver.height() == height {
        return Ok(Some(Cow::Borrowed(state.driver.validator_set())));
    }

    perform!(co, Effect::GetValidatorSet(height, Default::default()),
        Resume::ValidatorSet(validator_set) => Ok(validator_set.map(Cow::Owned))
    )
}

```
---
### `core-consensus/src/handle/vote.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use tracing::trace;

use crate::handle::driver::apply_driver_input;
use crate::handle::signature::verify_signature;
use crate::handle::validator_set::get_validator_set;
use crate::input::Input;
use crate::prelude::*;
use crate::types::{ConsensusMsg, SignedConsensusMsg, WalEntry};
use crate::util::pretty::PrettyVote;

pub async fn on_vote<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    signed_vote: SignedVote<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let consensus_height = state.driver.height();
    let consensus_round = state.driver.round();
    let vote_height = signed_vote.height();
    let validator_address = signed_vote.validator_address();

    if consensus_height > vote_height {
        debug!(
            consensus.height = %consensus_height,
            vote.height = %vote_height,
            validator = %validator_address,
            "Received vote for lower height, dropping"
        );

        return Ok(());
    }

    if !verify_signed_vote(co, state, &signed_vote).await? {
        return Ok(());
    }

    info!(
        height = %consensus_height,
        %vote_height,
        address = %validator_address,
        message = %PrettyVote::<Ctx>(&signed_vote.message),
        "Received vote",
    );

    // Queue messages if driver is not initialized, or if they are for higher height.
    // Process messages received for the current height.
    // Drop all others.
    if consensus_round == Round::Nil {
        trace!(
            consensus.height = %consensus_height,
            vote.height = %vote_height,
            validator = %validator_address,
            "Received vote at round -1, queuing for later"
        );

        state.buffer_input(vote_height, Input::Vote(signed_vote));

        return Ok(());
    }

    if consensus_height < vote_height {
        trace!(
            consensus.height = %consensus_height,
            vote.height = %vote_height,
            validator = %validator_address,
            "Received vote for higher height, queuing for later"
        );

        state.buffer_input(vote_height, Input::Vote(signed_vote));

        return Ok(());
    }

    debug_assert_eq!(consensus_height, vote_height);

    // Only append to WAL and store the non-nil precommit if we have not yet seen this vote.
    if !state.driver.votes().has_vote(&signed_vote) {
        // Append the vote to the Write-ahead Log
        perform!(
            co,
            Effect::WalAppend(
                WalEntry::ConsensusMsg(SignedConsensusMsg::Vote(signed_vote.clone())),
                Default::default()
            )
        );
    }

    apply_driver_input(co, state, metrics, DriverInput::Vote(signed_vote)).await?;

    Ok(())
}

pub async fn verify_signed_vote<Ctx>(
    co: &Co<Ctx>,
    state: &State<Ctx>,
    signed_vote: &SignedVote<Ctx>,
) -> Result<bool, Error<Ctx>>
where
    Ctx: Context,
{
    let consensus_height = state.driver.height();
    let vote_height = signed_vote.height();
    let vote_round = signed_vote.round();
    let validator_address = signed_vote.validator_address();

    let Some(validator_set) = get_validator_set(co, state, signed_vote.height()).await? else {
        debug!(
            consensus.height = %consensus_height,
            vote.height = %vote_height,
            vote.round = %vote_round,
            validator = %validator_address,
            "Received vote for height without known validator set, dropping"
        );

        return Ok(false);
    };

    let Some(validator) = validator_set.get_by_address(validator_address) else {
        warn!(
            consensus.height = %consensus_height,
            vote.height = %vote_height,
            vote.round = %vote_round,
            validator = %validator_address,
            "Received vote from unknown validator"
        );

        return Ok(false);
    };

    let signed_msg = signed_vote.clone().map(ConsensusMsg::Vote);
    if !verify_signature(co, signed_msg, validator).await? {
        warn!(
            consensus.height = %consensus_height,
            vote.height = %vote_height,
            vote.round = %vote_round,
            validator = %validator_address,
            "Received vote with invalid signature: {}", PrettyVote::<Ctx>(&signed_vote.message)
        );

        return Ok(false);
    }

    verify_vote_extension(co, state, signed_vote, validator).await
}

async fn verify_vote_extension<Ctx>(
    co: &Co<Ctx>,
    state: &State<Ctx>,
    vote: &SignedVote<Ctx>,
    validator: &Ctx::Validator,
) -> Result<bool, Error<Ctx>>
where
    Ctx: Context,
{
    let VoteType::Precommit = vote.vote_type() else {
        return Ok(true);
    };

    let NilOrVal::Val(value_id) = vote.value().as_ref() else {
        return Ok(true);
    };

    let Some(extension) = vote.extension() else {
        return Ok(true);
    };

    let result = perform!(
        co,
        Effect::VerifyVoteExtension(
            vote.height(),
            vote.round(),
            value_id.clone(),
            extension.clone(),
            validator.public_key().clone(),
            Default::default()
        ),
        Resume::VoteExtensionValidity(result) => result
    );

    if let Err(e) = result {
        warn!(
            consensus.height = %state.driver.height(),
            vote.height = %vote.height(),
            vote.round = %vote.round(),
            validator = %validator.address(),
            "Received vote with invalid extension: {}, reason: {e}",
            PrettyVote::<Ctx>(&vote.message)
        );

        return Ok(false);
    }

    Ok(true)
}

```
---
### `core-consensus/src/handle.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
mod decide;
mod driver;
mod liveness;
mod proposal;
mod propose;
mod proposed_value;
mod rebroadcast_timeout;
mod signature;
mod start_height;
mod sync;
mod timeout;
mod validator_set;
mod vote;

use liveness::{on_polka_certificate, on_round_certificate};
use proposal::on_proposal;
use propose::on_propose;
use proposed_value::on_proposed_value;
use start_height::reset_and_start_height;
use sync::on_commit_certificate;
use timeout::on_timeout_elapsed;
use vote::on_vote;

use crate::prelude::*;

#[allow(private_interfaces)]
pub async fn handle<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    input: Input<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    handle_input(&co, state, metrics, input).await
}

#[async_recursion]
async fn handle_input<Ctx>(
    co: &Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    input: Input<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    match input {
        Input::StartHeight(height, validator_set) => {
            reset_and_start_height(co, state, metrics, height, validator_set).await
        }
        Input::Vote(vote) => on_vote(co, state, metrics, vote).await,
        Input::Proposal(proposal) => on_proposal(co, state, metrics, proposal).await,
        Input::Propose(value) => on_propose(co, state, metrics, value).await,
        Input::TimeoutElapsed(timeout) => on_timeout_elapsed(co, state, metrics, timeout).await,
        Input::ProposedValue(value, origin) => {
            on_proposed_value(co, state, metrics, value, origin).await
        }
        Input::CommitCertificate(certificate) => {
            on_commit_certificate(co, state, metrics, certificate).await
        }
        Input::PolkaCertificate(certificate) => {
            on_polka_certificate(co, state, metrics, certificate).await
        }
        Input::RoundCertificate(certificate) => {
            on_round_certificate(co, state, metrics, certificate).await
        }
    }
}

```
---
### `core-consensus/src/input.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use derive_where::derive_where;
use malachitebft_core_types::{
    CommitCertificate, Context, PolkaCertificate, RoundCertificate, SignedProposal, SignedVote,
    Timeout, ValueOrigin,
};

use crate::types::{LocallyProposedValue, ProposedValue};

/// Inputs to be handled by the consensus process.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Input<Ctx>
where
    Ctx: Context,
{
    /// Start consensus for the given height with the given validator set
    StartHeight(Ctx::Height, Ctx::ValidatorSet),

    /// Process a vote received over the network.
    Vote(SignedVote<Ctx>),

    /// Process a Proposal message received over the network
    ///
    /// This input MUST only be provided when `ValuePayload` is set to `ProposalOnly` or `ProposalAndParts`,
    /// i.e. when consensus runs in a mode where the proposer sends a Proposal consensus message over the network.
    Proposal(SignedProposal<Ctx>),

    /// Process a PolkaCertificate message received over the network
    PolkaCertificate(PolkaCertificate<Ctx>),

    /// Process a RoundCertificate message received over the network
    RoundCertificate(RoundCertificate<Ctx>),

    /// Propose the given value.
    ///
    /// This input MUST only be provided when we are the proposer for the current round.
    Propose(LocallyProposedValue<Ctx>),

    /// A timeout has elapsed.
    TimeoutElapsed(Timeout),

    /// We have received the full proposal for the current round.
    ///
    /// The origin denotes whether the value was received via consensus gossip or via the sync protocol.
    ProposedValue(ProposedValue<Ctx>, ValueOrigin),

    /// We have received a commit certificate via the sync protocol.
    CommitCertificate(CommitCertificate<Ctx>),
}

```
---
### `core-consensus/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
mod prelude;

mod input;
pub use input::Input;

mod state;
pub use state::State;

mod error;
pub use error::Error;

mod params;
pub use params::{Params, ThresholdParams};

#[doc(hidden)]
pub use params::HIDDEN_LOCK_ROUND;

mod effect;
pub use effect::{Effect, Resumable, Resume};

mod types;
pub use types::*;

mod full_proposal;
mod macros;
mod util;

// Only used in macros
#[doc(hidden)]
pub mod gen;

// Only used in macros
mod handle;
#[doc(hidden)]
pub use handle::handle;

// Only used internally, but needs to be exposed for tests
#[doc(hidden)]
pub use full_proposal::{FullProposal, FullProposalKeeper};

// Used in macros
#[doc(hidden)]
pub use tracing;

```
---
### `core-consensus/src/macros.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
/// Process an [`Input`][input] and handle the emitted [`Effects`][effect].
///
/// [input]: crate::input::Input
/// [effect]: crate::effect::Effect
///
/// # Example
///
/// ```rust,ignore
/// malachitebft_core_consensus::process!(
///     // Input to process
///     input: input,
///     // Consensus state
///     state: &mut state,
///     // Metrics
///     metrics: &metrics,
///    // Effect handler
///     on: effect => handle_effect(effect).await
/// )
/// ```
#[macro_export]
macro_rules! process {
    (input: $input:expr, state: $state:expr, metrics: $metrics:expr, with: $effect:ident => $handle:expr) => {{
        let mut gen = $crate::gen::Gen::new(|co| $crate::handle(co, $state, $metrics, $input));
        let mut co_result = gen.resume_with($crate::Resume::Start);

        'proc: loop {
            match co_result {
                $crate::gen::CoResult::Yielded($effect) => {
                    let resume = match $handle {
                        Ok(resume) => resume,
                        Err(error) => {
                            $crate::tracing::error!("Error when processing effect: {error:?}");
                            $crate::Resume::Continue
                        }
                    };
                    co_result = gen.resume_with(resume)
                }
                $crate::gen::CoResult::Complete(result) => break 'proc result.map_err(Into::into),
            }
        }
    }};
}

/// Yield an effect, expecting a specific type of resume value.
///
/// Effects yielded by this macro must resume with a value that matches the provided pattern.
/// If not pattern is give, then the yielded effect must resume with [`Resume::Continue`][continue].
///
/// [continue]: crate::effect::Resume::Continue
///
/// # Errors
/// This macro will abort the current function with a [`Error::UnexpectedResume`][error] error
/// if the effect does not resume with a value that matches the provided pattern.
///
/// # Example
/// ```rust,ignore
/// // If we do not need to extract the resume value
/// let () = perform!(co, effect, Resume::ProposeValue(_, _));
///
/// /// If we need to extract the resume value
/// let value: Ctx::Value = perform!(co, effect, Resume::ProposeValue(_, value) => value);
/// ```
///
/// [error]: crate::error::Error::UnexpectedResume
#[macro_export]
macro_rules! perform {
    ($co:expr, $effect:expr) => {
        perform!($co, $effect, $crate::effect::Resume::Continue)
    };

    ($co:expr, $effect:expr, $pat:pat) => {
        perform!($co, $effect, $pat => ())
    };

    // TODO: Add support for multiple patterns + if guards
    ($co:expr, $effect:expr, $pat:pat => $expr:expr $(,)?) => {
        match $co.yield_($effect).await {
            $pat => $expr,
            resume => {
                return ::core::result::Result::Err($crate::error::Error::UnexpectedResume(
                    resume,
                    stringify!($pat)
                )
                .into())
            }
        }
    };
}

```
---
### `core-consensus/src/params.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use derive_where::derive_where;

use malachitebft_core_types::{Context, Round, ValuePayload};

/// The round from which we enable the hidden lock mitigation mechanism
pub const HIDDEN_LOCK_ROUND: Round = Round::new(10);

#[doc(inline)]
pub use malachitebft_core_driver::ThresholdParams;

/// Consensus parameters.
#[derive_where(Clone, Debug)]
pub struct Params<Ctx: Context> {
    /// The initial height
    pub initial_height: Ctx::Height,

    /// The initial validator set
    pub initial_validator_set: Ctx::ValidatorSet,

    /// The address of this validator
    pub address: Ctx::Address,

    /// The quorum and honest thresholds
    pub threshold_params: ThresholdParams,

    /// The messages required to deliver proposals
    pub value_payload: ValuePayload,
}

```
---
### `core-consensus/src/prelude.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub use async_recursion::async_recursion;
pub use tracing::{debug, info, warn};

pub use malachitebft_core_driver::Input as DriverInput;
pub use malachitebft_core_types::*;

pub use crate::effect::{Effect, Resume};
pub use crate::error::Error;
pub use crate::gen::Co;
pub use crate::input::Input;
pub use crate::perform;
pub use crate::state::State;

#[cfg(feature = "metrics")]
pub use malachitebft_metrics::Metrics;

#[cfg(not(feature = "metrics"))]
pub type Metrics = ();

```
---
### `core-consensus/src/state.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use tracing::warn;

use malachitebft_core_driver::Driver;
use malachitebft_core_types::*;

use crate::input::Input;
use crate::util::max_queue::MaxQueue;
use crate::{FullProposal, FullProposalKeeper, Params, ProposedValue};

/// The state maintained by consensus for processing a [`Input`][crate::Input].
pub struct State<Ctx>
where
    Ctx: Context,
{
    /// The context for the consensus state machine
    pub ctx: Ctx,

    /// The consensus parameters
    pub params: Params<Ctx>,

    /// Driver for the per-round consensus state machine
    pub driver: Driver<Ctx>,

    /// A queue of inputs that were received before the driver started.
    pub input_queue: MaxQueue<Ctx::Height, Input<Ctx>>,

    /// The proposals to decide on.
    pub full_proposal_keeper: FullProposalKeeper<Ctx>,

    /// Last prevote broadcasted by this node
    pub last_signed_prevote: Option<SignedVote<Ctx>>,

    /// Last precommit broadcasted by this node
    pub last_signed_precommit: Option<SignedVote<Ctx>>,
}

impl<Ctx> State<Ctx>
where
    Ctx: Context,
{
    pub fn new(ctx: Ctx, params: Params<Ctx>) -> Self {
        let driver = Driver::new(
            ctx.clone(),
            params.initial_height,
            params.initial_validator_set.clone(),
            params.address.clone(),
            params.threshold_params,
        );

        Self {
            ctx,
            driver,
            params,
            input_queue: Default::default(),
            full_proposal_keeper: Default::default(),
            last_signed_prevote: None,
            last_signed_precommit: None,
        }
    }

    pub fn height(&self) -> Ctx::Height {
        self.driver.height()
    }

    pub fn round(&self) -> Round {
        self.driver.round()
    }

    pub fn address(&self) -> &Ctx::Address {
        self.driver.address()
    }

    pub fn validator_set(&self) -> &Ctx::ValidatorSet {
        self.driver.validator_set()
    }

    pub fn get_proposer(&self, height: Ctx::Height, round: Round) -> &Ctx::Address {
        self.ctx
            .select_proposer(self.validator_set(), height, round)
            .address()
    }

    pub fn set_last_vote(&mut self, vote: SignedVote<Ctx>) {
        match vote.vote_type() {
            VoteType::Prevote => self.last_signed_prevote = Some(vote),
            VoteType::Precommit => self.last_signed_precommit = Some(vote),
        }
    }

    pub fn restore_precommits(
        &mut self,
        height: Ctx::Height,
        round: Round,
        value: &Ctx::Value,
    ) -> Vec<SignedVote<Ctx>> {
        assert_eq!(height, self.driver.height());

        // Get the commits for the height and round.
        if let Some(per_round) = self.driver.votes().per_round(round) {
            per_round
                .received_votes()
                .iter()
                .filter(|vote| {
                    vote.vote_type() == VoteType::Precommit
                        && vote.value() == &NilOrVal::Val(value.id())
                })
                .cloned()
                .collect()
        } else {
            Vec::new()
        }
    }

    #[allow(clippy::type_complexity)]
    pub fn restore_votes(
        &mut self,
        height: Ctx::Height,
        round: Round,
    ) -> Option<(Vec<SignedVote<Ctx>>, Vec<PolkaCertificate<Ctx>>)> {
        assert!(round.is_defined());

        if height != self.driver.height() {
            return None;
        }

        let mut votes = Vec::new();

        let upper_round = self.driver.votes().max_round();
        for r in round_range_inclusive(round, upper_round) {
            let per_round = self.driver.votes().per_round(r)?;
            votes.extend(per_round.received_votes().iter().cloned());
        }

        // Gather polka certificates for all rounds up to `round` included
        let certificates = self
            .driver
            .polka_certificates()
            .iter()
            .filter(|c| c.round <= round && c.height == height)
            .cloned()
            .collect::<Vec<_>>();

        Some((votes, certificates))
    }

    pub fn polka_certificate_at_round(&self, round: Round) -> Option<PolkaCertificate<Ctx>> {
        // Get the polka certificate for the specified round if it exists
        self.driver
            .polka_certificates()
            .iter()
            .find(|c| c.round == round && c.height == self.driver.height())
            .cloned()
    }

    pub fn full_proposal_at_round_and_value(
        &self,
        height: &Ctx::Height,
        round: Round,
        value: &Ctx::Value,
    ) -> Option<&FullProposal<Ctx>> {
        self.full_proposal_keeper
            .full_proposal_at_round_and_value(height, round, &value.id())
    }

    pub fn full_proposal_at_round_and_proposer(
        &self,
        height: &Ctx::Height,
        round: Round,
        address: &Ctx::Address,
    ) -> Option<&FullProposal<Ctx>> {
        self.full_proposal_keeper
            .full_proposal_at_round_and_proposer(height, round, address)
    }

    pub fn proposals_for_value(
        &self,
        proposed_value: &ProposedValue<Ctx>,
    ) -> Vec<SignedProposal<Ctx>> {
        self.full_proposal_keeper
            .proposals_for_value(proposed_value)
    }

    pub fn store_proposal(&mut self, new_proposal: SignedProposal<Ctx>) {
        self.full_proposal_keeper.store_proposal(new_proposal)
    }

    pub fn value_exists(&mut self, new_value: &ProposedValue<Ctx>) -> bool {
        self.full_proposal_keeper.value_exists(new_value)
    }

    pub fn store_value(&mut self, new_value: &ProposedValue<Ctx>) {
        // Values for higher height should have been cached for future processing
        assert_eq!(new_value.height, self.driver.height());

        // Store the value at both round and valid_round
        self.full_proposal_keeper.store_value(new_value);
    }

    pub fn reset_and_start_height(
        &mut self,
        height: Ctx::Height,
        validator_set: Ctx::ValidatorSet,
    ) {
        self.full_proposal_keeper.clear();
        self.last_signed_prevote = None;
        self.last_signed_precommit = None;

        self.driver.move_to_height(height, validator_set);
    }

    /// Return the round and value id of the decided value.
    pub fn decided_value(&self) -> Option<(Round, Ctx::Value)> {
        self.driver.decided_value()
    }

    /// Queue an input for later processing, only keep inputs for the highest height seen so far.
    pub fn buffer_input(&mut self, height: Ctx::Height, input: Input<Ctx>) {
        self.input_queue.push(height, input);
    }

    pub fn print_state(&self) {
        if let Some(per_round) = self.driver.votes().per_round(self.driver.round()) {
            warn!(
                "Number of validators having voted: {} / {}",
                per_round.addresses_weights().get_inner().len(),
                self.driver.validator_set().count()
            );
            warn!(
                "Total voting power of validators: {}",
                self.driver.validator_set().total_voting_power()
            );
            warn!(
                "Voting power required: {}",
                self.params
                    .threshold_params
                    .quorum
                    .min_expected(self.driver.validator_set().total_voting_power())
            );
            warn!(
                "Total voting power of validators having voted: {}",
                per_round.addresses_weights().sum()
            );
            warn!(
                "Total voting power of validators having prevoted nil: {}",
                per_round
                    .votes()
                    .get_weight(VoteType::Prevote, &NilOrVal::Nil)
            );
            warn!(
                "Total voting power of validators having precommited nil: {}",
                per_round
                    .votes()
                    .get_weight(VoteType::Precommit, &NilOrVal::Nil)
            );
            warn!(
                "Total weight of prevotes: {}",
                per_round.votes().weight_sum(VoteType::Prevote)
            );
            warn!(
                "Total weight of precommits: {}",
                per_round.votes().weight_sum(VoteType::Precommit)
            );
        }
    }

    /// Check if we are a validator node, i.e. we are present in the current validator set.
    pub fn is_validator(&self) -> bool {
        self.validator_set()
            .get_by_address(self.address())
            .is_some()
    }

    pub fn round_certificate(&self) -> Option<&EnterRoundCertificate<Ctx>> {
        self.driver.round_certificate.as_ref()
    }
}

fn round_range_inclusive(from: Round, to: Round) -> Box<dyn Iterator<Item = Round>> {
    if !from.is_defined() || !to.is_defined() || from > to {
        return Box::new(std::iter::empty());
    }

    if from == to {
        return Box::new(std::iter::once(from));
    }

    Box::new((from.as_u32().unwrap_or(0)..=to.as_u32().unwrap_or(0)).map(Round::new))
}

```
---
### `core-consensus/src/types.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use derive_where::derive_where;
use thiserror::Error;

use malachitebft_core_types::{
    Context, PolkaCertificate, Proposal, Round, RoundCertificate, Signature, SignedProposal,
    SignedVote, Timeout, Validity, Vote,
};

pub use malachitebft_core_types::ValuePayload;

pub use malachitebft_peer::PeerId;
pub use multiaddr::Multiaddr;

/// A signed consensus message, ie. a signed vote or a signed proposal.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum SignedConsensusMsg<Ctx: Context> {
    Vote(SignedVote<Ctx>),
    Proposal(SignedProposal<Ctx>),
}

impl<Ctx: Context> SignedConsensusMsg<Ctx> {
    pub fn height(&self) -> Ctx::Height {
        match self {
            SignedConsensusMsg::Vote(msg) => msg.height(),
            SignedConsensusMsg::Proposal(msg) => msg.height(),
        }
    }

    pub fn round(&self) -> Round {
        match self {
            SignedConsensusMsg::Vote(msg) => msg.round(),
            SignedConsensusMsg::Proposal(msg) => msg.round(),
        }
    }

    pub fn signature(&self) -> &Signature<Ctx> {
        match self {
            SignedConsensusMsg::Vote(msg) => &msg.signature,
            SignedConsensusMsg::Proposal(msg) => &msg.signature,
        }
    }
}

/// A message that can be sent by the consensus layer
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum ConsensusMsg<Ctx: Context> {
    Vote(Ctx::Vote),
    Proposal(Ctx::Proposal),
}

/// A value to propose by the current node.
/// Used only when the node is the proposer.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct LocallyProposedValue<Ctx: Context> {
    pub height: Ctx::Height,
    pub round: Round,
    pub value: Ctx::Value,
}

impl<Ctx: Context> LocallyProposedValue<Ctx> {
    pub fn new(height: Ctx::Height, round: Round, value: Ctx::Value) -> Self {
        Self {
            height,
            round,
            value,
        }
    }
}

/// A value proposed by a validator
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct ProposedValue<Ctx: Context> {
    pub height: Ctx::Height,
    pub round: Round,
    pub valid_round: Round,
    pub proposer: Ctx::Address,
    pub value: Ctx::Value,
    pub validity: Validity,
}

#[derive_where(Clone, Debug)]
pub enum WalEntry<Ctx: Context> {
    ConsensusMsg(SignedConsensusMsg<Ctx>),
    Timeout(Timeout),
    ProposedValue(ProposedValue<Ctx>),
}

impl<Ctx: Context> WalEntry<Ctx> {
    pub fn as_consensus_msg(&self) -> Option<&SignedConsensusMsg<Ctx>> {
        match self {
            WalEntry::ConsensusMsg(msg) => Some(msg),
            _ => None,
        }
    }

    pub fn as_timeout(&self) -> Option<&Timeout> {
        match self {
            WalEntry::Timeout(timeout) => Some(timeout),
            _ => None,
        }
    }

    pub fn as_proposed_value(&self) -> Option<&ProposedValue<Ctx>> {
        match self {
            WalEntry::ProposedValue(value) => Some(value),
            _ => None,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Error)]
pub enum VoteExtensionError {
    #[error("Invalid vote extension signature")]
    InvalidSignature,
    #[error("Invalid vote extension")]
    InvalidVoteExtension,
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum LivenessMsg<Ctx: Context> {
    Vote(SignedVote<Ctx>),
    PolkaCertificate(PolkaCertificate<Ctx>),
    SkipRoundCertificate(RoundCertificate<Ctx>),
}

```
---
### `core-consensus/src/util/max_queue.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
/// A data structure that maintains a queue of values associated with monotonically increasing indices,
/// retaining only those values associated with the maximum index seen so far.
///
/// # Type Parameters
/// - `I`: The type of the index associated with each value in the queue.
/// - `T`: The type of values stored in the queue.
///
/// # Invariant
/// - All values in the queue are associated with the maximum index observed so far.
#[derive(Clone, Debug)]
pub struct MaxQueue<I, T> {
    /// The highest index observed, which determines the values retained in the queue.
    highest_index: I,

    /// A vector storing the values associated with the maximum index.
    /// Values are appended in the order they are pushed.
    queue: Vec<T>,
}

impl<I, T> Default for MaxQueue<I, T>
where
    I: Default,
{
    /// Creates a `MaxQueue` with the default index value and an empty queue.
    ///
    /// # Returns
    /// - A `MaxQueue` instance with `current` initialized to the default value of `I` and an empty `queue`.
    fn default() -> Self {
        Self {
            highest_index: Default::default(),
            queue: Default::default(),
        }
    }
}

impl<I, T> MaxQueue<I, T> {
    /// Constructs a new, empty `MaxQueue` with its index set to default.
    ///
    /// # Returns
    /// - A new `MaxQueue` with default `current` index and an empty queue.
    pub fn new() -> Self
    where
        I: Default,
    {
        Self::default()
    }

    /// Pushes a value into the queue with an associated index.
    ///
    /// - If the `index` is greater than the highest index seen so far, the queue is cleared,
    ///   the highest index seen so far is updated, and the value is added.
    /// - If the `index` is equal to the highest index seen so far, the value is appended to the queue.
    /// - If the `index` is less than the highest index seen so far, the value is ignored.
    ///
    /// # Arguments
    /// - `index`: The index associated with the value.
    /// - `value`: The value to be stored in the queue.
    ///
    /// # Returns
    /// - Whether or not the value was inserted into the queue.
    #[allow(clippy::comparison_chain)]
    pub fn push(&mut self, index: I, value: T) -> bool
    where
        I: Ord,
    {
        if index > self.highest_index {
            // New highest index, clear the queue, insert the new value
            self.highest_index = index;
            self.queue.clear();
            self.queue.push(value);
            true
        } else if index == self.highest_index {
            // Same index, insert the new value
            self.queue.push(value);
            true
        } else {
            // Smaller index, ignore the value
            false
        }
    }

    /// Returns an iterator over references to the values in the queue.
    ///
    /// # Returns
    /// - An iterator producing references to each value stored in the queue in order of insertion.
    pub fn iter(&self) -> impl Iterator<Item = &T> {
        self.queue.iter()
    }

    /// Returns how many values are stored in queue.
    pub fn len(&self) -> usize {
        self.queue.len()
    }

    /// Returns whether the queue is empty.
    pub fn is_empty(&self) -> bool {
        self.queue.is_empty()
    }

    /// Returns the queue.
    pub fn into_vec(self) -> Vec<T> {
        self.queue
    }

    /// Returns a clone of the queue.
    pub fn to_vec(&self) -> Vec<T>
    where
        T: Clone,
    {
        self.queue.to_vec()
    }
}

/// Consumes the `MaxQueue` and returns an iterator that yields its values.
///
/// # Returns
/// - An iterator over values in the queue.
impl<I, T> IntoIterator for MaxQueue<I, T> {
    type Item = T;
    type IntoIter = std::vec::IntoIter<T>;

    fn into_iter(self) -> Self::IntoIter {
        self.queue.into_iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_max_queue() {
        let mut queue = MaxQueue::new();

        assert!(queue.is_empty());
        assert_eq!(queue.len(), 0);

        assert!(queue.push(1, "one"));
        assert_eq!(queue.len(), 1);
        assert!(!queue.is_empty());
        assert_eq!(queue.to_vec(), vec!["one"]);

        assert!(queue.push(2, "two"));
        assert_eq!(queue.len(), 1);
        assert!(!queue.is_empty());
        assert_eq!(queue.to_vec(), vec!["two"]);

        assert!(!queue.push(1, "one again"));
        assert_eq!(queue.len(), 1);
        assert!(!queue.is_empty());
        assert_eq!(queue.to_vec(), vec!["two"]);

        assert!(queue.push(2, "two again"));
        assert_eq!(queue.len(), 2);
        assert!(!queue.is_empty());
        assert_eq!(queue.to_vec(), vec!["two", "two again"]);

        assert!(queue.push(3, "three"));
        assert_eq!(queue.len(), 1);
        assert!(!queue.is_empty());
        assert_eq!(queue.to_vec(), vec!["three"]);
    }
}

```
---
### `core-consensus/src/util/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod max_queue;
pub mod pretty;

```
---
### `core-consensus/src/util/pretty.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt;

use malachitebft_core_types::{Context, Extension, NilOrVal, Proposal, Value};

pub struct PrettyVal<'a, T>(pub NilOrVal<&'a T>);

impl<T> fmt::Display for PrettyVal<'_, T>
where
    T: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.0 {
            NilOrVal::Nil => "Nil".fmt(f),
            NilOrVal::Val(v) => v.fmt(f),
        }
    }
}

pub struct PrettyVote<'a, Ctx: Context>(pub &'a Ctx::Vote);

impl<Ctx> fmt::Display for PrettyVote<'_, Ctx>
where
    Ctx: Context,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use malachitebft_core_types::Vote;

        write!(
            f,
            "{:?}(height: {}, round: {}, value: {}, from: {}",
            self.0.vote_type(),
            self.0.height(),
            self.0.round(),
            PrettyVal(self.0.value().as_ref()),
            self.0.validator_address(),
        )?;

        if let Some(e) = self.0.extension() {
            write!(f, ", extension: {:?} bytes", e.size_bytes())?;
        }

        write!(f, ")")
    }
}

pub struct PrettyProposal<'a, Ctx: Context>(pub &'a Ctx::Proposal);

impl<Ctx> fmt::Display for PrettyProposal<'_, Ctx>
where
    Ctx: Context,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Proposal(height: {}, round: {}, pol_round: {}, value: {}, from: {})",
            self.0.height(),
            self.0.round(),
            self.0.pol_round(),
            self.0.value().id(),
            self.0.validator_address()
        )
    }
}

```
---
### `core-consensus/tests/full_proposal.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
use malachitebft_core_types::{Round, SignedProposal, SigningProvider, Validity, ValueOrigin};
use malachitebft_test::utils::validators::make_validators;
use malachitebft_test::{Address, Ed25519Provider, Proposal, Value};
use malachitebft_test::{Height, TestContext};

use informalsystems_malachitebft_core_consensus::{
    FullProposal, FullProposalKeeper, Input, ProposedValue,
};

fn signed_proposal_pol(
    signing_provider: &Ed25519Provider,
    height: Height,
    round: Round,
    value: Value,
    pol_round: Round,
    address: Address,
) -> SignedProposal<TestContext> {
    let proposal1 = Proposal::new(height, round, value, pol_round, address);
    signing_provider.sign_proposal(proposal1)
}

fn prop(
    signing_provider: &Ed25519Provider,
    address: Address,
    round: u32,
    value: u64,
    pol_round: i64,
) -> SignedProposal<TestContext> {
    signed_proposal_pol(
        signing_provider,
        Height::new(1),
        Round::new(round),
        Value::new(value),
        Round::from(pol_round),
        address,
    )
}

fn prop_msg(
    signing_provider: &Ed25519Provider,
    address: Address,
    round: u32,
    value: u64,
    pol_round: i64,
) -> Input<TestContext> {
    Input::Proposal(prop(signing_provider, address, round, value, pol_round))
}

fn value(
    proposer: Address,
    round: u32,
    value: u64,
    validity: Validity,
) -> ProposedValue<TestContext> {
    ProposedValue {
        height: Height::new(1),
        round: Round::new(round),
        valid_round: Round::Nil,
        proposer,
        value: Value::new(value),
        validity,
    }
}

fn val_msg(proposer: Address, round: u32, value: u64, validity: Validity) -> Input<TestContext> {
    Input::ProposedValue(
        ProposedValue {
            height: Height::new(1),
            round: Round::new(round),
            valid_round: Round::Nil,
            value: Value::new(value),
            validity,
            proposer,
        },
        ValueOrigin::Consensus,
    )
}

fn prop_at_round_and_value(
    k: &FullProposalKeeper<TestContext>,
    r: u32,
    v: u64,
) -> Option<&FullProposal<TestContext>> {
    k.full_proposal_at_round_and_value(&Height::new(1), Round::new(r), &Value::new(v).id())
}

fn props_for_value(
    k: &FullProposalKeeper<TestContext>,
    v: &ProposedValue<TestContext>,
) -> Vec<SignedProposal<TestContext>> {
    k.proposals_for_value(v)
}

// Used for full proposer keeper testing:
// - input: includes a sequence of value and proposal messages that are applied in order
// - some_fp_for_rv - for each element: full proposal expected for (round, value)
// - none_fp_for_rv - for each element: incomplete proposal expected for (round, value)
// - fps_for_value - full proposals expected for a given ProposedValue
struct Test {
    desc: &'static str,
    input: Vec<Input<TestContext>>,
    some_fp_for_rv: Vec<(u32, u64)>,
    none_fp_for_rv: Vec<(u32, u64)>,
    fps_for_value: (ProposedValue<TestContext>, Vec<SignedProposal<TestContext>>),
}

#[test]
fn full_proposal_keeper_tests() {
    let [(v1, sk1), (v2, sk2)] = make_validators([1, 1]);

    let a1 = v1.address;
    let a2 = v2.address;

    let c1 = Ed25519Provider::new(sk1);
    let c2 = Ed25519Provider::new(sk2);

    let tests = vec![
        Test {
            desc: "BASIC: prop(0, 10, -1), val(0, 10, valid)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 10, Validity::Valid),
            ],
            some_fp_for_rv: vec![(0, 10)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 10, Validity::Valid),
                vec![prop(&c1, a1, 0, 10, -1)],
            ),
        },
        Test {
            desc: "BASIC: prop(0, 10, -1), val(0, 10, invalid)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 10, Validity::Invalid),
            ],
            some_fp_for_rv: vec![(0, 10)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 10, Validity::Invalid),
                vec![prop(&c1, a1, 0, 10, -1)],
            ),
        },
        Test {
            desc: "BASIC: prop(0, 10, -1), val(0, 20, valid)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 20, Validity::Valid),
            ],
            some_fp_for_rv: vec![],
            none_fp_for_rv: vec![(0, 10), (0, 20)],
            fps_for_value: (value(a1, 0, 20, Validity::Valid), vec![]),
        },
        Test {
            desc: "BASIC: prop(0, 10, -1), prop(0, 20, -1), val(0, 20, valid)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                prop_msg(&c1, a1, 0, 20, -1),
                val_msg(a1, 0, 20, Validity::Valid),
            ],
            some_fp_for_rv: vec![(0, 20)],
            none_fp_for_rv: vec![(0, 10)],
            fps_for_value: (
                value(a1, 0, 20, Validity::Valid),
                vec![prop(&c1, a1, 0, 20, -1)],
            ),
        },
        Test {
            desc: "BASIC: prop(0, 10, -1), val(0, 20, valid), val(0, 10, valid), prop(0, 20, -1)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 20, Validity::Valid),
                val_msg(a1, 0, 10, Validity::Valid),
                prop_msg(&c1, a1, 0, 20, -1),
            ],
            some_fp_for_rv: vec![(0, 10), (0, 20)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 10, Validity::Valid),
                vec![prop(&c1, a1, 0, 10, -1)],
            ),
        },
        Test {
            desc: "BASIC: prop(0, 10, -1), val(0, 10, valid), prop(0, 20, -1), val(0, 20, valid)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 10, Validity::Valid),
                prop_msg(&c1, a1, 0, 20, -1),
                val_msg(a1, 0, 20, Validity::Valid),
            ],
            some_fp_for_rv: vec![(0, 10), (0, 20)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 10, Validity::Valid),
                vec![prop(&c1, a1, 0, 10, -1)],
            ),
        },
        Test {
            desc: "POL: prop(0, 10, -1), val(0, 10, valid), prop(1, 10, 0)",
            input: vec![
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 10, Validity::Valid),
                prop_msg(&c2, a2, 1, 10, 0),
            ],
            some_fp_for_rv: vec![(0, 10), (1, 10)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 10, Validity::Valid),
                vec![prop(&c1, a1, 0, 10, -1), prop(&c2, a2, 1, 10, 0)],
            ),
        },
        Test {
            desc: "POL: prop(1, 10, 0), val(0, 10, valid), prop(0, 10, -1), val(0, 20, valid),",
            input: vec![
                prop_msg(&c2, a2, 1, 10, 0),
                val_msg(a1, 0, 10, Validity::Valid),
                prop_msg(&c1, a1, 0, 10, -1),
                val_msg(a1, 0, 20, Validity::Valid),
            ],
            some_fp_for_rv: vec![(0, 10), (1, 10)],
            none_fp_for_rv: vec![],
            fps_for_value: (value(a1, 0, 20, Validity::Valid), vec![]),
        },
        Test {
            desc: "POL: prop(0, 10, -1), val(0, 10, valid), prop(1, 20, 0)",
            input: vec![
                prop_msg(&c1, a1, 0, 20, -1),
                val_msg(a1, 0, 10, Validity::Valid),
                prop_msg(&c2, a2, 1, 20, 0),
            ],
            some_fp_for_rv: vec![],
            none_fp_for_rv: vec![(1, 20)],
            fps_for_value: (value(a1, 0, 20, Validity::Valid), vec![]),
        },
        Test {
            desc: "POL: val(0, 10, valid), prop(0, 20, -1), val(0, 20, valid), prop(1, 10, 0)",
            input: vec![
                val_msg(a1, 0, 10, Validity::Valid),
                prop_msg(&c1, a1, 0, 20, -1),
                val_msg(a1, 0, 20, Validity::Valid),
                prop_msg(&c2, a2, 1, 10, 0),
                prop_msg(&c2, a2, 1, 20, 0),
            ],
            some_fp_for_rv: vec![(0, 20), (1, 10)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 20, Validity::Valid),
                vec![prop(&c1, a1, 0, 20, -1), prop(&c2, a2, 1, 20, 0)],
            ),
        },
        Test {
            desc: "POL: prop(1, 10, 0), prop(0, 10, -1), prop(2, 10, 0), val(0, 10, valid)",
            input: vec![
                prop_msg(&c1, a1, 1, 10, 0),
                prop_msg(&c2, a2, 0, 10, -1),
                prop_msg(&c1, a1, 2, 10, 0),
                val_msg(a1, 0, 10, Validity::Valid),
            ],
            some_fp_for_rv: vec![(0, 10), (1, 10), (2, 10)],
            none_fp_for_rv: vec![],
            fps_for_value: (
                value(a1, 0, 10, Validity::Valid),
                vec![
                    prop(&c2, a2, 0, 10, -1),
                    prop(&c1, a1, 1, 10, 0),
                    prop(&c1, a1, 2, 10, 0),
                ],
            ),
        },
    ];

    for s in tests {
        println!("Step: {}", s.desc);
        let mut keeper = FullProposalKeeper::<TestContext>::new();

        for m in s.input {
            match m {
                Input::Proposal(p) => keeper.store_proposal(p),
                Input::ProposedValue(v, _) => keeper.store_value(&v),
                _ => continue,
            }
        }
        for (r, v) in s.some_fp_for_rv {
            assert!(prop_at_round_and_value(&keeper, r, v).is_some());
        }
        for (r, v) in s.none_fp_for_rv {
            assert!(prop_at_round_and_value(&keeper, r, v).is_none());
        }
        assert_eq!(
            props_for_value(&keeper, &s.fps_for_value.0),
            s.fps_for_value.1
        )
    }
}

```
---
### `core-driver/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-core-driver"
description = "Driver for the state machine of Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[features]
std = ["malachitebft-core-state-machine/std"]
debug = ["std", "malachitebft-core-state-machine/debug"]

[lints]
workspace = true

[dependencies]
malachitebft-core-types = { workspace = true }
malachitebft-core-state-machine = { workspace = true }
malachitebft-core-votekeeper = { workspace = true }

derive-where = { workspace = true }
thiserror = { workspace = true, default-features = false }

[dev-dependencies]
malachitebft-test = { workspace = true }

```
---
### `core-driver/src/driver.rs`
*2025-05-18 23:58:49 | 21 KB*
```rust
use alloc::collections::BTreeSet;
use alloc::vec;
use alloc::vec::Vec;
use core::fmt;

use malachitebft_core_state_machine::input::Input as RoundInput;
use malachitebft_core_state_machine::output::Output as RoundOutput;
use malachitebft_core_state_machine::state::{RoundValue, State as RoundState, Step};
use malachitebft_core_state_machine::state_machine::Info;
use malachitebft_core_types::{
    CommitCertificate, Context, EnterRoundCertificate, NilOrVal, PolkaCertificate, PolkaSignature,
    Proposal, Round, SignedProposal, SignedVote, Timeout, TimeoutKind, Validator, ValidatorSet,
    Validity, Value, ValueId, Vote, VoteType,
};
use malachitebft_core_votekeeper::keeper::Output as VKOutput;
use malachitebft_core_votekeeper::keeper::VoteKeeper;

use crate::input::Input;
use crate::output::Output;
use crate::proposal_keeper::{EvidenceMap, ProposalKeeper};
use crate::Error;
use crate::ThresholdParams;

/// Driver for the state machine of the Malachite consensus engine at a given height.
pub struct Driver<Ctx>
where
    Ctx: Context,
{
    /// The context of the consensus engine,
    /// for defining the concrete data types and signature scheme.
    #[allow(dead_code)]
    ctx: Ctx,

    /// The address of the node.
    address: Ctx::Address,

    /// Quorum thresholds
    threshold_params: ThresholdParams,

    /// The validator set at the current height
    validator_set: Ctx::ValidatorSet,

    /// The proposer for the current round, None for round nil.
    proposer: Option<Ctx::Address>,

    /// The proposals to decide on.
    pub(crate) proposal_keeper: ProposalKeeper<Ctx>,

    /// The vote keeper.
    pub(crate) vote_keeper: VoteKeeper<Ctx>,

    /// The commit certificates
    pub(crate) commit_certificates: Vec<CommitCertificate<Ctx>>,

    /// The polka certificates
    pub(crate) polka_certificates: Vec<PolkaCertificate<Ctx>>,

    /// The state of the round state machine.
    pub(crate) round_state: RoundState<Ctx>,

    /// The pending inputs to be processed next, if any.
    /// The first element of the tuple is the round at which that input has been emitted.
    pending_inputs: Vec<(Round, RoundInput<Ctx>)>,

    last_prevote: Option<Ctx::Vote>,
    last_precommit: Option<Ctx::Vote>,

    /// The certificate that justifies moving to the `enter_round` specified in the `EnterRoundCertificate.
    pub round_certificate: Option<EnterRoundCertificate<Ctx>>,
}

impl<Ctx> Driver<Ctx>
where
    Ctx: Context,
{
    /// Create a new `Driver` instance for the given height.
    ///
    /// Called when consensus is started and initialized with the first height.
    /// Re-initialization for subsequent heights is done using `move_to_height()`.
    pub fn new(
        ctx: Ctx,
        height: Ctx::Height,
        validator_set: Ctx::ValidatorSet,
        address: Ctx::Address,
        threshold_params: ThresholdParams,
    ) -> Self {
        let proposal_keeper = ProposalKeeper::new();
        let vote_keeper = VoteKeeper::new(validator_set.clone(), threshold_params);
        let round_state = RoundState::new(height, Round::Nil);

        Self {
            ctx,
            address,
            threshold_params,
            validator_set,
            proposal_keeper,
            vote_keeper,
            round_state,
            proposer: None,
            pending_inputs: vec![],
            commit_certificates: vec![],
            polka_certificates: vec![],
            last_prevote: None,
            last_precommit: None,
            round_certificate: None,
        }
    }

    /// Reset votes, round state, pending input
    /// and move to new height with the given validator set.
    pub fn move_to_height(&mut self, height: Ctx::Height, validator_set: Ctx::ValidatorSet) {
        // Reset the proposal keeper
        let proposal_keeper = ProposalKeeper::new();

        // Reset the vote keeper
        let vote_keeper = VoteKeeper::new(validator_set.clone(), self.threshold_params);

        // Reset the round state
        let round_state = RoundState::new(height, Round::Nil);

        self.validator_set = validator_set;
        self.proposal_keeper = proposal_keeper;
        self.vote_keeper = vote_keeper;
        self.round_state = round_state;
        self.pending_inputs = vec![];
        self.commit_certificates = vec![];
        self.polka_certificates = vec![];
        self.last_prevote = None;
        self.last_precommit = None;
    }

    /// Return the height of the consensus.
    pub fn height(&self) -> Ctx::Height {
        self.round_state.height
    }

    /// Return the current round we are at.
    pub fn round(&self) -> Round {
        self.round_state.round
    }

    /// Return the current step within the round we are at.
    pub fn step(&self) -> Step {
        self.round_state.step
    }

    /// Returns true if the current step is propose.
    pub fn step_is_propose(&self) -> bool {
        self.round_state.step == Step::Propose
    }

    /// Returns true if the current step is prevote.
    pub fn step_is_prevote(&self) -> bool {
        self.round_state.step == Step::Prevote
    }

    /// Returns true if the current step is precommit.
    pub fn step_is_precommit(&self) -> bool {
        self.round_state.step == Step::Precommit
    }

    /// Returns true if the current step is commit.
    pub fn step_is_commit(&self) -> bool {
        self.round_state.step == Step::Commit
    }

    /// Return the valid value (the value for which we saw a polka) for the current round, if any.
    pub fn valid_value(&self) -> Option<&RoundValue<Ctx::Value>> {
        self.round_state.valid.as_ref()
    }

    /// Return a reference to the votekeper
    pub fn votes(&self) -> &VoteKeeper<Ctx> {
        &self.vote_keeper
    }

    /// Return the state for the current round.
    pub fn round_state(&self) -> &RoundState<Ctx> {
        &self.round_state
    }

    /// Return the round and value of the decided proposal
    pub fn decided_value(&self) -> Option<(Round, Ctx::Value)> {
        self.round_state
            .decision
            .as_ref()
            .map(|decision| (decision.round, decision.value.clone()))
    }

    /// Return the address of the node.
    pub fn address(&self) -> &Ctx::Address {
        &self.address
    }

    /// Return the validator set for this height.
    pub fn validator_set(&self) -> &Ctx::ValidatorSet {
        &self.validator_set
    }

    /// Return recorded evidence of equivocation for this height.
    pub fn evidence(&self) -> &EvidenceMap<Ctx> {
        self.proposal_keeper.evidence()
    }

    /// Return the proposer for the current round.
    pub fn get_proposer(&self) -> Result<&Ctx::Validator, Error<Ctx>> {
        if let Some(proposer) = &self.proposer {
            let proposer = self
                .validator_set
                .get_by_address(proposer)
                .ok_or_else(|| Error::ProposerNotFound(proposer.clone()))?;

            Ok(proposer)
        } else {
            Err(Error::NoProposer(self.height(), self.round()))
        }
    }

    /// Get a commit certificate for the given round and value id.
    pub fn commit_certificate(
        &self,
        round: Round,
        value_id: ValueId<Ctx>,
    ) -> Option<&CommitCertificate<Ctx>> {
        self.commit_certificates
            .iter()
            .find(|c| c.round == round && c.value_id == value_id)
    }

    /// Get all polka certificates
    pub fn polka_certificates(&self) -> &[PolkaCertificate<Ctx>] {
        &self.polka_certificates
    }

    /// Get the round certificate for the current round.
    pub fn round_certificate(&self) -> Option<&EnterRoundCertificate<Ctx>> {
        self.round_certificate.as_ref()
    }

    /// Get the proposal for the given round.
    pub fn proposal_and_validity_for_round(
        &self,
        round: Round,
    ) -> Option<&(SignedProposal<Ctx>, Validity)> {
        self.proposal_keeper
            .get_proposal_and_validity_for_round(round)
    }

    /// Store the last vote that we have cast
    fn set_last_vote_cast(&mut self, vote: &Ctx::Vote) {
        assert_eq!(vote.height(), self.height());

        if vote.round() == self.round() {
            match vote.vote_type() {
                VoteType::Prevote => self.last_prevote = Some(vote.clone()),
                VoteType::Precommit => self.last_precommit = Some(vote.clone()),
            }
        }
    }

    /// Process the given input, returning the outputs to be broadcast to the network.
    pub fn process(&mut self, msg: Input<Ctx>) -> Result<Vec<Output<Ctx>>, Error<Ctx>> {
        let round_output = match self.apply(msg)? {
            Some(msg) => msg,
            None => return Ok(Vec::new()),
        };

        let mut outputs = vec![];

        // Lift the round state machine output to one or more driver outputs
        self.lift_output(round_output, &mut outputs);

        // Apply the pending inputs, if any, and lift their outputs
        while !self.pending_inputs.is_empty() {
            let new_pending = core::mem::take(&mut self.pending_inputs);
            for (round, input) in new_pending {
                if let Some(output) = self.apply_input(round, input)? {
                    self.lift_output(output, &mut outputs)
                }
            }
        }

        Ok(outputs)
    }

    /// Convert the output of the round state machine to the output type of the driver.
    fn lift_output(&mut self, round_output: RoundOutput<Ctx>, outputs: &mut Vec<Output<Ctx>>) {
        match round_output {
            RoundOutput::NewRound(round) => outputs.push(Output::NewRound(self.height(), round)),

            RoundOutput::Proposal(proposal) => outputs.push(Output::Propose(proposal)),

            RoundOutput::Vote(vote) => self.lift_vote_output(vote, outputs),

            RoundOutput::ScheduleTimeout(timeout) => outputs.push(Output::ScheduleTimeout(timeout)),

            RoundOutput::GetValueAndScheduleTimeout(height, round, timeout) => {
                outputs.push(Output::ScheduleTimeout(timeout));
                outputs.push(Output::GetValue(height, round, timeout));
            }

            RoundOutput::Decision(round, proposal) => outputs.push(Output::Decide(round, proposal)),
        }
    }

    fn lift_vote_output(&mut self, vote: Ctx::Vote, outputs: &mut Vec<Output<Ctx>>) {
        if vote.validator_address() != self.address() {
            return;
        }

        // Only cast a vote if any of the following is true:
        // - We have not voted yet
        // - That vote is for a higher height than our last vote
        // - That vote is for a higher round than our last vote
        // - That vote is the same as our last vote
        // Precommits have the additional constraint that the value must match the valid value
        let can_vote = match vote.vote_type() {
            VoteType::Prevote => self.last_prevote.as_ref().is_none_or(|prev| {
                prev.height() < vote.height() || prev.round() < vote.round() || prev == &vote
            }),
            VoteType::Precommit => {
                let good_precommit = self.last_precommit.as_ref().is_none_or(|prev| {
                    prev.height() < vote.height() || prev.round() < vote.round() || prev == &vote
                });
                let match_valid = self.round_state.valid.as_ref().is_none_or(|valid| {
                    if let NilOrVal::Val(value_id) = vote.value() {
                        &valid.value.id() == value_id
                    } else {
                        true
                    }
                });
                good_precommit && match_valid
            }
        };

        if can_vote {
            self.set_last_vote_cast(&vote);
            outputs.push(Output::Vote(vote));
        }
    }

    /// Apply the given input to the state machine, returning the output, if any.
    fn apply(&mut self, input: Input<Ctx>) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        match input {
            Input::CommitCertificate(certificate) => self.apply_commit_certificate(certificate),
            Input::PolkaCertificate(certificate) => self.apply_polka_certificate(certificate),
            Input::NewRound(height, round, proposer) => {
                self.apply_new_round(height, round, proposer)
            }
            Input::ProposeValue(round, value) => self.apply_propose_value(round, value),
            Input::Proposal(proposal, validity) => self.apply_proposal(proposal, validity),
            Input::Vote(vote) => self.apply_vote(vote),
            Input::TimeoutElapsed(timeout) => self.apply_timeout(timeout),
        }
    }

    fn apply_commit_certificate(
        &mut self,
        certificate: CommitCertificate<Ctx>,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        if self.height() != certificate.height {
            return Err(Error::InvalidCertificateHeight {
                certificate_height: certificate.height,
                consensus_height: self.height(),
            });
        }

        let round = certificate.round;

        match self.store_and_multiplex_commit_certificate(certificate) {
            Some(round_input) => self.apply_input(round, round_input),
            None => Ok(None),
        }
    }

    fn apply_polka_certificate(
        &mut self,
        certificate: PolkaCertificate<Ctx>,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        if self.height() != certificate.height {
            return Err(Error::InvalidCertificateHeight {
                certificate_height: certificate.height,
                consensus_height: self.height(),
            });
        }

        match self.store_and_multiplex_polka_certificate(certificate) {
            Some((input_round, round_input)) => self.apply_input(input_round, round_input),
            None => Ok(None),
        }
    }

    fn apply_new_round(
        &mut self,
        height: Ctx::Height,
        round: Round,
        proposer: Ctx::Address,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        if self.height() == height {
            // If it's a new round for same height, just reset the round, keep the valid and locked values
            self.round_state.round = round;
        } else {
            self.round_state = RoundState::new(height, round);
        }

        // Update the proposer for the new round
        self.proposer = Some(proposer);

        self.apply_input(round, RoundInput::NewRound(round))
    }

    fn apply_propose_value(
        &mut self,
        round: Round,
        value: Ctx::Value,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        self.apply_input(round, RoundInput::ProposeValue(value))
    }

    fn apply_proposal(
        &mut self,
        proposal: SignedProposal<Ctx>,
        validity: Validity,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        if self.height() != proposal.height() {
            return Err(Error::InvalidProposalHeight {
                proposal_height: proposal.height(),
                consensus_height: self.height(),
            });
        }

        let round = proposal.round();

        match self.store_and_multiplex_proposal(proposal, validity) {
            Some(round_input) => self.apply_input(round, round_input),
            None => Ok(None),
        }
    }

    fn apply_vote(
        &mut self,
        vote: SignedVote<Ctx>,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        if self.height() != vote.height() {
            return Err(Error::InvalidVoteHeight {
                vote_height: vote.height(),
                consensus_height: self.height(),
            });
        }

        if self
            .validator_set
            .get_by_address(vote.validator_address())
            .is_none()
        {
            return Err(Error::ValidatorNotFound(vote.validator_address().clone()));
        }

        let vote_round = vote.round();
        let this_round = self.round();

        let Some(output) = self.vote_keeper.apply_vote(vote, this_round) else {
            return Ok(None);
        };

        match &output {
            VKOutput::PolkaValue(val) => self.store_polka_certificate(vote_round, val),
            VKOutput::PrecommitAny => self.store_precommit_any_round_certificate(vote_round),
            VKOutput::SkipRound(round) => self.store_skip_round_certificate(*round),
            _ => (),
        }

        let (input_round, round_input) = self.multiplex_vote_threshold(output, vote_round);

        if round_input == RoundInput::NoInput {
            return Ok(None);
        }

        self.apply_input(input_round, round_input)
    }

    fn store_polka_certificate(&mut self, vote_round: Round, value_id: &ValueId<Ctx>) {
        let Some(per_round) = self.vote_keeper.per_round(vote_round) else {
            return;
        };

        self.polka_certificates.push(PolkaCertificate {
            height: self.height(),
            round: vote_round,
            value_id: value_id.clone(),
            polka_signatures: per_round
                .received_votes()
                .iter()
                .filter(|v| {
                    v.vote_type() == VoteType::Prevote
                        && v.value().as_ref() == NilOrVal::Val(value_id)
                })
                .map(|v| PolkaSignature::new(v.validator_address().clone(), v.signature.clone()))
                .collect(),
        })
    }

    fn store_precommit_any_round_certificate(&mut self, vote_round: Round) {
        let Some(per_round) = self.vote_keeper.per_round(vote_round) else {
            panic!("Missing the PrecommitAny votes for round {}", vote_round);
        };

        let precommits: Vec<SignedVote<Ctx>> = per_round
            .received_votes()
            .iter()
            .filter(|v| v.vote_type() == VoteType::Precommit)
            .cloned()
            .collect();

        self.round_certificate = Some(EnterRoundCertificate::new_from_votes(
            self.height(),
            vote_round.increment(),
            vote_round,
            precommits,
        ));
    }

    fn store_skip_round_certificate(&mut self, vote_round: Round) {
        let Some(per_round) = self.vote_keeper.per_round(vote_round) else {
            panic!("Missing the SkipRoundvotes for round {}", vote_round);
        };

        let mut seen_addresses = BTreeSet::new();
        let skip_votes: Vec<_> = per_round
            .received_votes()
            .iter()
            .filter(|vote| seen_addresses.insert(vote.validator_address()))
            .cloned()
            .collect();

        self.round_certificate = Some(EnterRoundCertificate::new_from_votes(
            self.height(),
            vote_round,
            vote_round,
            skip_votes,
        ));
    }

    fn apply_timeout(&mut self, timeout: Timeout) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        let input = match timeout.kind {
            TimeoutKind::Propose => RoundInput::TimeoutPropose,
            TimeoutKind::Prevote => RoundInput::TimeoutPrevote,
            TimeoutKind::Precommit => RoundInput::TimeoutPrecommit,

            // The driver never receives these events, so we can just ignore them.
            TimeoutKind::Rebroadcast => return Ok(None),
        };

        self.apply_input(timeout.round, input)
    }

    /// Apply the input, update the state.
    fn apply_input(
        &mut self,
        input_round: Round,
        input: RoundInput<Ctx>,
    ) -> Result<Option<RoundOutput<Ctx>>, Error<Ctx>> {
        let round_state = core::mem::take(&mut self.round_state);

        let previous_step = round_state.step;

        let proposer = self.get_proposer()?;
        let info = Info::new(input_round, &self.address, proposer.address());

        // Apply the input to the round state machine
        let transition = round_state.apply(&self.ctx, &info, input);

        // Update state
        self.round_state = transition.next_state;

        if previous_step != self.round_state.step && self.round_state.step != Step::Unstarted {
            let pending_inputs = self.multiplex_step_change(input_round);

            self.pending_inputs = pending_inputs;
        }

        // Return output, if any
        Ok(transition.output)
    }

    /// Return the traces logged during execution.
    #[cfg(feature = "debug")]
    pub fn get_traces(&self) -> &[malachitebft_core_state_machine::traces::Trace<Ctx>] {
        self.round_state.get_traces()
    }
}

impl<Ctx> fmt::Debug for Driver<Ctx>
where
    Ctx: Context,
{
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Driver")
            .field("address", &self.address)
            .field("validator_set", &self.validator_set)
            .field("proposal", &self.proposal_keeper)
            .field("votes", &self.vote_keeper)
            .field("round_state", &self.round_state)
            .finish()
    }
}

```
---
### `core-driver/src/error.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use derive_where::derive_where;

use malachitebft_core_types::{Context, Round};

/// The type of errors that can be yielded by the `Driver`.
#[derive_where(Clone, Debug, PartialEq, Eq)]
#[derive(thiserror::Error)]
pub enum Error<Ctx>
where
    Ctx: Context,
{
    /// No proposer was set for this round
    #[error("No proposer set for height {0} at round {1}")]
    NoProposer(Ctx::Height, Round),

    /// Proposer not found
    #[error("Proposer not found: {0}")]
    ProposerNotFound(Ctx::Address),

    /// Validator not found in validator set
    #[error("Validator not found: {0}")]
    ValidatorNotFound(Ctx::Address),

    /// Received a proposal for another height
    #[error("Received proposal for height {proposal_height} different from consensus height {consensus_height}")]
    InvalidProposalHeight {
        /// Proposal height
        proposal_height: Ctx::Height,
        /// Consensus height
        consensus_height: Ctx::Height,
    },

    /// Received a vote for another height
    #[error(
        "Received vote for height {vote_height} different from consensus height {consensus_height}"
    )]
    InvalidVoteHeight {
        /// Vote height
        vote_height: Ctx::Height,
        /// Consensus height
        consensus_height: Ctx::Height,
    },

    /// Received a certificate for another height
    #[error("Received certificate for height {certificate_height} different from consensus height {consensus_height}")]
    InvalidCertificateHeight {
        /// Certificate height
        certificate_height: Ctx::Height,
        /// Consensus height
        consensus_height: Ctx::Height,
    },
}

```
---
### `core-driver/src/input.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use malachitebft_core_types::{
    CommitCertificate, Context, PolkaCertificate, Round, SignedProposal, SignedVote, Timeout,
    Validity,
};

use derive_where::derive_where;

/// Events that can be received by the [`Driver`](crate::Driver).
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Input<Ctx>
where
    Ctx: Context,
{
    /// Start a new round with the given proposer
    NewRound(Ctx::Height, Round, Ctx::Address),

    /// Propose a value for the given round
    ProposeValue(Round, Ctx::Value),

    /// Receive a proposal, of the given validity
    Proposal(SignedProposal<Ctx>, Validity),

    /// Receive a vote
    Vote(SignedVote<Ctx>),

    /// Received a commit certificate
    CommitCertificate(CommitCertificate<Ctx>),

    /// Received a polka certificate
    PolkaCertificate(PolkaCertificate<Ctx>),

    /// Receive a timeout
    TimeoutElapsed(Timeout),
}

```
---
### `core-driver/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Driver for the state machine of the Malachite consensus engine

#![forbid(unsafe_code)]
#![deny(trivial_casts, trivial_numeric_casts)]
#![warn(
    missing_docs,
    rustdoc::broken_intra_doc_links,
    rustdoc::private_intra_doc_links,
    variant_size_differences
)]
// no_std compatibility
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(test), deny(clippy::unwrap_used))]
#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

extern crate alloc;

mod driver;
mod error;
mod input;
mod mux;
mod output;
mod proposal_keeper;

pub use driver::Driver;
pub use error::Error;
pub use input::Input;
pub use output::Output;

pub use malachitebft_core_votekeeper::ThresholdParams;

```
---
### `core-driver/src/mux.rs`
*2025-05-18 23:58:49 | 20 KB*
```rust
//! The Multiplexer is responsible for multiplexing the input data and returning the appropriate event to the Round State Machine.
//!
//! The table below describes the input to the Multiplexer and the output events to the Round State Machine.
//!
//! The input data is:
//! - Proposals from the Driver.
//! - The output events from the Vote Keeper.
//! - The step change from the Round State Machine.
//!
//! The table below shows the result of multiplexing an input, result that is sent as input to the round state machine, expected effects the tendermint algorithm condition.
//! Looking at the first entry as an example:
//! - If a proposal is received and a quorum of precommits exists, then the `PropAndPrecommitValue` input (L49) is sent to the round state machine.
//!   The round state machine will move to `commit` step, return the `decide(v)` to the driver.
//! - If a vote is received and as a result a quorum of precommits is reached, and if a valid proposal is present, then the same as above happens
//!
//!
//! | Step            | Vote Keeper Threshold | Proposal        | Multiplexed Input to Round SM   | New Step        | Algo Clause    | Output                             |
//! |---------------- | --------------------- | --------------- |---------------------------------| ---------       | -------------- | ---------------------------------- |
//! | any             | PrecommitValue(v)     | Proposal(v)     | PropAndPrecommitValue           | commit          | L49            | decide(v)                          |
//! | any             | PrecommitAny          | \*              | PrecommitAny                    | any (unchanged) | L47            | sch\_precommit\_timer              |
//! | propose         | none                  | InvalidProposal | InvalidProposal                 | prevote         | L22, L26       | prevote\_nil                       |
//! | propose         | none                  | Proposal        | Proposal                        | prevote         | L22, L24       | prevote(v)                         |
//! | propose         | PolkaPrevious(v, vr)  | InvalidProposal | InvalidProposalAndPolkaPrevious | prevote         | L28, L33       | prevote\_nil                       |
//! | propose         | PolkaPrevious(v, vr)  | Proposal(v,vr)  | ProposalAndPolkaPrevious        | prevote         | L28, L30       | prevote(v)                         |
//! | prevote         | PolkaNil              | \*              | PolkaNil                        | precommit       | L44            | precommit\_nil                     |
//! | prevote         | PolkaValue(v)         | Proposal(v)     | ProposalAndPolkaCurrent         | precommit       | L36, L37       | (set locked and valid)precommit(v) |
//! | prevote         | PolkaAny              | \*              | PolkaAny                        | prevote         | L34            | prevote timer                      |
//! | precommit       | PolkaValue(v)         | Proposal(v)     | ProposalAndPolkaCurrent         | precommit       | L36, L42       | (set valid)                        |

use alloc::vec::Vec;

use malachitebft_core_state_machine::input::Input as RoundInput;
use malachitebft_core_state_machine::state::Step;
use malachitebft_core_types::{CommitCertificate, PolkaCertificate, SignedProposal};
use malachitebft_core_types::{Context, Proposal, Round, Validity, Value, ValueId, VoteType};
use malachitebft_core_votekeeper::keeper::Output as VKOutput;
use malachitebft_core_votekeeper::keeper::VoteKeeper;
use malachitebft_core_votekeeper::Threshold;

use crate::Driver;

impl<Ctx> Driver<Ctx>
where
    Ctx: Context,
{
    /// Process a received proposal relative to the current state of the round, considering
    /// its validity and performing various checks to determine the appropriate round input action.
    ///
    /// This is needed because, depending on the step we are at when we receive the proposal,
    /// and the amount of votes we received for various values (or nil), we need to feed
    /// different inputs to the round state machine, instead of a plain proposal.
    ///
    /// For example, if we have a proposal for a value, and we have a quorum of precommits
    /// for that value, then we need to feed the round state machine a `ProposalAndPrecommitValue`
    /// input instead of a plain `Proposal` input.
    ///
    /// The method follows these steps:
    ///
    /// 1. Check that there is an ongoing round, otherwise return `None`
    ///
    /// 2. If the proposal is invalid, the method follows these steps:
    ///    a. If we are at propose step and the proposal's proof-of-lock (POL) round is `Nil`, return
    ///       `RoundInput::InvalidProposal`.
    ///    b. If we are at propose step and there is a polka for a prior-round proof-of-lock (POL),
    ///       return `RoundInput::InvalidProposalAndPolkaPrevious`.
    ///    c. For other steps or if there is no prior-round POL, return `None`.
    ///
    /// 3. If a quorum of precommit votes is met for the proposal's value,
    ///    return `RoundInput::ProposalAndPrecommitValue` including the proposal.
    ///
    /// 4. If the proposal is for a different round than the current one, return `None`.
    ///
    /// 5. If a polka is present for the current round and we are beyond the prevote step,
    ///    return `RoundInput::ProposalAndPolkaCurrent`, including the proposal.
    ///
    /// 6. If we are at the propose step, and a polka exists for a the propopsal's POL round,
    ///    return `RoundInput::ProposalAndPolkaPrevious`, including the proposal.
    ///
    /// 7. If none of the above conditions are met, simply wrap the proposal in
    ///    `RoundInput::Proposal` and return it.
    pub(crate) fn multiplex_proposal(
        &mut self,
        proposal: Ctx::Proposal,
        validity: Validity,
    ) -> Option<RoundInput<Ctx>> {
        // Should only receive proposals for our height.
        assert_eq!(self.height(), proposal.height());

        // Check that there is an ongoing round
        if self.round_state.round == Round::Nil {
            return None;
        }

        // Find the polka certificate for the pol_round
        let polka_certificate_for_previous = self
            .polka_certificates
            .iter()
            .find(|cert| cert.round == proposal.pol_round());

        // Determine if there is a polka for a previous round, either from the vote keeper or from the polka certificate
        let polka_previous = proposal.pol_round().is_defined()
            && proposal.pol_round() < self.round_state.round
            && (polka_certificate_for_previous.is_some()
                || self.vote_keeper.is_threshold_met(
                    &proposal.pol_round(),
                    VoteType::Prevote,
                    Threshold::Value(proposal.value().id()),
                ));

        // Handle invalid proposal
        if !validity.is_valid() {
            if self.round_state.step == Step::Propose {
                if proposal.pol_round().is_nil() {
                    // L26
                    return Some(RoundInput::InvalidProposal);
                } else if polka_previous {
                    // L32
                    return Some(RoundInput::InvalidProposalAndPolkaPrevious(proposal));
                } else {
                    return None;
                }
            } else {
                return None;
            }
        }

        // We have a valid proposal. Check if there is already a certificate for it.
        // L49
        if self.round_state.decision.is_none()
            && self
                .commit_certificate(proposal.round(), proposal.value().id())
                .is_some()
        {
            return Some(RoundInput::ProposalAndPrecommitValue(proposal));
        }

        if self.vote_keeper.is_threshold_met(
            &proposal.round(),
            VoteType::Precommit,
            Threshold::Value(proposal.value().id()),
        ) && self.round_state.decision.is_none()
        {
            return Some(RoundInput::ProposalAndPrecommitValue(proposal));
        }

        // If the proposal is for a different round, return.
        // This check must be after the L49 check above because a commit quorum from any round
        // should result in a decision.
        if self.round_state.round != proposal.round() {
            return None;
        }

        // Find the polka certificate for the current round
        let polka_certificate_for_current = self
            .polka_certificates
            .iter()
            .find(|cert| cert.round == proposal.round());

        // Determine if there is a polka for the current round, either from the vote keeper or from the polka certificate
        let polka_for_current = polka_certificate_for_current.is_some()
            || self.vote_keeper.is_threshold_met(
                &proposal.round(),
                VoteType::Prevote,
                Threshold::Value(proposal.value().id()),
            );

        let polka_current = polka_for_current && self.round_state.step >= Step::Prevote;

        // L36
        if polka_current {
            return Some(RoundInput::ProposalAndPolkaCurrent(proposal));
        }

        // L28
        if self.round_state.step == Step::Propose && polka_previous {
            return Some(RoundInput::ProposalAndPolkaPrevious(proposal));
        }

        if proposal.pol_round().is_nil() {
            // L22
            return Some(RoundInput::Proposal(proposal));
        }

        // We have `vr >= 0` without a  matching polka from round `vr`,
        // so we do not do anything and wait either:
        // - For more votes to arrive and form a polka
        // - For the Propose timeout to expire, prevote nil and move to prevote
        None
    }

    pub(crate) fn store_and_multiplex_proposal(
        &mut self,
        signed_proposal: SignedProposal<Ctx>,
        validity: Validity,
    ) -> Option<RoundInput<Ctx>> {
        // Should only receive proposals for our height.
        assert_eq!(self.height(), signed_proposal.height());

        let proposal = signed_proposal.message.clone();

        // Store the proposal and its validity
        self.proposal_keeper
            .store_proposal(signed_proposal, validity);

        self.multiplex_proposal(proposal, validity)
    }

    pub(crate) fn store_and_multiplex_commit_certificate(
        &mut self,
        certificate: CommitCertificate<Ctx>,
    ) -> Option<RoundInput<Ctx>> {
        // Should only receive proposals for our height.
        assert_eq!(self.height(), certificate.height);

        let certificate_round = certificate.round;
        let certificate_value_id = certificate.value_id.clone();

        // Store the certificate
        self.commit_certificates.push(certificate);

        if let Some((signed_proposal, validity)) =
            self.proposal_and_validity_for_round(certificate_round)
        {
            let proposal = &signed_proposal.message;
            if proposal.value().id() == certificate_value_id && validity.is_valid() {
                return Some(RoundInput::ProposalAndPrecommitValue(proposal.clone()));
            }
        }

        None
    }

    /// Store the polka certificate and multiplex the proposal.
    /// Returns the round and the input to the round state machine.
    /// The round is:
    /// - the round of the Proposal with a pol_round matching the certificate's round (L28), or
    /// - the matching proposal is at the same round (L36), or
    /// - the round of the certificate if there is no matching proposal (L44)
    pub(crate) fn store_and_multiplex_polka_certificate(
        &mut self,
        certificate: PolkaCertificate<Ctx>,
    ) -> Option<(Round, RoundInput<Ctx>)> {
        // Should only receive proposals for our height.
        assert_eq!(self.height(), certificate.height);

        let certificate_round = certificate.round;
        let certificate_value_id = certificate.value_id.clone();

        // Only add if an identical certificate isn't already present
        if !self.polka_certificates.iter().any(|existing| {
            existing.round == certificate.round && existing.value_id == certificate.value_id
        }) {
            self.polka_certificates.push(certificate);
        }

        let Some((signed_proposal, validity)) = self.proposal_and_validity_for_round(self.round())
        else {
            return Some((certificate_round, RoundInput::PolkaAny));
        };

        let proposal = &signed_proposal.message;

        if certificate_value_id == proposal.value().id() {
            if validity.is_valid() {
                if proposal.pol_round() == certificate_round {
                    Some((
                        proposal.round(),
                        RoundInput::ProposalAndPolkaPrevious(proposal.clone()),
                    ))
                } else if proposal.round() == certificate_round {
                    Some((
                        proposal.round(),
                        RoundInput::ProposalAndPolkaCurrent(proposal.clone()),
                    ))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            Some((certificate_round, RoundInput::PolkaAny))
        }
    }

    /// After a vote threshold change for a given round, check if we have a polka for nil, some value or any,
    /// based on the type of threshold and the current proposal.
    pub(crate) fn multiplex_vote_threshold(
        &mut self,
        new_threshold: VKOutput<ValueId<Ctx>>,
        threshold_round: Round,
    ) -> (Round, RoundInput<Ctx>) {
        match new_threshold {
            VKOutput::PolkaAny => (threshold_round, RoundInput::PolkaAny),
            VKOutput::PolkaNil => (threshold_round, RoundInput::PolkaNil),
            VKOutput::PrecommitAny => (threshold_round, RoundInput::PrecommitAny),
            VKOutput::SkipRound(r) => (threshold_round, RoundInput::SkipRound(r)),
            VKOutput::PrecommitValue(v) => {
                if let Some((proposal, validity)) =
                    self.proposal_and_validity_for_round(threshold_round)
                {
                    let proposal = &proposal.message;
                    if v == proposal.value().id() && validity.is_valid() {
                        (
                            threshold_round,
                            RoundInput::ProposalAndPrecommitValue(proposal.clone()),
                        )
                    } else {
                        (threshold_round, RoundInput::PrecommitAny)
                    }
                } else {
                    (threshold_round, RoundInput::PrecommitAny)
                }
            }
            VKOutput::PolkaValue(v) => {
                if let Some((proposal, validity)) =
                    self.proposal_and_validity_for_round(self.round())
                {
                    let proposal = &proposal.message;

                    if v == proposal.value().id() {
                        // We have a proposal for the same value as the threshold.
                        // validity  proposal(v, roundp, pol_round)      threshold(v, threshold_round) Output Line
                        // =================================================================================
                        // invalid   (v, roundp, pol_round)              (v, pol_round)             ProposalAndPolkaPrevious L32
                        // valid     (v, roundp, pol_round)              (v, pol_round)             InvalidProposalAndPolkaPrevious L30
                        //
                        // valid     (v, roundp, pol_round)              (v, roundp)                ProposalAndPolkaCurrent L36
                        // valid     (v, roundp, nil)                    (v, roundp)                ProposalAndPolkaCurrent L36
                        //
                        // *         *                                   (v, threshold_round)       PolkaAny L34
                        let proposal_round = proposal.round();
                        let pol_round = proposal.pol_round();
                        let pol_round_match = pol_round == threshold_round;
                        let round_match = proposal_round == threshold_round;
                        match pol_round {
                            // L32 - state machine will vote nil
                            Round::Some(_) if !validity.is_valid() && pol_round_match => (
                                proposal_round,
                                RoundInput::InvalidProposalAndPolkaPrevious(proposal.clone()),
                            ),
                            // L30
                            Round::Some(_) if validity.is_valid() && pol_round_match => (
                                proposal_round,
                                RoundInput::ProposalAndPolkaPrevious(proposal.clone()),
                            ),
                            // L36 with pol_round != *
                            _ if round_match && validity.is_valid() => (
                                threshold_round,
                                RoundInput::ProposalAndPolkaCurrent(proposal.clone()),
                            ),
                            _ => (threshold_round, RoundInput::PolkaAny),
                        }
                    } else {
                        // L34
                        (threshold_round, RoundInput::PolkaAny)
                    }
                } else {
                    // L34
                    (threshold_round, RoundInput::PolkaAny)
                }
            }
        }
    }

    /// After a step change, check for inputs to be sent to the round state machine.
    pub(crate) fn multiplex_step_change(&mut self, round: Round) -> Vec<(Round, RoundInput<Ctx>)> {
        let mut result = Vec::new();

        if let Some((signed_proposal, validity)) = self.proposal_and_validity_for_round(round) {
            let proposal = &signed_proposal.message;

            match self.round_state().step {
                Step::Propose => {
                    if let Some(input) = self.multiplex_proposal(proposal.clone(), *validity) {
                        result.push((self.round(), input))
                    }
                }

                Step::Prevote if has_polka_value(&self.vote_keeper, round, proposal) => result
                    .push(self.multiplex_vote_threshold(
                        VKOutput::PolkaValue(proposal.value().id()),
                        round,
                    )),

                _ => {}
            }
        }

        if let Some(threshold) = find_non_value_threshold(&self.vote_keeper, round) {
            result.push(self.multiplex_vote_threshold(threshold, round))
        }

        result
    }
}

fn find_non_value_threshold<Ctx>(
    votekeeper: &VoteKeeper<Ctx>,
    round: Round,
) -> Option<VKOutput<ValueId<Ctx>>>
where
    Ctx: Context,
{
    if has_precommit_any(votekeeper, round) {
        Some(VKOutput::PrecommitAny)
    } else if has_polka_nil(votekeeper, round) {
        Some(VKOutput::PolkaNil)
    } else if has_polka_any(votekeeper, round) {
        Some(VKOutput::PolkaAny)
    } else {
        None
    }
}

/// Check if we have a polka for a value
fn has_polka_value<Ctx>(
    votekeeper: &VoteKeeper<Ctx>,
    round: Round,
    proposal: &Ctx::Proposal,
) -> bool
where
    Ctx: Context,
{
    votekeeper.is_threshold_met(
        &round,
        VoteType::Prevote,
        Threshold::Value(proposal.value().id()),
    )
}

/// Check if we have a polka for nil
fn has_polka_nil<Ctx>(votekeeper: &VoteKeeper<Ctx>, round: Round) -> bool
where
    Ctx: Context,
{
    votekeeper.is_threshold_met(&round, VoteType::Prevote, Threshold::Nil)
}

/// Check if we have a polka for any
fn has_polka_any<Ctx>(votekeeper: &VoteKeeper<Ctx>, round: Round) -> bool
where
    Ctx: Context,
{
    votekeeper.is_threshold_met(&round, VoteType::Prevote, Threshold::Any)
}

/// Check if we have a quorum of precommits for any
fn has_precommit_any<Ctx>(votekeeper: &VoteKeeper<Ctx>, round: Round) -> bool
where
    Ctx: Context,
{
    votekeeper.is_threshold_met(&round, VoteType::Precommit, Threshold::Any)
}

```
---
### `core-driver/src/output.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use derive_where::derive_where;

use malachitebft_core_types::{Context, Round, Timeout};

/// Messages emitted by the [`Driver`](crate::Driver)
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Output<Ctx>
where
    Ctx: Context,
{
    /// Start a new round
    NewRound(Ctx::Height, Round),

    /// Broadcast a proposal
    Propose(Ctx::Proposal),

    /// Broadcast a vote for a value
    Vote(Ctx::Vote),

    /// Decide on a value
    Decide(Round, Ctx::Proposal),

    /// Schedule a timeout
    ScheduleTimeout(Timeout),

    /// Ask for a value at the given height, round.
    /// The timeout tells the proposal builder how long it has to build a value.
    GetValue(Ctx::Height, Round, Timeout),
}

```
---
### `core-driver/src/proposal_keeper.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
//! For storing proposals.

use alloc::collections::BTreeMap;
use alloc::vec;
use alloc::vec::Vec;

use derive_where::derive_where;
use thiserror::Error;

use malachitebft_core_types::{Context, Proposal, Round, SignedProposal, Validity};

/// Errors can that be yielded when recording a proposal.
#[derive_where(Debug)]
#[derive(Error)]
pub enum RecordProposalError<Ctx>
where
    Ctx: Context,
{
    /// Attempted to record a conflicting proposal.
    #[error("Conflicting proposal: existing: {existing}, conflicting: {conflicting}")]
    ConflictingProposal {
        /// The proposal already recorded for the same value.
        existing: SignedProposal<Ctx>,
        /// The conflicting proposal, from the same validator.
        conflicting: SignedProposal<Ctx>,
    },

    /// Attempted to record a conflicting proposal from a different validator.
    #[error("Invalid conflicting proposal: existing: {existing}, conflicting: {conflicting}")]
    InvalidConflictingProposal {
        /// The proposal already recorded for the same value.
        existing: SignedProposal<Ctx>,
        /// The conflicting proposal, from a different validator.
        conflicting: SignedProposal<Ctx>,
    },
}

#[derive_where(Clone, Debug, PartialEq, Eq, Default)]
struct PerRound<Ctx>
where
    Ctx: Context,
{
    /// The proposal received in a given round (proposal.round) if any.
    proposal: Option<(SignedProposal<Ctx>, Validity)>,
}

impl<Ctx> PerRound<Ctx>
where
    Ctx: Context,
{
    /// Add a proposal to the round, checking for conflicts.
    pub fn add(
        &mut self,
        proposal: SignedProposal<Ctx>,
        validity: Validity,
    ) -> Result<(), RecordProposalError<Ctx>> {
        if let Some((existing, _)) = self.get_proposal() {
            if existing.value() != proposal.value() {
                if existing.validator_address() != proposal.validator_address() {
                    // This is not a valid equivocating proposal, since the two proposers are different
                    // We should never reach this point, since the consensus algorithm should prevent this.
                    return Err(RecordProposalError::InvalidConflictingProposal {
                        existing: existing.clone(),
                        conflicting: proposal,
                    });
                }

                // This is an equivocating proposal
                return Err(RecordProposalError::ConflictingProposal {
                    existing: existing.clone(),
                    conflicting: proposal,
                });
            }
        }

        // Add the proposal
        self.proposal = Some((proposal, validity));

        Ok(())
    }

    /// Return the proposal received from the given validator.
    pub fn get_proposal(&self) -> Option<&(SignedProposal<Ctx>, Validity)> {
        self.proposal.as_ref()
    }
}

/// Keeps track of proposals.
#[derive_where(Clone, Debug, Default)]
pub struct ProposalKeeper<Ctx>
where
    Ctx: Context,
{
    /// The proposal for each round.
    per_round: BTreeMap<Round, PerRound<Ctx>>,

    /// Evidence of equivocation.
    evidence: EvidenceMap<Ctx>,
}

impl<Ctx> ProposalKeeper<Ctx>
where
    Ctx: Context,
{
    /// Create a new `ProposalKeeper` instance
    pub fn new() -> Self {
        Self::default()
    }

    /// Return the proposal and validity for the round.
    pub fn get_proposal_and_validity_for_round(
        &self,
        round: Round,
    ) -> Option<&(SignedProposal<Ctx>, Validity)> {
        self.per_round
            .get(&round)
            .and_then(|round_info| round_info.proposal.as_ref())
    }

    /// Return the evidence of equivocation.
    pub fn evidence(&self) -> &EvidenceMap<Ctx> {
        &self.evidence
    }

    /// Store a proposal, checking for conflicts and storing evidence of equivocation if necessary.
    ///
    /// # Precondition
    /// - The given proposal must have been proposed by the expected proposer at the proposal's height and round.
    pub fn store_proposal(&mut self, proposal: SignedProposal<Ctx>, validity: Validity) {
        let per_round = self.per_round.entry(proposal.round()).or_default();

        match per_round.add(proposal, validity) {
            Ok(()) => (),

            Err(RecordProposalError::ConflictingProposal {
                existing,
                conflicting,
            }) => {
                // This is an equivocating proposal
                self.evidence.add(existing, conflicting);
            }

            Err(RecordProposalError::InvalidConflictingProposal {
                existing,
                conflicting,
            }) => {
                // This is not a valid equivocating proposal, since the two proposers are different
                // We should never reach this point, since the consensus algorithm should prevent this.
                unreachable!(
                    "Conflicting proposals from different validators: existing: {}, conflicting: {}",
                    existing.validator_address(), conflicting.validator_address()
                );
            }
        }
    }
}

/// Keeps track of evidence of equivocation.
#[derive_where(Clone, Debug, Default)]
pub struct EvidenceMap<Ctx>
where
    Ctx: Context,
{
    #[allow(clippy::type_complexity)]
    map: BTreeMap<Ctx::Address, Vec<(SignedProposal<Ctx>, SignedProposal<Ctx>)>>,
}

impl<Ctx> EvidenceMap<Ctx>
where
    Ctx: Context,
{
    /// Create a new `EvidenceMap` instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Return whether or not there is any evidence of equivocation.
    pub fn is_empty(&self) -> bool {
        self.map.is_empty()
    }

    /// Return the evidence of equivocation for a given address, if any.
    pub fn get(
        &self,
        address: &Ctx::Address,
    ) -> Option<&Vec<(SignedProposal<Ctx>, SignedProposal<Ctx>)>> {
        self.map.get(address)
    }

    /// Add evidence of equivocating proposals, ie. two proposals submitted by the same validator,
    /// but with different values but for the same height and round.
    ///
    /// # Precondition
    /// - Panics if the two conflicting proposals were not proposed by the same validator.
    pub(crate) fn add(&mut self, existing: SignedProposal<Ctx>, conflicting: SignedProposal<Ctx>) {
        assert_eq!(
            existing.validator_address(),
            conflicting.validator_address()
        );

        if let Some(evidence) = self.map.get_mut(conflicting.validator_address()) {
            evidence.push((existing, conflicting));
        } else {
            self.map.insert(
                conflicting.validator_address().clone(),
                vec![(existing, conflicting)],
            );
        }
    }
}

```
---
### `core-driver/tests/it/basic.rs`
*2025-05-18 23:58:49 | 44 KB*
```rust
#![allow(clippy::needless_update)]

use std::sync::Arc;

use malachitebft_core_state_machine::state::{RoundValue, State, Step};
use malachitebft_core_types::{
    NilOrVal, Round, SignedProposal, SignedVote, Timeout, TimeoutKind, Validity,
};
use malachitebft_test::proposer_selector::{FixedProposer, ProposerSelector, RotateProposer};
use malachitebft_test::utils::validators::make_validators;
use malachitebft_test::{
    Address, Height, Proposal, Signature, TestContext, ValidatorSet, Value, ValueId, Vote,
};

use informalsystems_malachitebft_core_driver::{Driver, Error, Input, Output};

pub struct TestStep {
    desc: &'static str,
    input: Option<Input<TestContext>>,
    expected_outputs: Vec<Output<TestContext>>,
    expected_round: Round,
    new_state: State<TestContext>,
}

fn new_signed_proposal(
    height: Height,
    round: Round,
    value: Value,
    pol_round: Round,
    address: Address,
) -> SignedProposal<TestContext> {
    SignedProposal::new(
        Proposal::new(height, round, value.clone(), pol_round, address),
        Signature::test(),
    )
}

fn new_signed_prevote(
    height: Height,
    round: Round,
    value: NilOrVal<ValueId>,
    addr: Address,
) -> SignedVote<TestContext> {
    SignedVote::new(
        Vote::new_prevote(height, round, value, addr),
        Signature::test(),
    )
}

fn new_signed_precommit(
    height: Height,
    round: Round,
    value: NilOrVal<ValueId>,
    addr: Address,
) -> SignedVote<TestContext> {
    SignedVote::new(
        Vote::new_precommit(height, round, value, addr),
        Signature::test(),
    )
}

pub fn output_to_input(
    output: Output<TestContext>,
    sel: &dyn ProposerSelector<TestContext>,
    vs: &ValidatorSet,
) -> Option<Input<TestContext>> {
    match output {
        Output::NewRound(height, round) => {
            let proposer = sel.select_proposer(height, round, vs);
            Some(Input::NewRound(height, round, proposer))
        }
        // Let's consider our own proposal to always be valid
        Output::Propose(p) => Some(Input::Proposal(
            SignedProposal::new(p, Signature::test()),
            Validity::Valid,
        )),
        Output::Vote(v) => Some(Input::Vote(SignedVote::new(v, Signature::test()))),
        Output::Decide(_, _) => None,
        Output::ScheduleTimeout(_) => None,
        Output::GetValue(_, _, _) => None,
    }
}

#[test]
fn driver_steps_proposer() {
    let value = Value::new(9999);

    let [(v1, sk1), (v2, _sk2), (v3, _sk3)] = make_validators([1, 2, 3]);
    let (_my_sk, my_addr) = (sk1, v1.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(my_addr));
    let vs = ValidatorSet::new(vec![v1, v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let proposal = new_signed_proposal(
        Height::new(1),
        Round::new(0),
        value.clone(),
        Round::Nil,
        my_addr,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we are proposer, ask for a value to propose",
            input: Some(Input::NewRound(Height::new(1), Round::new(0), my_addr)),
            expected_outputs: vec![
                Output::ScheduleTimeout(Timeout::new(Round::new(0), TimeoutKind::Propose)),
                Output::GetValue(
                    Height::new(1),
                    Round::new(0),
                    Timeout::new(Round::new(0), TimeoutKind::Propose),
                ),
            ],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Feed a value to propose, propose that value",
            input: Some(Input::ProposeValue(Round::new(0), value.clone())),
            expected_outputs: vec![Output::Propose(proposal.message.clone())],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive our own proposal, prevote it (v1)",
            input: None,
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive our own prevote v1",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "v2 prevotes our proposal",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v2.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "v3 prevotes our proposal, we get +2/3 prevotes, precommit it (v1)",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v3.address,
            ))),
            expected_outputs: vec![Output::Vote(Vote::new_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
        TestStep {
            desc: "v1 receives its own precommit",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
        TestStep {
            desc: "v2 precommits our proposal",
            input: Some(Input::Vote(new_signed_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v2.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
        TestStep {
            desc: "v3 precommits our proposal, we get +2/3 precommits, decide it (v1)",
            input: Some(Input::Vote(new_signed_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v3.address,
            ))),
            expected_outputs: vec![Output::Decide(Round::new(0), proposal.message)],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Commit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                decision: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_proposer_timeout_get_value() {
    let [(v1, sk1), (v2, _sk2), (v3, _sk3)] = make_validators([1, 2, 3]);
    let (_my_sk, my_addr) = (sk1, v1.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(my_addr));
    let vs = ValidatorSet::new(vec![v1, v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we are proposer, ask for a value to propose",
            input: Some(Input::NewRound(Height::new(1), Round::new(0), my_addr)),
            expected_outputs: vec![
                Output::ScheduleTimeout(Timeout::new(Round::new(0), TimeoutKind::Propose)),
                Output::GetValue(
                    Height::new(1),
                    Round::new(0),
                    Timeout::new(Round::new(0), TimeoutKind::Propose),
                ),
            ],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive a propose timeout",
            input: Some(Input::TimeoutElapsed(Timeout::propose(Round::new(0)))),
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                round: Round::new(0),
                height: Height::new(1),
                step: Step::Prevote,
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_not_proposer_valid() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([1, 2, 3]);

    // Proposer is v1, so we are not the proposer
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(v1.address));
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let proposal = new_signed_proposal(
        Height::new(1),
        Round::new(0),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we are not the proposer",
            input: Some(Input::NewRound(
                Height::new(1),
                Round::new(0),
                proposal.validator_address,
            )),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive a proposal, prevote it (v2)",
            input: Some(Input::Proposal(proposal.clone(), Validity::Valid)),
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive our own prevote (v2)",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "v1 prevotes its own proposal",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "v3 prevotes v1's proposal, v2 gets +2/3 prevotes, precommits it",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v3.address,
            ))),
            expected_outputs: vec![Output::Vote(Vote::new_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
        TestStep {
            desc: "we receive our own precommit",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
        TestStep {
            desc: "v1 precommits its proposal",
            input: Some(Input::Vote(new_signed_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
        TestStep {
            desc: "v3 precommits v1's proposal, it gets +2/3 precommits, decide it",
            input: Some(Input::Vote(new_signed_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v3.address,
            ))),
            expected_outputs: vec![Output::Decide(Round::new(0), proposal.message)],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Commit,
                locked: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                valid: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                decision: Some(RoundValue {
                    value: value.clone(),
                    round: Round::new(0),
                }),
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_not_proposer_invalid() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([1, 2, 3]);

    // Proposer is v1, so we are not the proposer
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(v1.address));
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let proposal = new_signed_proposal(
        Height::new(1),
        Round::new(0),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we are not the proposer",
            input: Some(Input::NewRound(
                Height::new(1),
                Round::new(0),
                proposal.validator_address,
            )),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive an invalid proposal, prevote nil (v2)",
            input: Some(Input::Proposal(proposal.clone(), Validity::Invalid)),
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive our own prevote (v2)",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "v1 prevotes its own proposal",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc:
                "v3 prevotes v1's proposal, we have a polka for any, schedule prevote timeout (v2)",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v3.address,
            ))),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::prevote(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        TestStep {
            desc: "prevote timeout elapses, we precommit nil (v2)",
            input: Some(Input::TimeoutElapsed(Timeout::prevote(Round::new(0)))),
            expected_outputs: vec![Output::Vote(Vote::new_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_not_proposer_other_height() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2)] = make_validators([1, 2]);

    // Proposer is v1, so we are not the proposer
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(v1.address));
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    // Proposal is for another height
    let proposal = new_signed_proposal(
        Height::new(2),
        Round::new(0),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we are not the proposer",
            input: Some(Input::NewRound(
                Height::new(1),
                Round::new(0),
                proposal.validator_address,
            )),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive a proposal for another height, ignore it (v2)",
            input: Some(Input::Proposal(proposal.clone(), Validity::Invalid)),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
    ];

    let expected_error = Error::InvalidProposalHeight {
        proposal_height: Height::new(2),
        consensus_height: Height::new(1),
    };

    run_steps_failing(&mut driver, steps, expected_error, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_not_proposer_other_round() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2)] = make_validators([1, 2]);

    // Proposer is v1, so we are not the proposer
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(v1.address));
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    // Proposal is for another round
    let proposal = new_signed_proposal(
        Height::new(1),
        Round::new(1),
        value.clone(),
        Round::Nil,
        v2.address,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we are not the proposer",
            input: Some(Input::NewRound(Height::new(1), Round::new(0), v1.address)),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Receive a proposal for another round, ignore it (v2)",
            input: Some(Input::Proposal(proposal.clone(), Validity::Invalid)),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_not_proposer_timeout_multiple_rounds() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([1, 3, 1]);

    // Proposer is v1, so we, v3, are not the proposer
    let (_my_sk, my_addr) = (sk3, v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let sel = Arc::new(FixedProposer::new(v1.address));
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let steps = vec![
        // Start round 0, we, v3, are not the proposer
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer",
            input: Some(Input::NewRound(Height::new(1), Round::new(0), v1.address)),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        // Receive a propose timeout, prevote nil (from v3)
        TestStep {
            desc: "Receive a propose timeout, prevote nil (v3)",
            input: Some(Input::TimeoutElapsed(Timeout::propose(Round::new(0)))),
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                round: Round::new(0),
                height: Height::new(1),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // Receive our own prevote v3
        TestStep {
            desc: "Receive our own prevote v3",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // v1 prevotes its own proposal
        TestStep {
            desc: "v1 prevotes its own proposal",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // v2 prevotes nil, we get +2/3 nil prevotes and precommit nil
        TestStep {
            desc: "v2 prevotes nil, we get +2/3 prevotes, precommit nil",
            input: Some(Input::Vote(new_signed_prevote(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                v2.address,
            ))),
            expected_outputs: vec![Output::Vote(Vote::new_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                ..Default::default()
            },
        },
        // v3 receives its own precommit
        TestStep {
            desc: "v3 receives its own precommit",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                ..Default::default()
            },
        },
        // v1 precommits its proposal
        TestStep {
            desc: "v1 precommits its proposal",
            input: Some(Input::Vote(new_signed_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                ..Default::default()
            },
        },
        // v2 precommits nil
        TestStep {
            desc: "v2 precommits nil",
            input: Some(Input::Vote(new_signed_precommit(
                Height::new(1),
                Round::new(0),
                NilOrVal::Nil,
                v2.address,
            ))),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::precommit(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height: Height::new(1),
                round: Round::new(0),
                step: Step::Precommit,
                ..Default::default()
            },
        },
        // we receive a precommit timeout, start a new round
        TestStep {
            desc: "we receive a precommit timeout, start a new round",
            input: Some(Input::TimeoutElapsed(Timeout::precommit(Round::new(0)))),
            expected_outputs: vec![Output::NewRound(Height::new(1), Round::new(1))],
            expected_round: Round::new(1),
            new_state: State {
                height: Height::new(1),
                round: Round::new(1),
                step: Step::Unstarted,
                ..Default::default()
            },
        },
        TestStep {
            desc: "Start round 1, we are not the proposer",
            input: Some(Input::NewRound(Height::new(1), Round::new(1), v2.address)),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(1)))],
            expected_round: Round::new(1),
            new_state: State {
                height: Height::new(1),
                round: Round::new(1),
                step: Step::Propose,
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

// No value to propose
#[test]
fn driver_steps_no_value_to_propose() {
    let [(v1, sk1), (v2, _sk2), (v3, _sk3)] = make_validators([1, 2, 3]);
    let (_my_sk, my_addr) = (sk1, v1.address);

    let height = Height::new(1);
    let ctx = TestContext::new();

    // We are the proposer
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let outputs = driver
        .process(Input::NewRound(Height::new(1), Round::new(0), v1.address))
        .expect("execute succeeded");

    assert_eq!(
        outputs,
        vec!(
            Output::ScheduleTimeout(Timeout::new(Round::new(0), TimeoutKind::Propose)),
            Output::GetValue(
                Height::new(1),
                Round::new(0),
                Timeout::propose(Round::new(0))
            )
        )
    );
}

#[test]
fn driver_steps_proposer_not_found() {
    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([1, 2, 3]);

    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();

    // Proposer is v1, which is not in the validator set
    let vs = ValidatorSet::new(vec![v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let output = driver.process(Input::NewRound(Height::new(1), Round::new(0), v1.address));
    assert_eq!(output, Err(Error::ProposerNotFound(v1.address)));
}

#[test]
fn driver_steps_validator_not_found() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([1, 2, 3]);

    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();

    // Proposer is v1
    // We omit v2 from the validator set
    let vs = ValidatorSet::new(vec![v1.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    // Start new height
    driver
        .process(Input::NewRound(Height::new(1), Round::new(0), v1.address))
        .expect("execute succeeded");

    // v2 prevotes some proposal, we cannot find it in the validator set => error
    let output = driver.process(Input::Vote(new_signed_prevote(
        Height::new(1),
        Round::new(0),
        NilOrVal::Val(value.id()),
        v2.address,
    )));

    assert_eq!(output, Err(Error::ValidatorNotFound(v2.address)));
}

#[test]
fn driver_steps_skip_round_skip_threshold() {
    let value = Value::new(9999);

    let sel = Arc::new(RotateProposer);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([1, 1, 1]);

    // Proposer is v1, so we, v3, are not the proposer
    let (_my_sk, my_addr) = (sk3, v3.address);

    let ctx = TestContext::new();
    let height = Height::new(1);

    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);
    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let steps = vec![
        // Start round 0, we, v3, are not the proposer
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer",
            input: Some(Input::NewRound(height, Round::new(0), v1.address)),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        // Receive a propose timeout, prevote nil (from v3)
        TestStep {
            desc: "Receive a propose timeout, prevote nil (v3)",
            input: Some(Input::TimeoutElapsed(Timeout::propose(Round::new(0)))),
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                height,
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // Receive our own prevote v3
        TestStep {
            desc: "Receive our own prevote v3",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // v1 prevotes its own proposal
        TestStep {
            desc: "v1 prevotes its own proposal in round 1",
            input: Some(Input::Vote(new_signed_prevote(
                height,
                Round::new(1),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // v2 prevotes v1 proposal in round 1, expected output is to move to next round
        TestStep {
            desc: "v2 prevotes v1 proposal, we get +1/3 messages from future round",
            input: Some(Input::Vote(new_signed_prevote(
                height,
                Round::new(1),
                NilOrVal::Val(value.id()),
                v2.address,
            ))),
            expected_outputs: vec![Output::NewRound(height, Round::new(1))],
            expected_round: Round::new(1),
            new_state: State {
                height,
                round: Round::new(1),
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

#[test]
fn driver_steps_skip_round_quorum_threshold() {
    let value = Value::new(9999);

    let sel = Arc::new(RotateProposer);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([1, 2, 1]);

    // Proposer is v1, so we, v3, are not the proposer
    let (_my_sk, my_addr) = (sk3, v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();

    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);
    let mut driver = Driver::new(ctx, height, vs.clone(), my_addr, Default::default());

    let steps = vec![
        // Start round 0, we, v3, are not the proposer
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer",
            input: Some(Input::NewRound(height, Round::new(0), v1.address)),
            expected_outputs: vec![Output::ScheduleTimeout(Timeout::propose(Round::new(0)))],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Propose,
                ..Default::default()
            },
        },
        // Receive a propose timeout, prevote nil (from v3)
        TestStep {
            desc: "Receive a propose timeout, prevote nil (v3)",
            input: Some(Input::TimeoutElapsed(Timeout::propose(Round::new(0)))),
            expected_outputs: vec![Output::Vote(Vote::new_prevote(
                height,
                Round::new(0),
                NilOrVal::Nil,
                my_addr,
            ))],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // Receive our own prevote v3
        TestStep {
            desc: "Receive our own prevote v3",
            input: None,
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // v1 prevotes its own proposal
        TestStep {
            desc: "v1 prevotes its own proposal in round 1",
            input: Some(Input::Vote(new_signed_prevote(
                height,
                Round::new(1),
                NilOrVal::Val(value.id()),
                v1.address,
            ))),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: State {
                height,
                round: Round::new(0),
                step: Step::Prevote,
                ..Default::default()
            },
        },
        // v2 prevotes v1 proposal in round 1, expected output is to move to next round
        TestStep {
            desc: "v2 prevotes v1 proposal, we get +1/3 messages from future round",
            input: Some(Input::Vote(new_signed_prevote(
                height,
                Round::new(1),
                NilOrVal::Val(value.id()),
                v2.address,
            ))),
            expected_outputs: vec![Output::NewRound(height, Round::new(1))],
            expected_round: Round::new(1),
            new_state: State {
                height,
                round: Round::new(1),
                step: Step::Unstarted,
                ..Default::default()
            },
        },
    ];

    run_steps(&mut driver, steps, sel.as_ref(), &vs);
}

fn run_steps(
    driver: &mut Driver<TestContext>,
    steps: Vec<TestStep>,
    sel: &dyn ProposerSelector<TestContext>,
    vs: &ValidatorSet,
) {
    let mut input_from_prev_output = None;

    for step in steps {
        println!("Step: {}", step.desc);

        let input = step
            .input
            .unwrap_or_else(|| input_from_prev_output.unwrap());

        let mut outputs = driver.process(input).expect("execute succeeded");

        assert_eq!(outputs, step.expected_outputs, "expected outputs");
        assert_eq!(driver.round(), step.expected_round, "expected round");
        assert_eq!(driver.round_state(), &step.new_state, "new state");

        input_from_prev_output = outputs
            .pop()
            .and_then(|input| output_to_input(input, sel, vs));
    }
}

fn run_steps_failing(
    driver: &mut Driver<TestContext>,
    steps: Vec<TestStep>,
    expected_error: Error<TestContext>,
    sel: &dyn ProposerSelector<TestContext>,
    vs: &ValidatorSet,
) {
    let mut input_from_prev_output = None;

    for step in steps {
        println!("Step: {}", step.desc);

        let input = step
            .input
            .unwrap_or_else(|| input_from_prev_output.unwrap());

        match driver.process(input) {
            Ok(mut outputs) => {
                assert_eq!(outputs, step.expected_outputs, "expected outputs");
                assert_eq!(driver.round(), step.expected_round, "expected round");
                assert_eq!(driver.round_state(), &step.new_state, "new state");

                input_from_prev_output = outputs
                    .pop()
                    .and_then(|input| output_to_input(input, sel, vs));
            }

            Err(error) => {
                assert_eq!(error, expected_error, "expected error");
                return;
            }
        }
    }
}

```
---
### `core-driver/tests/it/extra.rs`
*2025-05-18 23:58:49 | 81 KB*
```rust
use malachitebft_core_state_machine::state::State;
use malachitebft_core_types::{Round, Validity};

use malachitebft_test::utils::validators::make_validators;
use malachitebft_test::{Height, Proposal, TestContext, ValidatorSet, Value};

use informalsystems_malachitebft_core_driver::{Driver, Input, Output};

use crate::utils::*;

// The following tests are performed:
// - L49 with commits from current rounds, no locked value, no valid value:
//    `driver_steps_decide_current_with_no_locked_no_valid()`
//
// - L49 with commits from previous rounds, no locked value, no valid value:
//    `driver_steps_decide_previous_with_no_locked_no_valid()`
//
// - L49 with commits from previous round, with locked and valid values
//    `driver_steps_decide_previous_with_locked_and_valid()`
//
// - L28 in round 1, via L36 in round 0, with locked invalid value v.
//     `driver_steps_polka_previous_invalid_proposal()`'
//
// - L23 in round 1, via L36 in round 0, with lockedValue != v.
//     `driver_steps_polka_previous_new_proposal()`
//
// - L28 in round 1 with no locked value, via L36 in round 0 with step precommit.
//     `driver_steps_polka_previous_with_no_locked()`
//
// - L28 in round 1 with locked value, via L36 in round 0 with step prevote.
//      `driver_steps_polka_previous_with_locked()
//
// - L44 with previously received polkaNil and entering prevote (due to timeoutPropose)
//      `driver_steps_polka_nil_and_timeout_propose()`
//
// - L36 with previoustly received polkaValue and proposal, and entering prevote (due to received proposal)
//      `driver_steps_polka_value_then_proposal()`
//
// - L34 with previously received polkaAny and entering prevote (due to received proposal)
//      `driver_steps_polka_any_then_proposal_other()`

struct TestStep {
    desc: &'static str,
    input: Input<TestContext>,
    expected_outputs: Vec<Output<TestContext>>,
    expected_round: Round,
    new_state: State<TestContext>,
}

// Arrive at L49 with commits from current rounds, no locked value, no valid value
//
// Ev:             NewRound                    <quorum>                       Proposal
// State: NewRound -------------------> Propose --------------------> Propose -------> Commit
// Msg:            start_propose_timer          start_precommit_timer         decide
// Alg:            L21                          L48                           L49
//
// v1=2, v2=3, v3=2, we are v3
//
// L21 - v3 is not proposer starts propose timer (step propose)
// L46 - v3 gets +2/3 precommits (from v1 and v2), starts precommit timer (step propose)
// L49 - v3 receives proposal and has already +2/3 precommit(id(v), round=0) (step decided)
#[test]
fn driver_steps_decide_current_with_no_locked_no_valid() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(0),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 precommits a proposal",
            input: precommit_input(Round::new(0), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 precommits the same proposal, we get +2/3 precommit, start precommit timer",
            input: precommit_input(Round::new(0), value.clone(), &v2.address),
            expected_outputs: vec![start_precommit_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![decide_output(Round::new(0), proposal)],
            expected_round: Round::new(0),
            new_state: decided_state(Round::new(0), Round::new(0), value),
        },
    ];

    run_steps(&mut driver, steps)
}

// Arrive at L49 with commits from previous rounds, no locked value, no valid value
//
// Ev:             NewRound(0)           Timeout(propose)          <polka>               Timeout(prevote)
// State: NewRound ------------> Propose ----------------> Prevote ------------> Prevote ---------------> Precommit -->
// Msg:            propose_timer         Prevote(nil)              prevote_timer         Precommit(nil)
// Alg:            L21                   L57                       L34                   L61
//
// Ev:              <quorum>              Timeout(precommit)         NewRound(1)          Proposal+<quorum>
// State: Precommit ----------> Precommit ---------------> NewRound -----------> Propose -----------------> Decided
// Msg:             precommit_timer       new_round(1)              propose_timer         decide
// Alg:             L46                   L65                       L21                   L49
//
// v1=2, v2=3, v3=2, we are v3
// L21 - v3 is not proposer starts propose timer (step propose)
// L57 - v3 receives timeout propose, prevote nil (step prevote)
// L34 - v3 gets +2/3 prevotes (from v1 and v2), starts prevote timer (step prevote)
// L61 - v3 receives timeout prevote, precommit nil (step precommit)
// L46 - v3 gets +2/3 precommits (from v1 and v2), starts precommit timer (step precommit)
// L65 - v3 receives timeout precommit, starts new round (step new_round)
// L21 - v3 receives new round, is not the proposer, starts propose timer
// L49 - v3 receives proposal(v, round=0) and has already +2/3 precommit(id(v), round=0) (step decided)
#[test]
fn driver_steps_decide_previous_with_no_locked_no_valid() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(0),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout propopse, prevote nil (v3)",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![prevote_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes a proposal",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes same proposal, we get +2/3 prevotes, start prevote timer",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![start_prevote_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 precommits a proposal",
            input: precommit_input(Round::new(0), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 precommits the same proposal, we get +2/3 precommit, start precommit timer",
            input: precommit_input(Round::new(0), value.clone(), &v2.address),
            expected_outputs: vec![start_precommit_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout precommit, start new round",
            input: timeout_precommit_input(Round::new(0)),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc: "Start round 1, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state(Round::new(1)),
        },
        TestStep {
            desc: "Receive proposal",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![decide_output(Round::new(1), proposal)],
            expected_round: Round::new(1),
            new_state: decided_state(Round::new(1), Round::new(0), value),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L49 with commits from previous round, with locked and valid values
//
// Ev:             NewRound(0)           Timeout(propose)          <polka>               Proposal
// State: NewRound ------------> Propose ----------------> Prevote ------------> Prevote ---------------> Precommit -->
// Msg:            propose_timer         Prevote(nil)              prevote_timer         Precommit(value)
// Alg:            L21                   L57                       L34                   L40
//
// Ev:              <honest precommit(round=1)>            NewRound(1)          <quorum precommit>
// State: Precommit ---------------------------> NewRound -----------> Propose --------------------> Commit
// Msg:             new_round(1)                 propose_timer                  decide(v, round=1)
// Alg:             L56                          L21                            L49-L54
//
// v1=2, v2=3, v3=2, we are v3
// L21 - start round 0, we, v3, are not the proposer, start timeout propose (step propose)
// L57 - timeout propose, prevote nil (v2) (step prevote)
// L34 - v1 and v2 prevote same proposal, we get +2/3 prevotes, start prevote timer (step prevote)
// L37-L43 - v3 receives the proposal, sets locked and value (step precommit)
// L55 - v2 precommits the value in round 1, i.e. v3 receives f+1 vote for round 1 from v2 (step new_round)
// L11 - v3 starts new round, not proposer, start timeout propose (step propose)
// L49 - v3 gets +2/3 precommits (from v1 and v2) for round 0, it has the proposal, decide
//
#[test]
fn driver_steps_decide_previous_with_locked_and_valid() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(0),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout propopse, prevote nil (v3)",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![prevote_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes a proposal",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes same proposal, we get +2/3 prevotes, start prevote timer",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![start_prevote_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal, L37-L43",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![precommit_output(
                Round::new(0),
                Value::new(9999),
                &v3.address,
            )],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(0),
                proposal.clone(),
            ),
        },
        TestStep {
            desc: "v2 precommits the value in round 1, we get f+1 votes for round 1 from v2",
            input: precommit_input(Round::new(1), Value::new(9999), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round_with_proposal_and_locked_and_valid(
                Round::new(1),
                proposal.clone(),
            ),
        },
        TestStep {
            desc: "Start round 1, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                proposal.clone(),
            ),
        },
        TestStep {
            desc: "v1 precommits for round 0 and same proposal",
            input: precommit_input(Round::new(0), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(1),
            new_state: propose_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                proposal.clone(),
            ),
        },
        TestStep {
            desc: "v2 precommits for round 0 and same proposal, we get +2/3 precommit, decide",
            input: precommit_input(Round::new(0), value.clone(), &v2.address),
            expected_outputs: vec![decide_output(Round::new(1), proposal.clone())],
            expected_round: Round::new(1),
            new_state: decided_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                proposal.clone(),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L36 in round 0, with step prevote and then L28 in round 1, with locked value v.
//
// Ev:             NewRound(0)           Proposal           <polka>                <honest precommit(round=1)>
// State: NewRound ------------> Propose ---------> Prevote -----------> Precommit ---------------------------> NewRound -->
// Msg:            propose_timer         prevote(v)         precommit(v)           new_round(1)
// Alg:            L21                   L24                L37                    L56
//
// Ev:             NewRound(1)             Proposal(+polka)
// State: NewRound --------------> Propose -----------------> Prevote
// Msg:            propose(v, pol)         prevote(v,round=1)
// Alg:            L16, L19                L28-L30
//
// v1=2, v2=2, v3=3, we are v2
// Trying to arrive at L36 with step prevote and then L28
// L21 - v2 is not proposer starts timeout propose (step propose)
// L24 - v2 receives proposal(v) from v1, prevotes v (step prevote)
// L37 - v1 and v3 prevote v, v2 gets +2/3 prevotes, locked_value=v, valid_value=v, sends precommit(v) (step precommit)
// L56 - v2 receives a precommit(id(v), round=1) from v3, starts new round (step new_round)
//   Note - this doesn't seem correct v3 behaviour (??)
// L16, L19 - v2 is the proposer and has both a locked and valid value from round 0, propose(round=1, value=v, valid_round=0) (step propose)
// L28 - v2 receives its proposal and has 2f+1 prevotes from round 0 and:
//   L29 - locked_round(0) <= valid_round(0) and valid_round(0) < round(1)
//     L30 - v2 sends prevote(id(v), round=1) (step prevote)
#[test]
fn driver_steps_polka_previous_with_locked() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([2, 2, 3]);
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v2, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive a proposal from v1 - L22 send prevote",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(0), value.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(
                Round::new(0),
                // Proposal::new(Height::new(1), Round::new(0), value.clone(), Round::Nil),
            ),
        },
        TestStep {
            desc: "v3 prevotes the proposal",
            input: prevote_input(value.clone(), &v3.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(
                Round::new(0),
                // Proposal::new(Height::new(1), Round::new(0), value.clone(), Round::Nil),
            ),
        },
        TestStep {
            desc: "v1 prevotes same proposal, we get +2/3 prevotes, precommit",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![precommit_output(Round::new(0), value.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(0),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v1.address,
                ),
            ),
        },
        TestStep {
            desc: "Receive f+1 vote for round 1 from v3",
            input: precommit_input(Round::new(1), Value::new(8888), &v3.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v1.address,
                ),
            ),
        },
        TestStep {
            desc: "Start round 1, we are proposer with a valid value, propose it",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![proposal_output(
                Round::new(1),
                value.clone(),
                Round::new(0),
                v2.address,
            )],
            expected_round: Round::new(1),
            new_state: propose_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v2.address,
                ),
            ),
        },
        TestStep {
            desc: "Receive our own proposal",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::new(0),
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(1), value.clone(), &v2.address)],
            expected_round: Round::new(1),
            new_state: prevote_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value.clone(),
                    Round::new(0),
                    v2.address,
                ),
            ),
        },
    ];

    run_steps(&mut driver, steps)
}

#[test]
fn driver_steps_polka_previous_not_locked_vote_last_l30() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([2, 2, 3]);
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v2, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive a proposal from v1 - L22 send prevote",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(0), value.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes the proposal",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v3 proposes with valid round at round 1",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::new(0),
                Validity::Valid,
                v3.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive f+1 vote for round 1 from v3",
            input: precommit_input(Round::new(1), Value::new(8888), &v3.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc: "Start round 1",
            input: new_round_input(Round::new(1), v3.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state(Round::new(1)),
        },
        TestStep {
            desc: "v3 prevotes the proposal at round 0",
            input: prevote_input(value.clone(), &v3.address),
            expected_outputs: vec![prevote_output(Round::new(1), value.clone(), &my_addr)],
            expected_round: Round::new(1),
            new_state: prevote_state(Round::new(1)),
        },
    ];

    run_steps(&mut driver, steps)
}

#[test]
fn driver_steps_polka_previous_locked_vote_last_l32() {
    let value1 = Value::new(9999);
    let value2 = Value::new(8888);
    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([2, 2, 3]);
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "(v2): Starts round 0 (v1 is proposer), starts timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Timeout propose expires in round 0",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![prevote_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Receives a prevote(nil) from v2(itself) in round 0",
            input: prevote_nil_input(&my_addr),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Receives a proposal(value1) from v1 in round 0",
            input: proposal_input(
                Round::new(0),
                value1.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Receives prevote(value1) from v3 in round 0, starts timeout prevote",
            input: prevote_input(value1.clone(), &v3.address),
            expected_outputs: vec![start_prevote_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Timeout prevote expires in round 0",
            input: timeout_prevote_input(Round::new(0)),
            expected_outputs: vec![precommit_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Receives precommit(nil) from v2(itself) in round 0",
            input: precommit_nil_input(Round::new(0), &my_addr),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Receives precommit(nil) from v3 in round 0, starts timeout precommit",
            input: precommit_nil_input(Round::new(0), &v3.address),
            expected_outputs: vec![start_precommit_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "(v2): Timeout precommit expires in round 0",
            input: timeout_precommit_input(Round::new(0)),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        // Round 1
        TestStep {
            desc: "(v2): Starts round 1(v3 is proposer), starts timeout propose",
            input: new_round_input(Round::new(1), v3.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state(Round::new(1)),
        },
        TestStep {
            desc: "(v2): Receives proposal(value2) from v3 in round 1",
            input: proposal_input(
                Round::new(1),
                value2.clone(),
                Round::Nil,
                Validity::Valid,
                v3.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(1), value2.clone(), &my_addr)],
            expected_round: Round::new(1),
            new_state: prevote_state(Round::new(1)),
        },
        TestStep {
            desc: "(v2): Receives prevote(value2) from v3 in round 1",
            input: prevote_input_at(Round::new(1), value2.clone(), &v3.address),
            expected_outputs: vec![],
            expected_round: Round::new(1),
            new_state: prevote_state(Round::new(1)),
        },
        TestStep {
            desc: "(v2): Receives prevote(value2) from v2(itself) in round 1, locks value2",
            input: prevote_input_at(Round::new(1), value2.clone(), &v2.address),
            expected_outputs: vec![precommit_output(Round::new(1), value2.clone(), &my_addr)],
            expected_round: Round::new(1),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
        TestStep {
            desc: "(v2): Receives precommit(value2) from v2(itself) in round 1",
            input: precommit_input_at(Round::new(1), value2.clone(), &my_addr),
            expected_outputs: vec![],
            expected_round: Round::new(1),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
        TestStep {
            desc: "(v2): Receives precommit(nil) from v3 in round 1, start timeout precommit",
            input: precommit_nil_input(Round::new(1), &v3.address),
            expected_outputs: vec![start_precommit_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
        TestStep {
            desc: "(v2): Timeout precommit expires in round 1",
            input: timeout_precommit_input(Round::new(1)),
            expected_outputs: vec![new_round_output(Round::new(2))],
            expected_round: Round::new(2),
            new_state: new_round_with_proposal_and_locked_and_valid(
                Round::new(2),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
        // Round 2
        TestStep {
            desc: "(v2): Starts round 2(v1 is proposer), starts timeout propose",
            input: new_round_input(Round::new(2), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(2))],
            expected_round: Round::new(2),
            new_state: propose_state_with_proposal_and_locked_and_valid(
                Round::new(2),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
        TestStep {
            desc: "(v2): Receives proposal(value1) from v1 in round 2",
            input: proposal_input(
                Round::new(2),
                value1.clone(),
                Round::new(0),
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(2),
            new_state: propose_state_with_proposal_and_locked_and_valid(
                Round::new(2),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
        TestStep {
            desc: "(v2): Receives prevote(value1) from v1 from round 0",
            input: prevote_input_at(Round::new(0), value1.clone(), &v1.address),
            expected_outputs: vec![prevote_nil_output(Round::new(2), &my_addr)],
            expected_round: Round::new(2),
            new_state: prevote_state_with_matching_proposal_and_locked_and_valid(
                Round::new(2),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value2.clone(),
                    Round::Nil,
                    v3.address,
                ),
            ),
        },
    ];

    run_steps(&mut driver, steps)
}

// Arrive at L36 in round 0, with step precommit and then L28 in round 1 with invalid value.
//
// Ev:             NewRound(0)           Timeout(propose)        <polka>                <honest precommit(round=1)>
// State: NewRound ------------> Propose --------------> Prevote -------------> Prevote ---------------------------> NewRound -->
// Msg:            propose_timer         prevote(nil)            prevote_timer          new_round(1)
// Alg:            L21                   L59                     L35                    L56
//
// Ev:             NewRound(1)              InvalidProposal(round=0)
// State: NewRound ---------------> Propose -----------------------> Prevote
// Msg:            propose_timer            prevote(nil,round=1)
// Alg:            L21                      L28-L32
//
// v1=2, v2=3, v3=2, we are v3
// L21 - v3 is not proposer starts timeout propose (step propose)
// L57 - propose timeout, prevote nil (step prevote)
// L37 - v1 and v2 prevote v, v3 gets +2/3 prevotes, start timeout prevote (step prevote)
// L55 - Receive f+1 vote for round 1 from v2, start new round (step new_round)
// L21 - v3 is not proposer starts timeout propose (step propose)
// L28 - v3 receives invalid proposal and has 2f+1 prevotes from round 0 and:
//   L29 - with invalid proposal
//     L32 - v2 sends prevote(nil, round=1) (step prevote)
#[test]
fn driver_steps_polka_previous_invalid_proposal() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3, v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout propopse, prevote nil (v3)",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![prevote_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes a proposal",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes same proposal, we get +2/3 prevotes, start prevote timer",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![start_prevote_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive f+1 vote for round 1 from v2",
            input: prevote_input_at(Round::new(1), value.clone(), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc: "Start round 1, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state(Round::new(1)),
        },
        TestStep {
            desc: "Receive an invalid proposal for POL round 0",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::new(0),
                Validity::Invalid,
                v1.address,
            ),
            expected_outputs: vec![prevote_nil_output(Round::new(1), &my_addr)],
            expected_round: Round::new(1),
            new_state: prevote_state(Round::new(1)),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L36 in round 0, with step precommit and then L23 in round 1 with lockedValue != v.
//
// Ev:             NewRound(0)           Proposal           <polka>                <honest precommit(round=1)>
// State: NewRound ------------> Propose ---------> Prevote -----------> Precommit ---------------------------> NewRound -->
// Msg:            propose_timer         prevote(v)         precommit(v)           new_round(1)
// Alg:            L21                   L24                L37                    L56
//
// Ev:             NewRound(1)              Proposal(other_value, pol_round=0)
// State: NewRound ---------------> Propose ----------------------------------> Prevote
// Msg:            propose_timer            prevote(nil,round=1)
// Alg:            L21                      L26
//
// v1=2, v2=3, v3=2, we are v3
// L21 - v3 is not proposer starts timeout propose (step propose)
// L24 - v3 receives proposal, prevotes value  (step prevote)
// L37 - v1 and v2 prevote v, v3 gets +2/3 prevotes (step precommit)
// L56 - Receive f+1 vote for round 1 from v2, start new round (step new_round)
// L21 - v3 is not proposer starts timeout propose (step propose)
// L22 - v3 receives proposal for a different value and no POL round:
//   L23 - valid(v) and lockedValue != v
//     L26 - v2 sends prevote(nil, round=1) (step prevote)
#[test]
fn driver_steps_polka_previous_new_proposal() {
    let value = Value::new(9999);
    let other_value = Value::new(8888);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3, v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive a valid proposal for round 0",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(0), value.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes the proposal",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes same proposal, we get +2/3 prevotes, precommit",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![precommit_output(Round::new(0), value.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(0),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v1.address,
                ),
            ),
        },
        TestStep {
            desc: "Receive f+1 vote for round 1 from v2",
            input: prevote_input_at(Round::new(1), value.clone(), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v1.address,
                ),
            ),
        },
        TestStep {
            desc: "Start round 1, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v1.address,
                ),
            ),
        },
        TestStep {
            desc: "Receive a valid proposal for round 1 with different value",
            input: proposal_input(
                Round::new(1),
                other_value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_nil_output(Round::new(1), &my_addr)],
            expected_round: Round::new(1),
            new_state: prevote_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                Proposal::new(
                    Height::new(1),
                    Round::new(1),
                    value.clone(),
                    Round::new(0),
                    v1.address,
                ),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L36 in round 0, with step precommit and then L28 in round 1 with no locked value.
//
// Ev:             NewRound(0)           Timeout(propose)         <polka>              Timeout(prevote)
// State: NewRound ------------> Propose ---------------> Prevote -----------> Prevote -----------------> Precommit -->
// Msg:            propose_timer         Prevote(nil)             prevote_timer        Precommit(nil)
// Alg:            L21                   L59                      L34                  L63
//
// Ev:              Proposal(v)           <honest precommit(round=1)>
// State: Precommit ----------> Precommit --------------------------> NewRound -->
// Msg:             none                  new_round(1)
// Alg:             L42, L43              L56
//
// Ev:             NewRound(1)             Proposal(+polka)
// State: NewRound --------------> Propose -------------------------> Prevote
// Msg:            propose(v, pol)         prevote(nil,round=1)
// Alg:            L16, L19                L28, L32 (not locked on v)
//
// v1=2, v2=2, v3=3, we are v2
// Trying to be at L36 with step precommit
// L21 - v2 is not proposer starts timeout propose (step propose)
// L59 - v2 receives timeout propose, prevotes nil (step prevote)
// L35 - v1 and v3 prevote some proposal(v), v2 gets +2/3 prevotes, starts timeout prevote (step prevote)
// L63 - v2 receives timeout prevote, prevotes nil (step precommit)
// L36 - v2 receives the proposal(v) from v1, sets valid = v (L42, L43) but does NOT lock (L37-L41 not executed) (step precommit)
// L56 - v2 receives a prevote(id(v), round=1) from v3, starts new round (step new_round)
//   Note - this doesn't seem correct v3 behaviour
// L16, L19 - v2 is the proposer and has a valid value from round 0, propose(round=1, value=v, valid_round=0) (step propose)
// L28 - v2 receives its proposal and has 2f+1 prevotes from round 0 and:
//   L29 - locked_round(-1) < valid_round(0) and valid_round(0) < round(1) BUT locked_value is nil
//     L32 - v2 sends prevote(nil, round=1) (step prevote)
#[test]
fn driver_steps_polka_previous_with_no_locked() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, sk2), (v3, _sk3)] = make_validators([2, 2, 3]);
    let (_my_sk, my_addr) = (sk2, v2.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v2, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout propose, prevote nil (v2)",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![prevote_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v3 prevotes some proposal",
            input: prevote_input(value.clone(), &v3.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes same proposal, we get +2/3 prevotes, start timeout prevote",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![start_prevote_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout prevote, prevote nil (v2)",
            input: timeout_prevote_input(Round::new(0)),
            expected_outputs: vec![precommit_nil_output(Round::new(0), &my_addr)],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive  a proposal - L36, we don't lock, we set valid",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v3.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_valid(
                Round::new(0),
                Round::new(0),
                Proposal::new(Height::new(1), Round::new(0), value.clone(), Round::Nil, v3.address),
            ),
        },
        TestStep {
            desc: "Receive f+1 vote for round 1 from v3",
            input: prevote_input_at(Round::new(1), value.clone(), &v3.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round_with_proposal_and_valid(
                Round::new(1),
                Proposal::new(Height::new(1), Round::new(0), value.clone(), Round::Nil, v3.address),
            ),
        },
        TestStep {
            desc: "start round 1, we are proposer with a valid value from round 0, propose it",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![proposal_output(
                Round::new(1),
                value.clone(),
                Round::new(0),
                v2.address,
            )],
            expected_round: Round::new(1),
            new_state: propose_state_with_proposal_and_valid(
                Round::new(1),
                Round::new(0),
                Proposal::new(Height::new(1), Round::new(0), value.clone(), Round::Nil, v2.address),
            ),
        },
        TestStep {
            desc: "Receive our own proposal, prevote value even if we are not locked on it (L29 with lockedRoundp == nil < vr)",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::new(0),
                Validity::Valid,
                v2.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(1), value.clone(), &my_addr)],
            expected_round: Round::new(1),
            new_state: prevote_state_with_proposal_and_valid(
                Round::new(1),
                Round::new(0),
                Proposal::new(Height::new(1), Round::new(0), value.clone(), Round::Nil, v2.address),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L44 with previously received polkaNil and entering prevote (due to timeoutPropose)
//
// Ev:             NewRound(0)          <polkaNil>         Timeout(propose)         + replay <polkaNil>
// State: NewRound ------------> Propose --------> Propose ---------------> Prevote -------------------> Precommit
// Msg:            propose_timer         None              prevote_nil              precommit_nil
// Alg:            L21                                     L34                      L44
//
//
// v1=2, v2=3, v3=2, we are v3
// L21 - v3 is not proposer starts propose timer (step propose)
// L34 - v3 gets +2/3 prevotes nil (from v1 and v2), event ignored (step propose)
// L57 - v3 receives timeout propose, prevotes nil (step prevote)
// L44 - polkaNil is replayed and v3 precommits nil (step precommit)
#[test]
fn driver_steps_polka_nil_and_timeout_propose() {
    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes nil",
            input: prevote_nil_input(&v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes nil, we get polkaNil, but we are in Propose step",
            input: prevote_nil_input(&v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout propose, prevote nil then, since we hit L44, precommit nil",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![
                prevote_nil_output(Round::new(0), &my_addr),
                precommit_nil_output(Round::new(0), &my_addr),
            ],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L36 with previoustly received polkaValue and proposal, and entering prevote (due to received proposal)
//
// Ev:             NewRound(0)           <polkaValue>         Proposal           + replay <polkaValue>
// State: NewRound ------------> Propose -----------> Propose ---------> Prevote --------------------> Precommit
// Msg:            propose_timer         None                 prevote(v)         precommit(v)
// Alg:            L21                                        L24                L37, L37-L43
//
//
// v1=2, v2=3, v3=2, we are v3
// L21 - v3 is not proposer starts propose timer (step propose)
// L34 - v3 gets +2/3 prevotes (from v1 and v2), events ignored (step propose)
// L57 - v3 receives proposal, prevotes value  (step prevote)
// L36 - polka is replayed and v3 precommits the value (step precommit)
#[test]
fn driver_steps_polka_value_then_proposal() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes a proposal",
            input: prevote_input(value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes same proposal, we get +2/3 prevotes, but we are in Propose step",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive a proposal from v1 - L22 send prevote",
            input: proposal_input(
                Round::new(0),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![
                prevote_output(Round::new(0), value.clone(), &my_addr),
                precommit_output(Round::new(0), value.clone(), &my_addr),
            ],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(0),
                Proposal::new(
                    Height::new(1),
                    Round::new(0),
                    value.clone(),
                    Round::Nil,
                    v1.address,
                ),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

// Arrive at L34 with previously received polkaAny and entering prevote (due to received proposal)
//
// Ev:             NewRound(0)           <polkaAny(v)>          Proposal(v')         + replay <polkaAny>
// State: NewRound ------------> Propose -------------> Propose -----------> Prevote -------------------------> Prevote
// Msg:            propose_timer         None                   prevote(v)           schedule_timeout(prevote)
// Alg:            L21                                          L24                  L34
//
//
// v1=2, v2=3, v3=2, we are v3
// L21 - v3 is not proposer starts propose timer (step propose)
// L34 - v3 gets +2/3 prevotes v (from v1 and v2), events ignored (step propose)
// L57 - v3 receives proposal v', prevotes v'  (step prevote)
// L34 - polka any is replayed and prevote timer is started (step prevote)
#[test]
fn driver_steps_polka_any_then_proposal_other() {
    let value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes nil",
            input: prevote_nil_input(&v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes same proposal, we get polkaAny, but we are in Propose step",
            input: prevote_input(value.clone(), &v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive a proposal from v1 - L22 send prevote, replay polkaAny, start timeout prevote",
            input: proposal_input(Round::new(0), value.clone(), Round::Nil, Validity::Valid, v1.address),
            expected_outputs: vec![
                prevote_output(Round::new(0),value.clone(), &my_addr),
                start_prevote_timer_output(Round::new(0))
            ],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn driver_equivocate_vote() {
    let value1 = Value::new(9999);
    let value2 = Value::new(42);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(0),
        value1.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive a proposal from v1, start timeout prevote",
            input: proposal_input(
                Round::new(0),
                value1.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(0), value1.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes proposal",
            input: prevote_input(value1.clone(), &v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes different value",
            input: prevote_input(value2, &v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes proposal, v3 precommits with proposal and locked and valid",
            input: prevote_input(value1.clone(), &v1.address),
            expected_outputs: vec![precommit_output(Round::new(0), value1.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_locked_and_valid(Round::new(0), proposal),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn driver_equivocate_proposal() {
    let value1 = Value::new(9999);
    let value2 = Value::new(42);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(0),
        value1.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal 1 from v1, start timeout prevote",
            input: proposal_input(
                Round::new(0),
                value1.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(0), value1.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal 2 from v1",
            input: proposal_input(
                Round::new(0),
                value2,
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes proposal",
            input: prevote_input(value1.clone(), &v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes proposal, v3 precommits with proposal and locked and valid",
            input: prevote_input(value1.clone(), &v1.address),
            expected_outputs: vec![precommit_output(Round::new(0), value1.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(0),
                proposal.clone(),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
#[should_panic(expected = "unreachable code: Conflicting proposals from different validators")]
fn driver_conflicting_proposal_unreachable() {
    let value1 = Value::new(9999);
    let value2 = Value::new(42);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal 1 from v1, start timeout prevote",
            input: proposal_input(
                Round::new(0),
                value1.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![prevote_output(Round::new(0), value1.clone(), &my_addr)],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal 2 from v2",
            input: proposal_input(
                Round::new(0),
                value2,
                Round::Nil,
                Validity::Valid,
                v2.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: prevote_state(Round::new(0)),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn driver_step_change_mux_with_proposal() {
    let value: Value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes nil",
            input: prevote_nil_input(&v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes nil, we get polkaNil, but we are in Propose step",
            input: prevote_nil_input(&v2.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout propose, prevote nil then precommit nil",
            input: timeout_propose_input(Round::new(0)),
            expected_outputs: vec![
                prevote_nil_output(Round::new(0), &my_addr),
                precommit_nil_output(Round::new(0), &my_addr),
            ],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 precommits nil",
            input: precommit_nil_input(Round::new(0), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 precommits nil, we get polkaNil, but we are in Propose step",
            input: precommit_nil_input(Round::new(0), &v2.address),
            expected_outputs: vec![start_precommit_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal for next round, store",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: precommit_state(Round::new(0)),
        },
        TestStep {
            desc: "Timeout precommit, start new round",
            input: timeout_precommit_input(Round::new(0)),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc:
                "Start round 1, change step to propose, start propose timer, mux proposal, prevote",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![
                start_propose_timer_output(Round::new(1)),
                prevote_output(Round::new(1), value.clone(), &my_addr),
            ],
            expected_round: Round::new(1),
            new_state: prevote_state(Round::new(1)),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn driver_step_change_mux_with_proposal_and_polka() {
    let value: Value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(1),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal for next round, store",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes value for round 1",
            input: prevote_input_at(Round::new(1), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes value for round 1, we hit the f+1 threshold, move to round 1",
            input: prevote_input_at(Round::new(1), value.clone(), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc:
                "Start round 1, change step to propose, start propose timer, mux proposal, prevote",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![
                start_propose_timer_output(Round::new(1)),
                prevote_output(Round::new(1), value.clone(), &my_addr),
                start_prevote_timer_output(Round::new(1)),
                precommit_output(Round::new(1), value.clone(), &my_addr),
            ],
            expected_round: Round::new(1),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                proposal.clone(),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn driver_step_change_mux_with_proposal_and_commit_quorum() {
    let value: Value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(1),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "Receive proposal for round 1, store",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 precommits value for round 1",
            input: precommit_input_at(Round::new(1), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 precommits value for round 1, we hit f+1 threshold, move to round 1",
            input: precommit_input_at(Round::new(1), value.clone(), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc:
                "Start round 1, change step to propose, start propose timer, mux proposal, decide",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![
                start_propose_timer_output(Round::new(1)),
                decide_output(Round::new(1), proposal),
            ],
            expected_round: Round::new(1),
            new_state: decided_state(Round::new(1), Round::new(1), value),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn proposal_mux_with_polka() {
    let value: Value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(1),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 prevotes value for round 1",
            input: prevote_input_at(Round::new(1), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v2 prevotes value for round 1, we hit the f+1 threshold, move to round 1",
            input: prevote_input_at(Round::new(1), value.clone(), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc: "Start round 1, change step to propose, start propose timer",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: propose_state(Round::new(1)),
        },
        TestStep {
            desc: "Receive proposal for next round, store",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![
                prevote_output(Round::new(1), value.clone(), &my_addr),
                precommit_output(Round::new(1), value.clone(), &my_addr),
            ],
            expected_round: Round::new(1),
            new_state: precommit_state_with_proposal_and_locked_and_valid(
                Round::new(1),
                proposal.clone(),
            ),
        },
    ];

    run_steps(&mut driver, steps);
}

#[test]
fn proposal_mux_with_commit_quorum() {
    let value: Value = Value::new(9999);

    let [(v1, _sk1), (v2, _sk2), (v3, sk3)] = make_validators([2, 3, 2]);
    let (_my_sk, my_addr) = (sk3.clone(), v3.address);

    let height = Height::new(1);
    let ctx = TestContext::new();
    let vs = ValidatorSet::new(vec![v1.clone(), v2.clone(), v3.clone()]);

    let proposal = Proposal::new(
        Height::new(1),
        Round::new(1),
        value.clone(),
        Round::Nil,
        v1.address,
    );

    let mut driver = Driver::new(ctx, height, vs, my_addr, Default::default());

    let steps = vec![
        TestStep {
            desc: "Start round 0, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(0), v1.address),
            expected_outputs: vec![start_propose_timer_output(Round::new(0))],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc: "v1 precommits value for round 1",
            input: precommit_input_at(Round::new(1), value.clone(), &v1.address),
            expected_outputs: vec![],
            expected_round: Round::new(0),
            new_state: propose_state(Round::new(0)),
        },
        TestStep {
            desc:
                "v2 precommits value for round 1, we hit f+1 threshold (also 2f+1), move to round 1",
            input: precommit_input_at(Round::new(1), value.clone(), &v2.address),
            expected_outputs: vec![new_round_output(Round::new(1))],
            expected_round: Round::new(1),
            new_state: new_round(Round::new(1)),
        },
        TestStep {
            desc: "Start round 1, we, v3, are not the proposer, start timeout propose",
            input: new_round_input(Round::new(1), v2.address),
            expected_outputs: vec![
                start_propose_timer_output(Round::new(1)),
                start_precommit_timer_output(Round::new(1)),
            ],
            expected_round: Round::new(1),
            new_state: propose_state(Round::new(1)),
        },
        TestStep {
            desc: "Receive proposal for round 1, store, mux, decide",
            input: proposal_input(
                Round::new(1),
                value.clone(),
                Round::Nil,
                Validity::Valid,
                v1.address,
            ),
            expected_outputs: vec![decide_output(Round::new(1), proposal)],
            expected_round: Round::new(1),
            new_state: decided_state(Round::new(1), Round::new(1), value),
        },
    ];

    run_steps(&mut driver, steps);
}

fn run_steps(driver: &mut Driver<TestContext>, steps: Vec<TestStep>) {
    for step in steps {
        println!("Step: {}", step.desc);

        let outputs = driver.process(step.input).expect("execute succeeded");

        assert_eq!(outputs, step.expected_outputs, "expected outputs");
        assert_eq!(driver.round(), step.expected_round, "expected round");
        assert_eq!(driver.round_state(), &step.new_state, "expected state");
    }
}

```
---
### `core-driver/tests/it/main.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod basic;
pub mod extra;

mod utils;

```
---
### `core-driver/tests/it/utils.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
#![allow(clippy::needless_update)]

use malachitebft_core_state_machine::state::{RoundValue, State, Step};
use malachitebft_core_types::{NilOrVal, Round, SignedProposal, SignedVote, Timeout, Validity};
use malachitebft_test::{Address, Height, Proposal, Signature, TestContext, Value, Vote};

use informalsystems_malachitebft_core_driver::{Input, Output};

pub fn new_round_input(round: Round, proposer: Address) -> Input<TestContext> {
    Input::NewRound(Height::new(1), round, proposer)
}

pub fn new_round_output(round: Round) -> Output<TestContext> {
    Output::NewRound(Height::new(1), round)
}

pub fn proposal_output(
    round: Round,
    value: Value,
    locked_round: Round,
    address: Address,
) -> Output<TestContext> {
    let proposal = Proposal::new(Height::new(1), round, value, locked_round, address);
    Output::Propose(proposal)
}

pub fn proposal_input(
    round: Round,
    value: Value,
    locked_round: Round,
    validity: Validity,
    address: Address,
) -> Input<TestContext> {
    let proposal = Proposal::new(Height::new(1), round, value, locked_round, address);
    Input::Proposal(SignedProposal::new(proposal, Signature::test()), validity)
}

pub fn prevote_output(round: Round, value: Value, addr: &Address) -> Output<TestContext> {
    Output::Vote(Vote::new_prevote(
        Height::new(1),
        round,
        NilOrVal::Val(value.id()),
        *addr,
    ))
}

pub fn prevote_nil_output(round: Round, addr: &Address) -> Output<TestContext> {
    Output::Vote(Vote::new_prevote(
        Height::new(1),
        round,
        NilOrVal::Nil,
        *addr,
    ))
}

pub fn prevote_input(value: Value, addr: &Address) -> Input<TestContext> {
    Input::Vote(SignedVote::new(
        Vote::new_prevote(
            Height::new(1),
            Round::new(0),
            NilOrVal::Val(value.id()),
            *addr,
        ),
        Signature::test(),
    ))
}

pub fn prevote_nil_input(addr: &Address) -> Input<TestContext> {
    Input::Vote(SignedVote::new(
        Vote::new_prevote(Height::new(1), Round::new(0), NilOrVal::Nil, *addr),
        Signature::test(),
    ))
}

pub fn prevote_input_at(round: Round, value: Value, addr: &Address) -> Input<TestContext> {
    Input::Vote(SignedVote::new(
        Vote::new_prevote(Height::new(1), round, NilOrVal::Val(value.id()), *addr),
        Signature::test(),
    ))
}

pub fn precommit_output(round: Round, value: Value, addr: &Address) -> Output<TestContext> {
    Output::Vote(Vote::new_precommit(
        Height::new(1),
        round,
        NilOrVal::Val(value.id()),
        *addr,
    ))
}

pub fn precommit_nil_output(round: Round, addr: &Address) -> Output<TestContext> {
    Output::Vote(Vote::new_precommit(
        Height::new(1),
        round,
        NilOrVal::Nil,
        *addr,
    ))
}

pub fn precommit_input(round: Round, value: Value, addr: &Address) -> Input<TestContext> {
    Input::Vote(SignedVote::new(
        Vote::new_precommit(Height::new(1), round, NilOrVal::Val(value.id()), *addr),
        Signature::test(),
    ))
}

pub fn precommit_nil_input(round: Round, addr: &Address) -> Input<TestContext> {
    Input::Vote(SignedVote::new(
        Vote::new_precommit(Height::new(1), round, NilOrVal::Nil, *addr),
        Signature::test(),
    ))
}

pub fn precommit_input_at(round: Round, value: Value, addr: &Address) -> Input<TestContext> {
    Input::Vote(SignedVote::new(
        Vote::new_precommit(Height::new(1), round, NilOrVal::Val(value.id()), *addr),
        Signature::test(),
    ))
}

pub fn decide_output(round: Round, proposal: Proposal) -> Output<TestContext> {
    Output::Decide(round, proposal)
}

pub fn start_propose_timer_output(round: Round) -> Output<TestContext> {
    Output::ScheduleTimeout(Timeout::propose(round))
}

pub fn timeout_propose_input(round: Round) -> Input<TestContext> {
    Input::TimeoutElapsed(Timeout::propose(round))
}

pub fn start_prevote_timer_output(round: Round) -> Output<TestContext> {
    Output::ScheduleTimeout(Timeout::prevote(round))
}

pub fn timeout_prevote_input(round: Round) -> Input<TestContext> {
    Input::TimeoutElapsed(Timeout::prevote(round))
}

pub fn start_precommit_timer_output(round: Round) -> Output<TestContext> {
    Output::ScheduleTimeout(Timeout::precommit(round))
}

pub fn timeout_precommit_input(round: Round) -> Input<TestContext> {
    Input::TimeoutElapsed(Timeout::precommit(round))
}

pub fn propose_state(round: Round) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Propose,
        ..Default::default()
    }
}

pub fn propose_state_with_proposal_and_valid(
    state_round: Round,
    valid_round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round: state_round,
        step: Step::Propose,
        valid: Some(RoundValue {
            value: proposal.value,
            round: valid_round,
        }),
        ..Default::default()
    }
}

pub fn propose_state_with_proposal_and_locked_and_valid(
    round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Propose,
        valid: Some(RoundValue {
            value: proposal.value.clone(),
            round: proposal.round,
        }),
        locked: Some(RoundValue {
            value: proposal.value,
            round: proposal.round,
        }),
        ..Default::default()
    }
}

pub fn prevote_state(round: Round) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Prevote,
        ..Default::default()
    }
}

pub fn prevote_state_with_proposal_and_valid(
    state_round: Round,
    valid_round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round: state_round,
        step: Step::Prevote,
        valid: Some(RoundValue {
            value: proposal.value,
            round: valid_round,
        }),
        ..Default::default()
    }
}

pub fn prevote_state_with_proposal_and_locked_and_valid(
    round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Prevote,
        valid: Some(RoundValue {
            value: proposal.value.clone(),
            round: Round::new(0),
        }),
        locked: Some(RoundValue {
            value: proposal.value,
            round: Round::new(0),
        }),
        ..Default::default()
    }
}

pub fn prevote_state_with_matching_proposal_and_locked_and_valid(
    round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Prevote,
        valid: Some(RoundValue {
            value: proposal.value.clone(),
            round: proposal.round,
        }),
        locked: Some(RoundValue {
            value: proposal.value,
            round: proposal.round,
        }),
        ..Default::default()
    }
}

pub fn precommit_state_with_proposal_and_locked_and_valid(
    round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Precommit,
        valid: Some(RoundValue {
            value: proposal.value.clone(),
            round: proposal.round,
        }),
        locked: Some(RoundValue {
            value: proposal.value,
            round: proposal.round,
        }),
        ..Default::default()
    }
}

pub fn precommit_state(round: Round) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Precommit,
        ..Default::default()
    }
}

pub fn precommit_state_with_proposal_and_valid(
    state_round: Round,
    valid_round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round: state_round,
        step: Step::Precommit,
        valid: Some(RoundValue {
            value: proposal.value,
            round: valid_round,
        }),
        ..Default::default()
    }
}

pub fn new_round(round: Round) -> State<TestContext> {
    State::new(Height::new(1), round)
}

pub fn new_round_with_proposal_and_valid(round: Round, proposal: Proposal) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Unstarted,
        valid: Some(RoundValue {
            value: proposal.value,
            round: Round::new(0),
        }),
        ..Default::default()
    }
}

pub fn new_round_with_proposal_and_locked_and_valid(
    round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Unstarted,
        valid: Some(RoundValue {
            value: proposal.value.clone(),
            round: proposal.round,
        }),
        locked: Some(RoundValue {
            value: proposal.value,
            round: proposal.round,
        }),
        ..Default::default()
    }
}

pub fn decided_state(
    consensus_round: Round,
    proposal_round: Round,
    value: Value,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round: consensus_round,
        step: Step::Commit,
        decision: Some(RoundValue {
            value: value.clone(),
            round: proposal_round,
        }),
        ..Default::default()
    }
}

pub fn decided_state_with_proposal_and_locked_and_valid(
    round: Round,
    proposal: Proposal,
) -> State<TestContext> {
    State {
        height: Height::new(1),
        round,
        step: Step::Commit,
        valid: Some(RoundValue {
            value: proposal.value.clone(),
            round: Round::new(0),
        }),
        locked: Some(RoundValue {
            value: proposal.value.clone(),
            round: Round::new(0),
        }),
        decision: Some(RoundValue {
            value: proposal.value.clone(),
            round: proposal.round,
        }),
        ..Default::default()
    }
}

```
---
### `core-state-machine/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-core-state-machine"
description = "Core state-machine for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
malachitebft-core-types = { workspace = true }

derive-where = { workspace = true }
displaydoc = { workspace = true }
time = { workspace = true, optional = true }

[features]
std = []
debug = ["std", "dep:time"]

```
---
### `core-state-machine/src/input.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! Inputs to the round state machine.

use derive_where::derive_where;

use malachitebft_core_types::{Context, Round};

/// Input to the round state machine.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Input<Ctx>
where
    Ctx: Context,
{
    /// No input
    NoInput,

    /// Start a new round, either as proposer or not.
    /// L14/L20
    NewRound(Round),

    /// Propose a value.
    /// L14
    ProposeValue(Ctx::Value),

    /// Receive a proposal.
    /// L22 + L23 (valid)
    Proposal(Ctx::Proposal),

    /// Receive an invalid proposal.
    /// L26 + L32 (invalid)
    InvalidProposal,

    /// Received a proposal and a polka value from a previous round.
    /// L28 + L29 (valid)
    ProposalAndPolkaPrevious(Ctx::Proposal),

    /// Received a proposal and a polka value from a previous round.
    /// L28 + L29 (invalid)
    InvalidProposalAndPolkaPrevious(Ctx::Proposal),

    /// Receive +2/3 prevotes for anything.
    /// L34
    PolkaAny,

    /// Receive +2/3 prevotes for nil.
    /// L44
    PolkaNil,

    /// Receive +2/3 prevotes for a value in current round.
    /// L36
    ProposalAndPolkaCurrent(Ctx::Proposal),

    /// Receive +2/3 precommits for anything.
    /// L47
    PrecommitAny,

    /// Receive +2/3 precommits for a value.
    /// L49
    ProposalAndPrecommitValue(Ctx::Proposal),

    /// Receive +1/3 messages from a higher round. OneCorrectProcessInHigherRound.
    /// L55
    SkipRound(Round),

    /// Timeout waiting for proposal.
    /// L57
    TimeoutPropose,

    /// Timeout waiting for prevotes.
    /// L61
    TimeoutPrevote,

    /// Timeout waiting for precommits.
    /// L65
    TimeoutPrecommit,
}

```
---
### `core-state-machine/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Per-round consensus state machine

#![forbid(unsafe_code)]
#![deny(trivial_casts, trivial_numeric_casts)]
#![warn(
    missing_docs,
    rustdoc::broken_intra_doc_links,
    rustdoc::private_intra_doc_links,
    variant_size_differences
)]
// no_std compatibility
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(test), deny(clippy::unwrap_used, clippy::panic))]

extern crate alloc;

pub mod input;
pub mod output;
pub mod state;
pub mod state_machine;
pub mod transition;

#[doc(hidden)]
pub mod traces;

```
---
### `core-state-machine/src/output.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
//! Outputs of the round state machine.

use derive_where::derive_where;

use malachitebft_core_types::{Context, NilOrVal, Round, Timeout, TimeoutKind, ValueId};

/// Output of the round state machine.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Output<Ctx>
where
    Ctx: Context,
{
    /// Move to the new round.
    NewRound(Round),

    /// Broadcast the proposal.
    Proposal(Ctx::Proposal),

    /// Broadcast the vote.
    Vote(Ctx::Vote),

    /// Schedule the timeout.
    ScheduleTimeout(Timeout),

    /// Ask for a value at the given height, round and to schedule a timeout.
    /// The timeout tells the proposal builder how long it has to build a value.
    GetValueAndScheduleTimeout(Ctx::Height, Round, Timeout),

    /// Decide the value.
    Decision(Round, Ctx::Proposal),
}

impl<Ctx: Context> Output<Ctx> {
    /// Build a `Proposal` output.
    pub fn proposal(
        ctx: &Ctx,
        height: Ctx::Height,
        round: Round,
        value: Ctx::Value,
        pol_round: Round,
        address: Ctx::Address,
    ) -> Self {
        Output::Proposal(ctx.new_proposal(height, round, value, pol_round, address))
    }

    /// Build a `Vote` output for a prevote.
    pub fn prevote(
        ctx: &Ctx,
        height: Ctx::Height,
        round: Round,
        value_id: NilOrVal<ValueId<Ctx>>,
        address: Ctx::Address,
    ) -> Self {
        Output::Vote(ctx.new_prevote(height, round, value_id, address))
    }

    /// Build a `Vote` output for a precommit.
    pub fn precommit(
        ctx: &Ctx,
        height: Ctx::Height,
        round: Round,
        value_id: NilOrVal<ValueId<Ctx>>,
        address: Ctx::Address,
    ) -> Self {
        Output::Vote(ctx.new_precommit(height, round, value_id, address))
    }

    /// Build a `ScheduleTimeout` output.
    pub fn schedule_timeout(round: Round, step: TimeoutKind) -> Self {
        Output::ScheduleTimeout(Timeout { round, kind: step })
    }

    /// Build a `GetValue` output.
    pub fn get_value_and_schedule_timeout(
        height: Ctx::Height,
        round: Round,
        step: TimeoutKind,
    ) -> Self {
        Output::GetValueAndScheduleTimeout(height, round, Timeout { round, kind: step })
    }

    /// Build a `Decision` output.
    pub fn decision(round: Round, proposal: Ctx::Proposal) -> Self {
        Output::Decision(round, proposal)
    }
}

```
---
### `core-state-machine/src/state.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
//! The state maintained by the round state machine

use derive_where::derive_where;

use crate::input::Input;
use crate::state_machine::Info;
use crate::transition::Transition;

#[cfg(feature = "debug")]
use crate::traces::*;

use malachitebft_core_types::{Context, Height, Round};

/// A value and its associated round
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct RoundValue<Value> {
    /// The value
    pub value: Value,
    /// The round
    pub round: Round,
}

impl<Value> RoundValue<Value> {
    /// Create a new `RoundValue` instance.
    pub fn new(value: Value, round: Round) -> Self {
        Self { value, round }
    }
}

/// The step of consensus in this round
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Step {
    /// The round has not started yet
    Unstarted,

    /// Propose step.
    /// Either we are the proposer or we are waiting for a proposal.
    Propose,

    /// We are at the prevote step.
    Prevote,

    /// We are at the precommit step.
    Precommit,

    /// We have committed and decided on a value
    Commit,
}

/// The state of the consensus state machine
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct State<Ctx>
where
    Ctx: Context,
{
    /// The height of the consensus
    pub height: Ctx::Height,

    /// The round we are at within a height
    pub round: Round,

    /// The step we are at within a round
    pub step: Step,

    /// The value we are locked on, ie. we have received a polka for before we precommitted
    pub locked: Option<RoundValue<Ctx::Value>>,

    /// The value for which we saw a polka
    pub valid: Option<RoundValue<Ctx::Value>>,

    /// The value we have decided on, None if no decision has been made yet.
    /// The decision round is the round of the proposal that we decided on.
    /// It may be different, lower or higher, than the state machine round.
    pub decision: Option<RoundValue<Ctx::Value>>,

    /// Buffer with traces of tendermint algorithm lines,
    #[cfg(feature = "debug")]
    #[derive_where(skip)]
    pub traces: alloc::vec::Vec<Trace<Ctx>>,
}

impl<Ctx> State<Ctx>
where
    Ctx: Context,
{
    /// Create a new `State` instance at the given height and round.
    pub fn new(height: Ctx::Height, round: Round) -> Self {
        Self {
            height,
            round,
            step: Step::Unstarted,
            locked: None,
            valid: None,
            decision: None,
            #[cfg(feature = "debug")]
            traces: alloc::vec::Vec::default(),
        }
    }

    /// Set the round.
    pub fn with_round(self, round: Round) -> Self {
        Self { round, ..self }
    }

    /// Set the step.
    pub fn with_step(self, step: Step) -> Self {
        Self { step, ..self }
    }

    /// Set the locked value.
    pub fn set_locked(self, value: Ctx::Value) -> Self {
        Self {
            locked: Some(RoundValue::new(value, self.round)),
            ..self
        }
    }

    /// Set the valid value.
    pub fn set_valid(self, value: Ctx::Value) -> Self {
        Self {
            valid: Some(RoundValue::new(value, self.round)),
            ..self
        }
    }

    /// Set the value we have decided on.
    pub fn set_decision(self, proposal_round: Round, value: Ctx::Value) -> Self {
        Self {
            decision: Some(RoundValue::new(value, proposal_round)),
            ..self
        }
    }

    /// Apply the given input to the current state, triggering a transition.
    pub fn apply(self, ctx: &Ctx, data: &Info<Ctx>, input: Input<Ctx>) -> Transition<Ctx> {
        crate::state_machine::apply(ctx, self, data, input)
    }

    /// Return the traces logged during execution.
    #[cfg(feature = "debug")]
    pub fn add_trace(&mut self, line: Line) {
        self.traces.push(Trace::new(self.height, self.round, line));
    }

    /// Return the traces logged during execution.
    #[cfg(feature = "debug")]
    pub fn get_traces(&self) -> &[Trace<Ctx>] {
        &self.traces
    }
}

impl<Ctx> Default for State<Ctx>
where
    Ctx: Context,
{
    fn default() -> Self {
        Self::new(Ctx::Height::ZERO, Round::Nil)
    }
}

```
---
### `core-state-machine/src/state_machine.rs`
*2025-05-18 23:58:49 | 17 KB*
```rust
//! The consensus state machine.

use malachitebft_core_types::{Context, NilOrVal, Proposal, Round, TimeoutKind, Value};

use crate::debug_trace;
use crate::input::Input;
use crate::output::Output;
use crate::state::{State, Step};
use crate::transition::Transition;

/// Immutable information about the input and our node:
/// - Address of our node
/// - Proposer for the round we are at
/// - Round for which the input is for, can be different than the round we are at
pub struct Info<'a, Ctx>
where
    Ctx: Context,
{
    /// The round for which the input is for, can be different than the round we are at
    pub input_round: Round,
    /// Address of our node
    pub address: &'a Ctx::Address,
    /// Proposer for the round we are at
    pub proposer: &'a Ctx::Address,
}

impl<'a, Ctx> Info<'a, Ctx>
where
    Ctx: Context,
{
    /// Create a new `Info` instance.
    pub fn new(input_round: Round, address: &'a Ctx::Address, proposer: &'a Ctx::Address) -> Self {
        Self {
            input_round,
            address,
            proposer,
        }
    }

    /// Create a new `Info` instance where we are the proposer.
    pub fn new_proposer(input_round: Round, address: &'a Ctx::Address) -> Self {
        Self {
            input_round,
            address,
            proposer: address,
        }
    }

    /// Check if we are the proposer for the round we are at.
    pub fn is_proposer(&self) -> bool {
        self.address == self.proposer
    }
}

/// Check that a proposal has a valid Proof-Of-Lock round
fn is_valid_pol_round<Ctx>(state: &State<Ctx>, pol_round: Round) -> bool
where
    Ctx: Context,
{
    pol_round.is_defined() && pol_round < state.round
}

/// Apply an input to the current state at the current round.
///
/// This function takes the current state and round, and an input,
/// and returns the next state and an optional message for the driver to act on.
///
/// Valid transitions result in at least a change to the state and/or an output.
///
/// Commented numbers refer to line numbers in the spec paper.
pub fn apply<Ctx>(
    ctx: &Ctx,
    mut state: State<Ctx>,
    info: &Info<Ctx>,
    input: Input<Ctx>,
) -> Transition<Ctx>
where
    Ctx: Context,
{
    let this_round = state.round == info.input_round;

    match (state.step, input) {
        //
        // From NewRound.
        //

        // L11/L14
        (Step::Unstarted, Input::NewRound(round)) if info.is_proposer() => {
            // Update the round
            state.round = round;

            debug_trace!(state, Line::L11Proposer);

            // We are the proposer
            propose_valid_or_get_value(ctx, state, info.address)
        }

        // L11/L20
        (Step::Unstarted, Input::NewRound(round)) => {
            // Update the round
            state.round = round;

            debug_trace!(state, Line::L11NonProposer);

            // We are not the proposer
            schedule_timeout_propose(state)
        }

        //
        // From Propose. Input must be for current round.
        //

        // L18
        (Step::Propose, Input::ProposeValue(value)) if this_round => {
            debug_assert!(info.is_proposer());

            propose(ctx, state, value, info.address)
        }

        // L22 with valid proposal
        (Step::Propose, Input::Proposal(proposal))
            if this_round && proposal.pol_round().is_nil() =>
        {
            debug_trace!(state, Line::L22);

            prevote(ctx, state, info.address, &proposal)
        }

        // L22 with invalid proposal
        (Step::Propose, Input::InvalidProposal) if this_round => {
            prevote_nil(ctx, state, info.address)
        }

        // L28 with valid proposal
        (Step::Propose, Input::ProposalAndPolkaPrevious(proposal))
            if this_round && is_valid_pol_round(&state, proposal.pol_round()) =>
        {
            debug_trace!(state, Line::L28ValidProposal);
            prevote_previous(ctx, state, info.address, &proposal)
        }

        // L28 with invalid proposal
        (Step::Propose, Input::InvalidProposalAndPolkaPrevious(proposal))
            if this_round && is_valid_pol_round(&state, proposal.pol_round()) =>
        {
            debug_trace!(state, Line::L28InvalidProposal);
            debug_trace!(state, Line::L32InvalidValue);

            prevote_nil(ctx, state, info.address)
        }

        // L57
        // We are the proposer.
        (Step::Propose, Input::TimeoutPropose) if this_round && info.is_proposer() => {
            debug_trace!(state, Line::L59Proposer);

            prevote_nil(ctx, state, info.address)
        }

        // L57
        // We are not the proposer.
        (Step::Propose, Input::TimeoutPropose) if this_round => {
            debug_trace!(state, Line::L59NonProposer);

            prevote_nil(ctx, state, info.address)
        }

        //
        // From Prevote. Input must be for current round.
        //

        // L34
        (Step::Prevote, Input::PolkaAny) if this_round => {
            debug_trace!(state, Line::L34);
            debug_trace!(state, Line::L35);

            schedule_timeout_prevote(state)
        }

        // L45
        (Step::Prevote, Input::PolkaNil) if this_round => {
            debug_trace!(state, Line::L45);

            precommit_nil(ctx, state, info.address)
        }

        // L36/L37
        // NOTE: Only executed the first time, as the votekeeper will only emit this threshold once.
        (Step::Prevote, Input::ProposalAndPolkaCurrent(proposal)) if this_round => {
            debug_trace!(state, Line::L36ValidProposal);

            precommit(ctx, state, info.address, proposal)
        }

        // L61
        (Step::Prevote, Input::TimeoutPrevote) if this_round => {
            debug_trace!(state, Line::L61);

            precommit_nil(ctx, state, info.address)
        }

        //
        // From Precommit
        //

        // L36/L42
        // NOTE: Only executed the first time, as the votekeeper will only emit this threshold once.
        (Step::Precommit, Input::ProposalAndPolkaCurrent(proposal)) if this_round => {
            debug_trace!(state, Line::L36ValidProposal);
            set_valid_value(state, &proposal)
        }

        //
        // From Commit. No more state transitions.
        //
        (Step::Commit, _) => Transition::invalid(state),

        //
        // From all (except Commit). Various round guards.
        //

        // L47
        (_, Input::PrecommitAny) if this_round => {
            debug_trace!(state, Line::L48);
            schedule_timeout_precommit(state)
        }

        // L65
        (_, Input::TimeoutPrecommit) if this_round => {
            debug_trace!(state, Line::L67);
            round_skip(state, info.input_round.increment())
        }

        // L55
        (_, Input::SkipRound(round)) if state.round < round => {
            debug_trace!(state, Line::L55);
            round_skip(state, round)
        }

        // L49
        (_, Input::ProposalAndPrecommitValue(proposal)) => {
            let round = state.round;
            debug_trace!(state, Line::L49);
            commit(state, round, proposal)
        }

        // Invalid transition.
        _ => Transition::invalid(state),
    }
}

//---------------------------------------------------------------------
// Propose
//---------------------------------------------------------------------

/// We are the proposer. Propose the valid value if present, otherwise schedule timeout propose
/// and ask for a value.
///
/// Ref: L13-L16, L19
pub fn propose_valid_or_get_value<Ctx>(
    ctx: &Ctx,
    mut state: State<Ctx>,
    address: &Ctx::Address,
) -> Transition<Ctx>
where
    Ctx: Context,
{
    debug_trace!(state, Line::L14);

    match &state.valid {
        Some(round_value) => {
            // L16
            let pol_round = round_value.round;
            let proposal = Output::proposal(
                ctx,
                state.height,
                state.round,
                round_value.value.clone(),
                pol_round,
                address.clone(),
            );
            debug_trace!(state, Line::L16);
            debug_trace!(state, Line::L19);

            Transition::to(state.with_step(Step::Propose)).with_output(proposal)
        }
        None => {
            // L18
            let output = Output::get_value_and_schedule_timeout(
                state.height,
                state.round,
                TimeoutKind::Propose,
            );
            debug_trace!(state, Line::L18);

            Transition::to(state.with_step(Step::Propose)).with_output(output)
        }
    }
}

/// We are the proposer; propose the valid value if it exists,
/// otherwise propose the given value.
///
/// Ref: L13, L17-18
pub fn propose<Ctx>(
    ctx: &Ctx,
    mut state: State<Ctx>,
    value: Ctx::Value,
    address: &Ctx::Address,
) -> Transition<Ctx>
where
    Ctx: Context,
{
    let proposal = Output::proposal(
        ctx,
        state.height,
        state.round,
        value,
        Round::Nil,
        address.clone(),
    );

    debug_trace!(state, Line::L19);
    Transition::to(state.with_step(Step::Propose)).with_output(proposal)
}

//---------------------------------------------------------------------
// Prevote
//---------------------------------------------------------------------

/// Received a complete proposal; prevote the value,
/// unless we are locked on something else.
///
/// Ref: L22 with valid proposal
pub fn prevote<Ctx>(
    ctx: &Ctx,
    mut state: State<Ctx>,
    address: &Ctx::Address,
    proposal: &Ctx::Proposal,
) -> Transition<Ctx>
where
    Ctx: Context,
{
    let vr = proposal.pol_round();
    assert_eq!(vr, Round::Nil);
    let proposed = proposal.value().id();
    let value = match &state.locked {
        Some(locked) if locked.value.id() == proposed => {
            // already locked on value
            debug_trace!(state, Line::L24ValidAndLockedValue);
            NilOrVal::Val(proposed)
        }
        Some(_) => {
            // locked on a different value
            debug_trace!(state, Line::L26ValidAndLockedValue);
            NilOrVal::Nil
        }
        None => {
            // not locked, prevote the value
            debug_trace!(state, Line::L24ValidNoLockedRound);
            NilOrVal::Val(proposed)
        }
    };

    let output = Output::prevote(ctx, state.height, state.round, value, address.clone());
    Transition::to(state.with_step(Step::Prevote)).with_output(output)
}

/// Received a proposal for a previously seen value and a polka from a previous round; prevote the value,
/// unless we are locked on a different value at a higher round.
///
/// Ref: L28
pub fn prevote_previous<Ctx>(
    ctx: &Ctx,
    mut state: State<Ctx>,
    address: &Ctx::Address,
    proposal: &Ctx::Proposal,
) -> Transition<Ctx>
where
    Ctx: Context,
{
    let vr = proposal.pol_round();
    assert!(vr >= Round::Some(0));
    assert!(vr < proposal.round());

    let proposed = proposal.value().id();
    let value = match &state.locked {
        Some(locked) if locked.round <= vr => {
            // locked on lower or equal round, maybe on different value
            debug_trace!(state, Line::L30ValidLockedRound);
            NilOrVal::Val(proposed)
        }
        Some(locked) if locked.value.id() == proposed => {
            // already locked same value
            debug_trace!(state, Line::L30ValidLockedValue);
            NilOrVal::Val(proposed)
        }
        Some(_) => {
            // we're locked on a different value in a higher round, prevote nil
            debug_trace!(state, Line::L32InvalidValue);
            NilOrVal::Nil
        }
        None => {
            // not locked, prevote the value
            debug_trace!(state, Line::L30ValidNoLockedRound);
            NilOrVal::Val(proposed)
        }
    };

    let output = Output::Vote(ctx.new_prevote(state.height, state.round, value, address.clone()));
    Transition::to(state.with_step(Step::Prevote)).with_output(output)
}

/// Received a complete proposal for an empty or invalid value, or timed out; prevote nil.
///
/// Ref: L22/L25, L28/L31, L57
pub fn prevote_nil<Ctx>(ctx: &Ctx, state: State<Ctx>, address: &Ctx::Address) -> Transition<Ctx>
where
    Ctx: Context,
{
    let output =
        Output::Vote(ctx.new_prevote(state.height, state.round, NilOrVal::Nil, address.clone()));

    Transition::to(state.with_step(Step::Prevote)).with_output(output)
}

// ---------------------------------------------------------------------
// Precommit
// ---------------------------------------------------------------------

/// Received a polka for a value; precommit the value.
///
/// Ref: L36
///
/// NOTE: Only one of this and set_valid_value should be called once in a round
///       How do we enforce this?
pub fn precommit<Ctx>(
    ctx: &Ctx,
    state: State<Ctx>,
    address: &Ctx::Address,
    proposal: Ctx::Proposal,
) -> Transition<Ctx>
where
    Ctx: Context,
{
    if state.step != Step::Prevote {
        return Transition::to(state);
    }

    let value = proposal.value();
    let output = Output::precommit(
        ctx,
        state.height,
        state.round,
        NilOrVal::Val(value.id()),
        address.clone(),
    );

    let next = state
        .set_locked(value.clone())
        .set_valid(value.clone())
        .with_step(Step::Precommit);

    Transition::to(next).with_output(output)
}

/// Received a polka for nil or timed out of prevote; precommit nil.
///
/// Ref: L44, L61
pub fn precommit_nil<Ctx>(ctx: &Ctx, state: State<Ctx>, address: &Ctx::Address) -> Transition<Ctx>
where
    Ctx: Context,
{
    let output =
        Output::Vote(ctx.new_precommit(state.height, state.round, NilOrVal::Nil, address.clone()));

    Transition::to(state.with_step(Step::Precommit)).with_output(output)
}

// ---------------------------------------------------------------------
// Schedule timeouts
// ---------------------------------------------------------------------

/// We're not the proposer; schedule timeout propose.
///
/// Ref: L11, L20
pub fn schedule_timeout_propose<Ctx>(mut state: State<Ctx>) -> Transition<Ctx>
where
    Ctx: Context,
{
    debug_trace!(state, Line::L21ProposeTimeoutScheduled);

    let timeout = Output::schedule_timeout(state.round, TimeoutKind::Propose);
    Transition::to(state.with_step(Step::Propose)).with_output(timeout)
}

/// We received a polka for any; schedule timeout prevote.
///
/// Ref: L34
///
/// NOTE: This should only be called once in a round, per the spec,
///       but it's harmless to schedule more timeouts
pub fn schedule_timeout_prevote<Ctx>(state: State<Ctx>) -> Transition<Ctx>
where
    Ctx: Context,
{
    let output = Output::schedule_timeout(state.round, TimeoutKind::Prevote);
    Transition::to(state).with_output(output)
}

/// We received +2/3 precommits for any; schedule timeout precommit.
///
/// Ref: L47
pub fn schedule_timeout_precommit<Ctx>(state: State<Ctx>) -> Transition<Ctx>
where
    Ctx: Context,
{
    let output = Output::schedule_timeout(state.round, TimeoutKind::Precommit);
    Transition::to(state).with_output(output)
}

//---------------------------------------------------------------------
// Set the valid value.
//---------------------------------------------------------------------

/// We received a polka for a value after we already precommitted.
/// Set the valid value and current round.
///
/// Ref: L36/L42
///
/// NOTE: only one of this and precommit should be called once in a round
pub fn set_valid_value<Ctx>(state: State<Ctx>, proposal: &Ctx::Proposal) -> Transition<Ctx>
where
    Ctx: Context,
{
    Transition::to(state.set_valid(proposal.value().clone()))
}

//---------------------------------------------------------------------
// New round or height
//---------------------------------------------------------------------

/// We finished a round (timeout precommit) or received +1/3 votes
/// from a higher round. Move to the higher round.
///
/// Ref: L65
pub fn round_skip<Ctx>(state: State<Ctx>, round: Round) -> Transition<Ctx>
where
    Ctx: Context,
{
    let new_state = state.with_round(round).with_step(Step::Unstarted);
    Transition::to(new_state).with_output(Output::NewRound(round))
}

/// We received +2/3 precommits for a value - commit and decide that value!
///
/// Ref: L49
pub fn commit<Ctx>(state: State<Ctx>, round: Round, proposal: Ctx::Proposal) -> Transition<Ctx>
where
    Ctx: Context,
{
    match &state.decision {
        // We already decided the same value
        Some(decision) if decision.value.id() == proposal.value().id() => Transition::to(state),
        // We decided a different value
        Some(_) => Transition::invalid(state),
        // First time we see a decision
        None => {
            let new_state = state
                .set_decision(proposal.round(), proposal.value().clone())
                .with_step(Step::Commit);
            let output = Output::decision(round, proposal.clone());
            Transition::to(new_state).with_output(output)
        }
    }
}

```
---
### `core-state-machine/src/traces/line.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use displaydoc::Display;

#[allow(dead_code)]
#[derive(Clone, Debug, Eq, PartialEq, Display)]
pub enum Line {
    /// L11 - proposer
    L11Proposer,

    /// L11 - non-proposer: schedule proposeTimeout
    L11NonProposer,

    /// L14 - check if proposer
    L14,

    /// L16 - validValue
    L16,

    /// L18 - getValue()
    L18,

    /// L19 - proposal
    L19,

    /// L21 - proposeTimeout scheduled
    L21ProposeTimeoutScheduled,

    /// L22 - proposal in propose step: prevote
    L22,

    /// L24 - prevote v: valid(v) and lockedValue = v
    L24ValidAndLockedValue,

    /// L24 - prevote v: valid(v) and lockedRound == -1
    L24ValidNoLockedRound,

    /// L26 - prevote nil: valid(v) and lockedValue != v
    L26ValidAndLockedValue,

    /// L28 - valid proposal
    L28ValidProposal,

    /// L28 - invalid proposal
    L28InvalidProposal,

    /// L30 - prevote v: valid(v) and 0 <= lockedRound <= vr
    L30ValidLockedRound,

    /// L30 - prevote v: valid(v) and lockedValue = v
    L30ValidLockedValue,

    /// L30 - prevote v: valid(v) and lockedRound == -1
    L30ValidNoLockedRound,

    /// L32 - prevote nil: valid(v) and lockedRound > vr and lockedValue != v
    L32ValidLockedRound,

    /// L32 - invalid value
    L32InvalidValue,

    /// L34 - polka any: schedule prevoteTimeout
    L34,

    /// L35 - prevoteTimeout scheduled
    L35,

    /// L36 - valid v and step == prevote: set locked, valid
    L36ValidProposal,

    /// L45 - polka nil: precommit nil
    L45,

    /// L48 - precommit any: schedule precommitTimeout
    L48,

    /// L49 - valid v and precommit quorum: commit
    L49,

    /// L55 - f+1 for higher round: move to that round
    L55,

    /// L59 - proposer, proposeTimeout expired: prevote nil
    L59Proposer,

    /// L59 - non proposer, proposeTimeout expired: prevote nil
    L59NonProposer,

    /// L61 - prevoteTimeout expired: precommit nil
    L61,

    /// L67 - precommitTimeout expired: move to next round
    L67,
}

```
---
### `core-state-machine/src/traces/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
mod line;

#[allow(unused_imports)]
pub use line::Line;

#[cfg(feature = "debug")]
mod trace;

#[cfg(feature = "debug")]
pub use trace::Trace;

#[doc(hidden)]
#[macro_export]
macro_rules! debug_trace {
    ($state:expr, $line:expr) => {
        #[cfg(feature = "debug")]
        {
            #[allow(unused_imports)]
            use $crate::traces::Line;

            $state.add_trace($line);
        }
        #[cfg(not(feature = "debug"))]
        {
            let _ = &mut $state;
        }
    };
}

```
---
### `core-state-machine/src/traces/trace.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use derive_where::derive_where;
use displaydoc::Display;
use time::OffsetDateTime;

use malachitebft_core_types::{Context, Round};

use super::Line;

#[derive_where(Clone, Debug, Eq, PartialEq)]
#[derive(Display)]
#[displaydoc("[{time}] height: {height}, round: {round}, line: {line}")]
pub struct Trace<Ctx: Context> {
    pub time: OffsetDateTime,
    pub height: Ctx::Height,
    pub round: Round,
    pub line: Line,
}

impl<Ctx: Context> Trace<Ctx> {
    pub fn new(height: Ctx::Height, round: Round, line: Line) -> Self {
        Self {
            time: OffsetDateTime::now_utc(),
            height,
            round,
            line,
        }
    }
}

```
---
### `core-state-machine/src/transition.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! A transition taken by the state machine after processing an input.

use malachitebft_core_types::Context;

use crate::output::Output;
use crate::state::State;

/// A transition taken by the state machine after processing an input.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Transition<Ctx>
where
    Ctx: Context,
{
    /// The next state to transition to.
    pub next_state: State<Ctx>,
    /// The output to emit.
    pub output: Option<Output<Ctx>>,
    /// Whether the transition is valid or not.
    pub valid: bool,
}

impl<Ctx> Transition<Ctx>
where
    Ctx: Context,
{
    /// Build a new valid transition to the given next state.
    pub fn to(next_state: State<Ctx>) -> Self {
        Self {
            next_state,
            output: None,
            valid: true,
        }
    }

    /// Build a new invalid transition to the given next state.
    pub fn invalid(next_state: State<Ctx>) -> Self {
        Self {
            next_state,
            output: None,
            valid: false,
        }
    }

    /// Set the output of the transition.
    pub fn with_output(mut self, output: Output<Ctx>) -> Self {
        self.output = Some(output);
        self
    }
}

```
---
### `core-types/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-core-types"
description = "Core type definitions and interfaces for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[lints]
workspace = true

[dependencies]
bytes = { workspace = true, default-features = false }
derive-where = { workspace = true }
thiserror = { workspace = true, default-features = false }

```
---
### `core-types/src/certificate.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use alloc::vec::Vec;
use derive_where::derive_where;
use thiserror::Error;

use crate::{
    Context, NilOrVal, Round, Signature, SignedVote, ValueId, Vote, VoteType, VotingPower,
};

/// Represents a signature for a commit certificate, with the address of the validator that produced it.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct CommitSignature<Ctx: Context> {
    /// The address associated with the signature.
    pub address: Ctx::Address,
    /// The signature itself.
    pub signature: Signature<Ctx>,
}

impl<Ctx: Context> CommitSignature<Ctx> {
    /// Create a new `CommitSignature` from an address and a signature.
    pub fn new(address: Ctx::Address, signature: Signature<Ctx>) -> Self {
        Self { address, signature }
    }
}

/// Represents a certificate containing the message (height, round, value_id) and the commit signatures.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct CommitCertificate<Ctx: Context> {
    /// The height of the certificate.
    pub height: Ctx::Height,
    /// The round number associated with the certificate.
    pub round: Round,
    /// The identifier for the value being certified.
    pub value_id: ValueId<Ctx>,
    /// A vector of signatures that make up the certificate.
    pub commit_signatures: Vec<CommitSignature<Ctx>>,
}

impl<Ctx: Context> CommitCertificate<Ctx> {
    /// Creates a new `CommitCertificate` from a vector of signed votes.
    pub fn new(
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        commits: Vec<SignedVote<Ctx>>,
    ) -> Self {
        // Collect all commit signatures from the signed votes
        let commit_signatures = commits
            .into_iter()
            .filter(|vote| {
                matches!(vote.value(), NilOrVal::Val(id) if id == &value_id)
                    && vote.vote_type() == VoteType::Precommit
                    && vote.round() == round
                    && vote.height() == height
            })
            .map(|signed_vote| {
                CommitSignature::new(
                    signed_vote.validator_address().clone(),
                    signed_vote.signature,
                )
            })
            .collect();

        Self {
            height,
            round,
            value_id,
            commit_signatures,
        }
    }
}

/// Represents a signature for a polka certificate, with the address of the validator that produced it.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct PolkaSignature<Ctx: Context> {
    /// The address associated with the signature.
    pub address: Ctx::Address,
    /// The signature itself.
    pub signature: Signature<Ctx>,
}

impl<Ctx: Context> PolkaSignature<Ctx> {
    /// Create a new `CommitSignature` from an address and a signature.
    pub fn new(address: Ctx::Address, signature: Signature<Ctx>) -> Self {
        Self { address, signature }
    }
}

/// Represents a certificate witnessing a Polka at a given height and round.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct PolkaCertificate<Ctx: Context> {
    /// The height at which a Polka was witnessed
    pub height: Ctx::Height,
    /// The round at which a Polka that was witnessed
    pub round: Round,
    /// The value that the Polka is for
    pub value_id: ValueId<Ctx>,
    /// The signatures for the votes that make up the Polka
    pub polka_signatures: Vec<PolkaSignature<Ctx>>,
}

impl<Ctx: Context> PolkaCertificate<Ctx> {
    /// Creates a new `PolkaCertificate` from signed prevotes.
    pub fn new(
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        votes: Vec<SignedVote<Ctx>>,
    ) -> Self {
        // Collect all polka signatures from the signed votes
        let polka_signatures = votes
            .into_iter()
            .filter(|vote| {
                matches!(vote.value(), NilOrVal::Val(id) if id == &value_id)
                    && vote.vote_type() == VoteType::Prevote
                    && vote.round() == round
                    && vote.height() == height
            })
            .map(|signed_vote| {
                PolkaSignature::new(
                    signed_vote.validator_address().clone(),
                    signed_vote.signature,
                )
            })
            .collect();

        Self {
            height,
            round,
            value_id,
            polka_signatures,
        }
    }
}

/// Represents an error that can occur when verifying a certificate.
#[derive(Error)]
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum CertificateError<Ctx: Context> {
    /// One of the commit signature is invalid.
    #[error("Invalid commit signature: {0:?}")]
    InvalidCommitSignature(CommitSignature<Ctx>),

    /// One of the commit signature is invalid.
    #[error("Invalid polka signature: {0:?}")]
    InvalidPolkaSignature(PolkaSignature<Ctx>),

    /// A validator in the certificate is not in the validator set.
    #[error("A validator in the certificate is not in the validator set: {0:?}")]
    UnknownValidator(Ctx::Address),

    /// Not enough voting power has signed the certificate.
    #[error(
        "Not enough voting power has signed the certificate: \
         signed={signed}, total={total}, expected={expected}"
    )]
    NotEnoughVotingPower {
        /// Signed voting power
        signed: VotingPower,
        /// Total voting power
        total: VotingPower,
        /// Expected voting power
        expected: VotingPower,
    },

    /// Multiple votes from the same validator.
    #[error("Multiple votes from the same validator: {0}")]
    DuplicateVote(Ctx::Address),
}

/// Represents a signature for a round certificate, with the address of the validator that produced it.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct RoundSignature<Ctx: Context> {
    /// The vote type
    pub vote_type: VoteType,
    /// The value id
    pub value_id: NilOrVal<ValueId<Ctx>>,
    /// The address associated with the signature.
    pub address: Ctx::Address,
    /// The signature itself.
    pub signature: Signature<Ctx>,
}

impl<Ctx: Context> RoundSignature<Ctx> {
    /// Create a new `CommitSignature` from an address and a signature.
    pub fn new(
        vote_type: VoteType,
        value_id: NilOrVal<ValueId<Ctx>>,
        address: Ctx::Address,
        signature: Signature<Ctx>,
    ) -> Self {
        Self {
            vote_type,
            value_id,
            address,
            signature,
        }
    }
}

/// Represents a certificate for entering a new round at a given height.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct RoundCertificate<Ctx: Context> {
    /// The height at which a certificate was witnessed
    pub height: Ctx::Height,
    /// The round of the votes that made up the certificate
    pub round: Round,
    /// The signatures for the votes that make up the certificate
    pub round_signatures: Vec<RoundSignature<Ctx>>,
}

impl<Ctx: Context> RoundCertificate<Ctx> {
    /// Creates a new `RoundCertificate` from a vector of signed votes.
    pub fn new_from_votes(height: Ctx::Height, round: Round, votes: Vec<SignedVote<Ctx>>) -> Self {
        RoundCertificate {
            height,
            round,
            round_signatures: votes
                .into_iter()
                .map(|v| {
                    RoundSignature::new(
                        v.vote_type(),
                        v.value().clone(),
                        v.validator_address().clone(),
                        v.signature,
                    )
                })
                .collect(),
        }
    }
}

/// Represents a local certificate that triggered or will trigger the start of a new round.
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct EnterRoundCertificate<Ctx: Context> {
    /// The certificate that triggered or will trigger the start of a new round
    pub certificate: RoundCertificate<Ctx>,
    /// The round that will be entered due to the `RoundCertificate`.
    /// - If the certificate is `PrecommitAny`, it contains signatures from the previous round,
    ///   so `enter_round` will be one more than the round of those signatures.
    /// - If the certificate is `SkipRound`, it contains signatures from the round being entered,
    ///   so `enter_round` will be equal to the round of those signatures.
    pub enter_round: Round,
}

impl<Ctx: Context> EnterRoundCertificate<Ctx> {
    /// Creates a new `LocalRoundCertificate` from a vector of signed votes.
    pub fn new_from_votes(
        height: Ctx::Height,
        enter_round: Round,
        round: Round,
        votes: Vec<SignedVote<Ctx>>,
    ) -> Self {
        Self {
            certificate: RoundCertificate::new_from_votes(height, round, votes),
            enter_round,
        }
    }
}

```
---
### `core-types/src/context.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use crate::{
    Address, Extension, Height, NilOrVal, Proposal, ProposalPart, Round, SigningScheme, Validator,
    ValidatorSet, Value, ValueId, Vote,
};

/// This trait allows to abstract over the various datatypes
/// that are used in the consensus engine.
pub trait Context
where
    Self: Sized + Clone + Send + Sync + 'static,
{
    /// The type of address of a validator.
    type Address: Address;

    /// The type of the height of a block.
    type Height: Height;

    /// The type of proposal part
    type ProposalPart: ProposalPart<Self>;

    /// The interface provided by the proposal type.
    type Proposal: Proposal<Self>;

    /// The interface provided by the validator type.
    type Validator: Validator<Self>;

    /// The interface provided by the validator set type.
    type ValidatorSet: ValidatorSet<Self>;

    /// The `Value` type denotes the value `v` carried by the `Proposal`
    /// consensus message that is gossiped to other nodes by the proposer.
    type Value: Value;

    /// The type of votes that can be cast.
    type Vote: Vote<Self>;

    /// The type of vote extensions.
    type Extension: Extension;

    /// The signing scheme used to sign consensus messages.
    type SigningScheme: SigningScheme;

    /// Select a proposer in the validator set for the given height and round.
    fn select_proposer<'a>(
        &self,
        validator_set: &'a Self::ValidatorSet,
        height: Self::Height,
        round: Round,
    ) -> &'a Self::Validator;

    /// Build a new proposal for the given value at the given height, round and POL round.
    fn new_proposal(
        &self,
        height: Self::Height,
        round: Round,
        value: Self::Value,
        pol_round: Round,
        address: Self::Address,
    ) -> Self::Proposal;

    /// Build a new prevote vote by the validator with the given address,
    /// for the value identified by the given value id, at the given round.
    fn new_prevote(
        &self,
        height: Self::Height,
        round: Round,
        value_id: NilOrVal<ValueId<Self>>,
        address: Self::Address,
    ) -> Self::Vote;

    /// Build a new precommit vote by the validator with the given address,
    /// for the value identified by the given value id, at the given round.
    fn new_precommit(
        &self,
        height: Self::Height,
        round: Round,
        value_id: NilOrVal<ValueId<Self>>,
        address: Self::Address,
    ) -> Self::Vote;
}

```
---
### `core-types/src/height.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt::{Debug, Display};

/// Defines the requirements for a height type.
///
/// A height denotes the number of blocks (values) created since the chain began.
///
/// A height of 0 represents a chain which has not yet produced a block.
pub trait Height
where
    Self: Copy + Clone + Default + Debug + Display + Eq + Ord + Send + Sync,
{
    /// The zero-th height. Typically 0.
    ///
    /// This value must be the same as the one built by the `Default` impl.
    const ZERO: Self;

    /// The initial height. Typically 1.
    const INITIAL: Self;

    /// Increment the height by one.
    fn increment(&self) -> Self {
        self.increment_by(1)
    }

    /// Decrement the height by one.
    fn decrement(&self) -> Option<Self> {
        self.decrement_by(1)
    }

    /// Increment this height by the given amount.
    fn increment_by(&self, n: u64) -> Self;

    /// Decrement this height by the given amount.
    /// Returns None if the height would be decremented below its minimum.
    fn decrement_by(&self, n: u64) -> Option<Self>;

    /// Convert the height to a `u64`.
    fn as_u64(&self) -> u64;
}

```
---
### `core-types/src/lib.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
//! Common data types and abstractions for the consensus engine.

#![no_std]
#![forbid(unsafe_code)]
#![deny(trivial_casts, trivial_numeric_casts)]
#![warn(
    missing_docs,
    rustdoc::broken_intra_doc_links,
    rustdoc::private_intra_doc_links,
    variant_size_differences
)]
#![cfg_attr(not(test), deny(clippy::unwrap_used, clippy::panic))]

extern crate alloc;

mod certificate;
mod context;
mod height;
mod proposal;
mod proposal_part;
mod round;
mod signed_message;
mod signing;
mod threshold;
mod timeout;
mod validator_set;
mod value;
mod vote;
mod vote_extension;

/// Type alias to make it easier to refer the `ValueId` type.
pub type ValueId<Ctx> = <<Ctx as Context>::Value as Value>::Id;

/// Type alias to make it easier to refer the `PublicKey` type.
pub type PublicKey<Ctx> = <<Ctx as Context>::SigningScheme as SigningScheme>::PublicKey;

/// Type alias to make it easier to refer the `PrivateKey` type.
pub type PrivateKey<Ctx> = <<Ctx as Context>::SigningScheme as SigningScheme>::PrivateKey;

/// Type alias to make it easier to refer the `Signature` type.
pub type Signature<Ctx> = <<Ctx as Context>::SigningScheme as SigningScheme>::Signature;

/// A signed vote
pub type SignedVote<Ctx> = SignedMessage<Ctx, <Ctx as Context>::Vote>;

/// A signed proposal
pub type SignedProposal<Ctx> = SignedMessage<Ctx, <Ctx as Context>::Proposal>;

/// A signed proposal part
pub type SignedProposalPart<Ctx> = SignedMessage<Ctx, <Ctx as Context>::ProposalPart>;

/// A signed vote extension
pub type SignedExtension<Ctx> = SignedMessage<Ctx, <Ctx as Context>::Extension>;

pub use certificate::{
    CertificateError, CommitCertificate, CommitSignature, EnterRoundCertificate, PolkaCertificate,
    PolkaSignature, RoundCertificate, RoundSignature,
};
pub use context::Context;
pub use height::Height;
pub use proposal::{Proposal, Validity};
pub use proposal_part::ProposalPart;
pub use round::Round;
pub use signed_message::SignedMessage;
pub use signing::{SigningProvider, SigningProviderExt, SigningScheme};
pub use threshold::{Threshold, ThresholdParam, ThresholdParams};
pub use timeout::{Timeout, TimeoutKind};
pub use validator_set::{Address, Validator, ValidatorSet, VotingPower};
pub use value::{NilOrVal, Value, ValueOrigin, ValuePayload};
pub use vote::{Vote, VoteType};
pub use vote_extension::{Extension, VoteExtensions};

```
---
### `core-types/src/proposal.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt::Debug;

use crate::{Context, Round};

/// Defines the requirements for a proposal type.
pub trait Proposal<Ctx>
where
    Self: Clone + Debug + Eq + Send + Sync + 'static,
    Ctx: Context,
{
    /// The height for which the proposal is for.
    fn height(&self) -> Ctx::Height;

    /// The round for which the proposal is for.
    fn round(&self) -> Round;

    /// The value that is proposed.
    fn value(&self) -> &Ctx::Value;

    /// The value that is proposed.
    fn take_value(self) -> Ctx::Value;

    /// The POL round for which the proposal is for.
    fn pol_round(&self) -> Round;

    /// Address of the validator who issued this proposal
    fn validator_address(&self) -> &Ctx::Address;
}

/// Whether or not a proposal is valid.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Validity {
    /// The proposal is valid.
    Valid,
    /// The proposal is invalid.
    Invalid,
}

impl Validity {
    /// Returns `true` if the proposal is valid.
    pub fn is_valid(self) -> bool {
        self == Validity::Valid
    }

    /// Converts the validity to a boolean:
    /// `true` if the proposal is valid, `false` otherwise.
    pub fn to_bool(self) -> bool {
        self.is_valid()
    }

    /// Returns `Valid` if given true, `Invalid` if given false.
    pub fn from_bool(valid: bool) -> Self {
        if valid {
            Validity::Valid
        } else {
            Validity::Invalid
        }
    }
}

```
---
### `core-types/src/proposal_part.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use core::fmt::Debug;

use crate::Context;

/// Defines the requirements for a proposal part type.
pub trait ProposalPart<Ctx>
where
    Self: Clone + Debug + Eq + Send + Sync + 'static,
    Ctx: Context,
{
    /// Is this the first proposal part?
    fn is_first(&self) -> bool;

    /// Is this the last proposal part?
    fn is_last(&self) -> bool;
}

```
---
### `core-types/src/round.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use core::{cmp, fmt};

/// A round number.
///
/// Can be either:
/// - `Round::Nil` (ie. `-1`)
/// - `Round::Some(r)` where `r >= 0`
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Round {
    /// No round, ie. `-1`
    Nil,

    /// Some round `r` where `r >= 0`
    Some(u32),
}

impl Round {
    /// The zero-th or initial round.
    pub const ZERO: Self = Self::Some(0);

    /// Create a new non-nil round.
    pub const fn new(round: u32) -> Self {
        Self::Some(round)
    }

    /// Convert a round to a `Option<u32>`.
    ///
    /// `Round::Nil` is converted to `None`.
    /// `Round::Some(r)` is converted to `Some(r)`.
    pub fn as_u32(&self) -> Option<u32> {
        match self {
            Round::Nil => None,
            Round::Some(r) => Some(*r),
        }
    }

    /// Convert the round to an `i64`.
    ///
    /// `Round::Nil` is converted to `-1`.
    /// `Round::Some(r)` is converted to `r`.
    pub fn as_i64(&self) -> i64 {
        match self {
            Round::Nil => -1,
            Round::Some(r) => i64::from(*r),
        }
    }

    /// Whether the round is defined, ie. `r >= 0`.
    pub fn is_defined(&self) -> bool {
        matches!(self, Round::Some(_))
    }

    /// Whether the round is nil, ie. `r == -1`.
    pub fn is_nil(&self) -> bool {
        matches!(self, Round::Nil)
    }

    /// Increment the round.
    ///
    /// If the round is nil, then the initial zero round is returned.
    /// Otherwise, the round is incremented by one.
    pub fn increment(&self) -> Round {
        match self {
            Round::Nil => Round::new(0),
            Round::Some(r) => Round::new(r + 1),
        }
    }
}

impl From<u32> for Round {
    fn from(round: u32) -> Self {
        Round::new(round)
    }
}

impl From<Option<u32>> for Round {
    fn from(round: Option<u32>) -> Self {
        match round {
            None => Round::Nil,
            Some(r) => Round::new(r),
        }
    }
}

impl From<i64> for Round {
    fn from(round: i64) -> Self {
        assert!(round <= i64::from(u32::MAX));

        if round < 0 {
            Round::Nil
        } else {
            Round::new(round as u32)
        }
    }
}

impl PartialOrd for Round {
    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Round {
    fn cmp(&self, other: &Self) -> cmp::Ordering {
        self.as_i64().cmp(&other.as_i64())
    }
}

impl fmt::Display for Round {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.as_i64().fmt(f)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_round() {
        // Test Round::new()
        assert_eq!(Round::new(0), Round::Some(0));
        assert_eq!(Round::new(1), Round::Some(1));
        assert_eq!(Round::new(2), Round::Some(2));

        // Test Round::as_u32()
        assert_eq!(Round::Nil.as_u32(), None);
        assert_eq!(Round::Some(0).as_u32(), Some(0));
        assert_eq!(Round::Some(1).as_u32(), Some(1));
        assert_eq!(Round::Some(2).as_u32(), Some(2));

        // Test Round::as_i64()
        assert_eq!(Round::Nil.as_i64(), -1);
        assert_eq!(Round::Some(0).as_i64(), 0);
        assert_eq!(Round::Some(1).as_i64(), 1);
        assert_eq!(Round::Some(2).as_i64(), 2);

        // Test Round::is_defined()
        assert!(!Round::Nil.is_defined());
        assert!(Round::Some(0).is_defined());
        assert!(Round::Some(1).is_defined());
        assert!(Round::Some(2).is_defined());
    }
}

```
---
### `core-types/src/signed_message.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::ops::Deref;

use derive_where::derive_where;

use crate::{Context, Signature};

/// A signed message, ie. a message emitted by a validator and signed by its private key.
#[derive_where(Clone, Debug, PartialEq, Eq, PartialOrd, Ord; Msg)]
pub struct SignedMessage<Ctx, Msg>
where
    Ctx: Context,
{
    /// The message
    pub message: Msg,

    /// The signature of the proposal.
    pub signature: Signature<Ctx>,
}

impl<Ctx, Msg> SignedMessage<Ctx, Msg>
where
    Ctx: Context,
{
    /// Create a new signed message from the given message and signature.
    pub fn new(message: Msg, signature: Signature<Ctx>) -> Self {
        Self { message, signature }
    }

    /// Map the message to a new message.
    pub fn map<F, NewMsg>(self, f: F) -> SignedMessage<Ctx, NewMsg>
    where
        F: FnOnce(Msg) -> NewMsg,
    {
        SignedMessage {
            message: f(self.message),
            signature: self.signature,
        }
    }

    /// Return a reference to the signed message.
    pub fn as_ref(&self) -> SignedMessage<Ctx, &Msg> {
        SignedMessage {
            message: &self.message,
            signature: self.signature.clone(),
        }
    }
}

impl<Ctx, Msg> Deref for SignedMessage<Ctx, Msg>
where
    Ctx: Context,
{
    type Target = Msg;

    fn deref(&self) -> &Self::Target {
        &self.message
    }
}

```
---
### `core-types/src/signing.rs`
*2025-05-18 23:58:49 | 15 KB*
```rust
use alloc::boxed::Box;
use alloc::vec::Vec;
use core::fmt::{Debug, Display};

use crate::certificate::PolkaSignature;
use crate::{
    CertificateError, CommitCertificate, CommitSignature, Context, NilOrVal, PolkaCertificate,
    PublicKey, Signature, SignedMessage, ThresholdParams, Validator, VotingPower,
};

/// A signing scheme that can be used to sign votes and verify such signatures.
///
/// This trait is used to abstract over the signature scheme used by the consensus engine.
///
/// An example of a signing scheme is the Ed25519 signature scheme,
/// eg. as implemented in the [`ed25519-consensus`][ed25519-consensus] crate.
///
/// [ed25519-consensus]: https://crates.io/crates/ed25519-consensus
pub trait SigningScheme
where
    Self: Clone + Debug + Eq,
{
    /// Errors that can occur when decoding a signature from a byte array.
    type DecodingError: Display;

    /// The type of signatures produced by this signing scheme.
    type Signature: Clone + Debug + Eq + Ord + Send + Sync;

    /// The type of public keys produced by this signing scheme.
    type PublicKey: Clone + Debug + Eq + Send + Sync;

    /// The type of private keys produced by this signing scheme.
    type PrivateKey: Clone + Send + Sync;

    /// Decode a signature from a byte array.
    fn decode_signature(bytes: &[u8]) -> Result<Self::Signature, Self::DecodingError>;

    /// Encode a signature to a byte array.
    fn encode_signature(signature: &Self::Signature) -> Vec<u8>;
}

/// A provider of signing functionality for the consensus engine.
///
/// This trait defines the core signing operations needed by the engine,
/// including signing and verifying votes, proposals, proposal parts, and commit signatures.
/// It is parameterized by a context type `Ctx` that defines the specific types used
/// for votes, proposals, and other consensus-related data structures.
///
/// Implementers of this trait are responsible for managing the private keys used for signing
/// and providing verification logic using the corresponding public keys.
pub trait SigningProvider<Ctx>
where
    Ctx: Context,
    Self: Send + Sync + 'static,
{
    /// Sign the given vote with our private key.
    fn sign_vote(&self, vote: Ctx::Vote) -> SignedMessage<Ctx, Ctx::Vote>;

    /// Verify the given vote's signature using the given public key.
    fn verify_signed_vote(
        &self,
        vote: &Ctx::Vote,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool;

    /// Sign the given proposal with our private key.
    fn sign_proposal(&self, proposal: Ctx::Proposal) -> SignedMessage<Ctx, Ctx::Proposal>;

    /// Verify the given proposal's signature using the given public key.
    fn verify_signed_proposal(
        &self,
        proposal: &Ctx::Proposal,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool;

    /// Sign the proposal part with our private key.
    fn sign_proposal_part(
        &self,
        proposal_part: Ctx::ProposalPart,
    ) -> SignedMessage<Ctx, Ctx::ProposalPart>;

    /// Verify the given proposal part signature using the given public key.
    fn verify_signed_proposal_part(
        &self,
        proposal_part: &Ctx::ProposalPart,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool;

    /// Sign the given vote extension with our private key.
    fn sign_vote_extension(&self, extension: Ctx::Extension) -> SignedMessage<Ctx, Ctx::Extension>;

    /// Verify the given vote extension's signature using the given public key.
    fn verify_signed_vote_extension(
        &self,
        extension: &Ctx::Extension,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool;
}

impl<Ctx> SigningProvider<Ctx> for Box<dyn SigningProvider<Ctx> + '_>
where
    Ctx: Context,
{
    fn sign_vote(&self, vote: Ctx::Vote) -> SignedMessage<Ctx, Ctx::Vote> {
        self.as_ref().sign_vote(vote)
    }

    fn verify_signed_vote(
        &self,
        vote: &<Ctx as Context>::Vote,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool {
        self.as_ref()
            .verify_signed_vote(vote, signature, public_key)
    }

    fn sign_proposal(&self, proposal: Ctx::Proposal) -> SignedMessage<Ctx, Ctx::Proposal> {
        self.as_ref().sign_proposal(proposal)
    }

    fn verify_signed_proposal(
        &self,
        proposal: &Ctx::Proposal,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool {
        self.as_ref()
            .verify_signed_proposal(proposal, signature, public_key)
    }

    fn sign_proposal_part(
        &self,
        proposal_part: Ctx::ProposalPart,
    ) -> SignedMessage<Ctx, Ctx::ProposalPart> {
        self.as_ref().sign_proposal_part(proposal_part)
    }

    fn verify_signed_proposal_part(
        &self,
        proposal_part: &Ctx::ProposalPart,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool {
        self.as_ref()
            .verify_signed_proposal_part(proposal_part, signature, public_key)
    }

    fn sign_vote_extension(&self, extension: Ctx::Extension) -> SignedMessage<Ctx, Ctx::Extension> {
        self.as_ref().sign_vote_extension(extension)
    }

    fn verify_signed_vote_extension(
        &self,
        extension: &Ctx::Extension,
        signature: &Signature<Ctx>,
        public_key: &PublicKey<Ctx>,
    ) -> bool {
        self.as_ref()
            .verify_signed_vote_extension(extension, signature, public_key)
    }
}

/// Extension trait providing additional certificate verification functionality for signing providers.
///
/// This trait extends the base [`SigningProvider`] functionality with methods for verifying
/// commit certificates against validator sets. It is automatically implemented for any type
/// that implements [`SigningProvider`].
pub trait SigningProviderExt<Ctx>
where
    Ctx: Context,
{
    /// Verify a commit signature in a commit certificate against the public key of its validator.
    ///
    /// ## Return
    /// Return the voting power of that validator if the signature is valid.
    fn verify_commit_signature(
        &self,
        ctx: &Ctx,
        certificate: &CommitCertificate<Ctx>,
        commit_sig: &CommitSignature<Ctx>,
        validator: &Ctx::Validator,
    ) -> Result<VotingPower, CertificateError<Ctx>>;

    /// Verify a polka signature in a polka certificate against the public key of its validator.
    ///
    /// ## Return
    /// Return the voting power of that validator if the signature is valid.
    fn verify_polka_signature(
        &self,
        ctx: &Ctx,
        certificate: &PolkaCertificate<Ctx>,
        signature: &PolkaSignature<Ctx>,
        validator: &Ctx::Validator,
    ) -> Result<VotingPower, CertificateError<Ctx>>;

    /// Verify the given certificate against the given validator set.
    ///
    /// - For each commit signature in the certificate:
    ///   - Reconstruct the signed precommit and verify its signature
    /// - Check that we have 2/3+ of voting power has signed the certificate
    ///
    /// If any of those steps fail, return a [`CertificateError`].
    fn verify_commit_certificate(
        &self,
        ctx: &Ctx,
        certificate: &CommitCertificate<Ctx>,
        validator_set: &Ctx::ValidatorSet,
        thresholds: ThresholdParams,
    ) -> Result<(), CertificateError<Ctx>>;

    /// Verify the polka certificate against the given validator set.
    ///
    /// - For each signature in the certificate:
    ///   - Reconstruct the signed prevote and verify its signature
    /// - Check that we have 2/3+ of voting power has signed the certificate
    ///
    /// If any of those steps fail, return a [`CertificateError`].
    fn verify_polka_certificate(
        &self,
        ctx: &Ctx,
        certificate: &PolkaCertificate<Ctx>,
        validator_set: &Ctx::ValidatorSet,
        thresholds: ThresholdParams,
    ) -> Result<(), CertificateError<Ctx>>;
}

impl<Ctx, P> SigningProviderExt<Ctx> for P
where
    Ctx: Context,
    P: SigningProvider<Ctx>,
{
    /// Verify a commit signature in a commit certificate against the public key of its validator.
    ///
    /// ## Return
    /// Return the voting power of that validator if the signature is valid.
    fn verify_commit_signature(
        &self,
        ctx: &Ctx,
        certificate: &CommitCertificate<Ctx>,
        commit_sig: &CommitSignature<Ctx>,
        validator: &Ctx::Validator,
    ) -> Result<VotingPower, CertificateError<Ctx>> {
        // Reconstruct the vote that was signed
        let vote = ctx.new_precommit(
            certificate.height,
            certificate.round,
            NilOrVal::Val(certificate.value_id.clone()),
            validator.address().clone(),
        );

        // Verify signature
        if !self.verify_signed_vote(&vote, &commit_sig.signature, validator.public_key()) {
            return Err(CertificateError::InvalidCommitSignature(commit_sig.clone()));
        }

        Ok(validator.voting_power())
    }

    /// Verify a polka signature in a polka certificate against the public key of its validator.
    ///
    /// ## Return
    /// Return the voting power of that validator if the signature is valid.
    fn verify_polka_signature(
        &self,
        ctx: &Ctx,
        certificate: &PolkaCertificate<Ctx>,
        signature: &PolkaSignature<Ctx>,
        validator: &Ctx::Validator,
    ) -> Result<VotingPower, CertificateError<Ctx>> {
        // Reconstruct the vote that was signed
        let vote = ctx.new_prevote(
            certificate.height,
            certificate.round,
            NilOrVal::Val(certificate.value_id.clone()),
            validator.address().clone(),
        );

        // Verify signature
        if !self.verify_signed_vote(&vote, &signature.signature, validator.public_key()) {
            return Err(CertificateError::InvalidPolkaSignature(signature.clone()));
        }

        Ok(validator.voting_power())
    }

    /// Verify the commit certificate against the given validator set.
    ///
    /// - For each commit signature in the certificate:
    ///   - Reconstruct the signed precommit and verify its signature
    /// - Check that we have 2/3+ of voting power has signed the certificate
    ///
    /// If any of those steps fail, return a [`CertificateError`].
    fn verify_commit_certificate(
        &self,
        ctx: &Ctx,
        certificate: &CommitCertificate<Ctx>,
        validator_set: &Ctx::ValidatorSet,
        thresholds: ThresholdParams,
    ) -> Result<(), CertificateError<Ctx>> {
        use crate::ValidatorSet;

        let mut signed_voting_power = 0;
        let mut seen_validators = Vec::new();

        // For each commit signature, reconstruct the signed precommit and verify the signature
        for commit_sig in &certificate.commit_signatures {
            let validator_address = &commit_sig.address;

            if seen_validators.contains(&validator_address) {
                return Err(CertificateError::DuplicateVote(validator_address.clone()));
            }

            seen_validators.push(validator_address);

            // Abort if validator not in validator set
            let validator = validator_set
                .get_by_address(validator_address)
                .ok_or_else(|| CertificateError::UnknownValidator(validator_address.clone()))?;

            if let Ok(voting_power) =
                self.verify_commit_signature(ctx, certificate, commit_sig, validator)
            {
                signed_voting_power += voting_power;
            }
        }

        let total_voting_power = validator_set.total_voting_power();

        // Check if we have 2/3+ voting power
        if thresholds
            .quorum
            .is_met(signed_voting_power, total_voting_power)
        {
            Ok(())
        } else {
            Err(CertificateError::NotEnoughVotingPower {
                signed: signed_voting_power,
                total: total_voting_power,
                expected: thresholds.quorum.min_expected(total_voting_power),
            })
        }
    }

    /// Verify the polka certificate against the given validator set.
    ///
    /// - For each signed prevote in the certificate:
    ///   - Reconstruct the signed prevote and verify its signature
    /// - Check that we have 2/3+ of voting power has signed the certificate
    ///
    /// If any of those steps fail, return a [`CertificateError`].
    ///
    fn verify_polka_certificate(
        &self,
        ctx: &Ctx,
        certificate: &PolkaCertificate<Ctx>,
        validator_set: &Ctx::ValidatorSet,
        thresholds: ThresholdParams,
    ) -> Result<(), CertificateError<Ctx>> {
        use crate::ValidatorSet;

        let mut signed_voting_power = 0;
        let mut seen_validators = Vec::new();

        for signature in &certificate.polka_signatures {
            let validator_address = &signature.address;

            // Abort if validator already voted
            if seen_validators.contains(&validator_address) {
                return Err(CertificateError::DuplicateVote(validator_address.clone()));
            }

            // Add the validator to the list of seenv validators
            seen_validators.push(validator_address);

            // Abort if validator not in validator set
            let validator = validator_set
                .get_by_address(validator_address)
                .ok_or_else(|| CertificateError::UnknownValidator(validator_address.clone()))?;

            // Check that the vote signature is valid. Do this last and lazily as it is expensive.
            if let Ok(voting_power) =
                self.verify_polka_signature(ctx, certificate, signature, validator)
            {
                signed_voting_power += voting_power;
            }
        }

        let total_voting_power = validator_set.total_voting_power();

        // Check if we have 2/3+ voting power
        if thresholds
            .quorum
            .is_met(signed_voting_power, total_voting_power)
        {
            Ok(())
        } else {
            Err(CertificateError::NotEnoughVotingPower {
                signed: signed_voting_power,
                total: total_voting_power,
                expected: thresholds.quorum.min_expected(total_voting_power),
            })
        }
    }
}

```
---
### `core-types/src/threshold.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use crate::VotingPower;

/// Represents the different quorum thresholds.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Threshold<ValueId> {
    /// No quorum has been reached yet
    Unreached,

    /// Quorum of votes but not for the same value
    Any,

    /// Quorum of votes for nil
    Nil,

    /// Quorum (+2/3) of votes for a value
    Value(ValueId),
}

/// Represents the different quorum thresholds.
///
/// There are two thresholds:
/// - The quorum threshold, which is the minimum number of votes required for a quorum.
/// - The honest threshold, which is the minimum number of votes required for a quorum of honest nodes.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct ThresholdParams {
    /// Threshold for a quorum (default: 2f+1)
    pub quorum: ThresholdParam,

    /// Threshold for the minimum number of honest nodes (default: f+1)
    pub honest: ThresholdParam,
}

impl Default for ThresholdParams {
    fn default() -> Self {
        Self {
            quorum: ThresholdParam::TWO_F_PLUS_ONE,
            honest: ThresholdParam::F_PLUS_ONE,
        }
    }
}

/// Represents the different quorum thresholds.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct ThresholdParam {
    /// Numerator of the threshold
    pub numerator: u64,

    /// Denominator of the threshold
    pub denominator: u64,
}

impl ThresholdParam {
    /// 2f+1, ie. more than two thirds of the total weight
    pub const TWO_F_PLUS_ONE: Self = Self::new(2, 3);

    /// f+1, ie. more than one third of the total weight
    pub const F_PLUS_ONE: Self = Self::new(1, 3);

    /// Create a new threshold parameter with the given numerator and denominator.
    pub const fn new(numerator: u64, denominator: u64) -> Self {
        Self {
            numerator,
            denominator,
        }
    }

    /// Check whether the threshold is met.
    pub fn is_met(&self, weight: VotingPower, total: VotingPower) -> bool {
        let lhs = weight
            .checked_mul(self.denominator)
            .expect("attempt to multiply with overflow");

        let rhs = total
            .checked_mul(self.numerator)
            .expect("attempt to multiply with overflow");

        lhs > rhs
    }

    /// Return the minimum expected weight to meet the threshold when applied to the given total.
    pub fn min_expected(&self, total: VotingPower) -> VotingPower {
        1 + total
            .checked_mul(self.numerator)
            .expect("attempt to multiply with overflow")
            .checked_div(self.denominator)
            .expect("attempt to divide with overflow")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn threshold_param_is_met() {
        assert!(!ThresholdParam::TWO_F_PLUS_ONE.is_met(1, 3));
        assert!(!ThresholdParam::TWO_F_PLUS_ONE.is_met(2, 3));
        assert!(ThresholdParam::TWO_F_PLUS_ONE.is_met(3, 3));

        assert!(!ThresholdParam::F_PLUS_ONE.is_met(3, 10));
        assert!(ThresholdParam::F_PLUS_ONE.is_met(4, 10));
        assert!(!ThresholdParam::TWO_F_PLUS_ONE.is_met(6, 10));
        assert!(ThresholdParam::TWO_F_PLUS_ONE.is_met(7, 10));
    }

    #[test]
    #[should_panic(expected = "attempt to multiply with overflow")]
    fn threshold_param_is_met_overflow() {
        assert!(!ThresholdParam::TWO_F_PLUS_ONE.is_met(1, u64::MAX));
    }
}

```
---
### `core-types/src/timeout.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt;

use crate::Round;

/// The timeout type. There may be multiple timeouts running in a given step.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TimeoutKind {
    /// Timeout for the propose step.
    Propose,

    /// Timeout for the prevote step.
    Prevote,

    /// Timeout for the precommit step.
    Precommit,

    /// Timeout to rebroadcast the round synchronization messages
    Rebroadcast,
}

/// A timeout for a round step.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct Timeout {
    /// The timeout kind.
    pub kind: TimeoutKind,

    /// The round for which the timeout is for.
    pub round: Round,
}

impl Timeout {
    /// Create a new timeout for the given round and step.
    pub const fn new(round: Round, kind: TimeoutKind) -> Self {
        Self { round, kind }
    }

    /// Create a new timeout for the propose step of the given round.
    pub const fn propose(round: Round) -> Self {
        Self::new(round, TimeoutKind::Propose)
    }

    /// Create a new timeout for the prevote step of the given round.
    pub const fn prevote(round: Round) -> Self {
        Self::new(round, TimeoutKind::Prevote)
    }

    /// Create a new timeout for the precommit step of the given round.
    pub const fn precommit(round: Round) -> Self {
        Self::new(round, TimeoutKind::Precommit)
    }

    /// Create a new timeout for rebroadcasting the round synchronization messages.
    pub const fn rebroadcast(round: Round) -> Self {
        Self::new(round, TimeoutKind::Rebroadcast)
    }
}

impl fmt::Display for Timeout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}Timeout({})", self.kind, self.round)
    }
}

```
---
### `core-types/src/validator_set.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt::{Debug, Display};

use crate::{Context, PublicKey};

/// Voting power held by a validator.
///
/// TODO: Introduce newtype
pub type VotingPower = u64;

/// Defines the requirements for an address.
pub trait Address
where
    Self: Clone + Debug + Display + Eq + Ord + Send + Sync,
{
}

/// Defines the requirements for a validator.
pub trait Validator<Ctx>
where
    Self: Clone + Debug + Eq + Send + Sync,
    Ctx: Context,
{
    /// The address of the validator, typically derived from its public key.
    fn address(&self) -> &Ctx::Address;

    /// The public key of the validator, used to verify signatures.
    fn public_key(&self) -> &PublicKey<Ctx>;

    /// The voting power held by the validaror.
    fn voting_power(&self) -> VotingPower;
}

/// Defines the requirements for a validator set.
///
/// A validator set is a collection of validators.
pub trait ValidatorSet<Ctx>
where
    Self: Clone + Debug + Eq + Send + Sync,
    Ctx: Context,
{
    /// The number of validators in the set.
    fn count(&self) -> usize;

    /// The total voting power of the validator set.
    fn total_voting_power(&self) -> VotingPower;

    /// Get the validator with the given address.
    fn get_by_address(&self, address: &Ctx::Address) -> Option<&Ctx::Validator>;

    /// Get the validator at the given index.
    fn get_by_index(&self, index: usize) -> Option<&Ctx::Validator>;
}

```
---
### `core-types/src/value.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use core::fmt::{Debug, Display};

/// Represents either `Nil` or a value of type `Value`.
///
/// This type is isomorphic to `Option<Value>` but is more explicit about its intent.
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub enum NilOrVal<Value> {
    /// The value is `nil`.
    #[default]
    Nil,

    /// The value is a value of type `Value`.
    Val(Value),
}

impl<Value> NilOrVal<Value> {
    /// Whether this is `nil`.
    pub fn is_nil(&self) -> bool {
        matches!(self, Self::Nil)
    }

    /// Whether this is an actual value.
    pub fn is_val(&self) -> bool {
        matches!(self, Self::Val(_))
    }

    /// Apply the given function to the value if it is not `nil`.
    pub fn map<NewValue, F: FnOnce(Value) -> NewValue>(self, f: F) -> NilOrVal<NewValue> {
        match self {
            NilOrVal::Nil => NilOrVal::Nil,
            NilOrVal::Val(value) => NilOrVal::Val(f(value)),
        }
    }

    /// Convert this into an `NilOrVal<&Value>`, allowing to borrow the value.
    pub fn as_ref(&self) -> NilOrVal<&Value> {
        match self {
            NilOrVal::Nil => NilOrVal::Nil,
            NilOrVal::Val(value) => NilOrVal::Val(value),
        }
    }

    /// Consumes this and returns the value if it is not `nil`,
    /// otherwise returns the default `Value`.
    // (note adi) Find what is this for? Could not find a way to use it.
    pub fn value_or_default(self) -> Value
    where
        Value: Default,
    {
        match self {
            NilOrVal::Nil => Value::default(),
            NilOrVal::Val(value) => value,
        }
    }
}

impl<Value> NilOrVal<&Value> {
    /// Clone the underlying value
    #[must_use = "`self` will be dropped if the result is not used"]
    pub fn cloned(self) -> NilOrVal<Value>
    where
        Value: Clone,
    {
        match self {
            NilOrVal::Nil => NilOrVal::Nil,
            NilOrVal::Val(value) => NilOrVal::Val(value.clone()),
        }
    }
}

/// The `Value` type denotes the value `v` carried by the `Proposal`
/// consensus message broadcast by the proposer of a round of consensus.
///
/// How to instantiate `Value` with a concrete type depends on which mode consensus
/// is parametrized to run in. See the documentation for the [`ValuePayload`]
/// type for more information.
pub trait Value
where
    Self: Clone + Debug + PartialEq + Eq + PartialOrd + Ord + Send + Sync,
{
    /// A unique representation of the `Value` with a lower memory footprint, denoted `id(v)`.
    /// It is carried by votes and herefore is typically set to be a hash of the value `v`.
    type Id: Clone + Debug + Display + Eq + Ord + Send + Sync;

    /// The ID of the value.
    fn id(&self) -> Self::Id;
}

/// The possible messages used to deliver proposals
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ValuePayload {
    /// The proposer broadcasts a `Proposal` consensus message carrying the full proposed value `v`. There is no proposal part streaming.
    /// Better suited for small proposed values when there are no benefits of gossiping proposal parts.
    /// In this case `Value` is typically set to be the block and `Id` is its hash.
    ProposalOnly,

    /// The proposer does not broadcast a `Proposal` consensus message at all. The proposer only streams the proposed value as proposal parts.
    /// In this case `Value` is typically set to the same type as `Id`.
    PartsOnly,

    /// The proposer broadcasts a `Proposal` message carrying `id(v)` and streams the full proposed value `v` as proposal parts.
    /// In this case `Value` is typically set to the same type as `Id`.
    ProposalAndParts,
}

impl ValuePayload {
    /// Whether the proposer must publish the proposed value as a `Proposal` message.
    pub fn include_proposal(self) -> bool {
        matches!(self, Self::ProposalOnly | Self::ProposalAndParts)
    }

    /// Whether the proposer must publish the proposed value as parts.
    pub fn include_parts(self) -> bool {
        matches!(self, Self::PartsOnly | Self::ProposalAndParts)
    }

    /// Whether the proposal must only publish proposal parts, no `Proposal` message.
    pub fn parts_only(self) -> bool {
        matches!(self, Self::PartsOnly)
    }

    /// Whether the proposer must only publish a `Proposal` message, no proposal parts.
    pub fn proposal_only(&self) -> bool {
        matches!(self, Self::ProposalOnly)
    }
}

/// Protocols that diseminate `Value`
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum ValueOrigin {
    /// Synchronization protocol
    Sync,

    /// Consensus protocol
    Consensus,
}

```
---
### `core-types/src/vote.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt::Debug;

use crate::{Context, NilOrVal, Round, SignedExtension, Value};

/// A type of vote.
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum VoteType {
    /// Votes for values which validators observe are valid for a given round.
    Prevote,

    /// Votes to commit to a particular value for a given round.
    Precommit,
}

/// Defines the requirements for a vote.
///
/// Votes are signed messages from validators for a particular value which
/// include information about the validator signing it.
pub trait Vote<Ctx>
where
    Self: Clone + Debug + Eq + Ord + Send + Sync + 'static,
    Ctx: Context,
{
    /// The height for which the vote is for.
    fn height(&self) -> Ctx::Height;

    /// The round for which the vote is for.
    fn round(&self) -> Round;

    /// Get a reference to the value being voted for.
    fn value(&self) -> &NilOrVal<<Ctx::Value as Value>::Id>;

    /// Take ownership of the value being voted for.
    fn take_value(self) -> NilOrVal<<Ctx::Value as Value>::Id>;

    /// The type of vote.
    fn vote_type(&self) -> VoteType;

    /// Address of the validator who issued this vote
    fn validator_address(&self) -> &Ctx::Address;

    /// Votes extensions
    fn extension(&self) -> Option<&SignedExtension<Ctx>>;

    /// Return an owned reference to this vote's extensions,
    /// removing them from the vote in the process.
    fn take_extension(&mut self) -> Option<SignedExtension<Ctx>>;

    /// Extend this vote with an extension, overriding any existing extension.
    fn extend(self, extension: SignedExtension<Ctx>) -> Self;
}

```
---
### `core-types/src/vote_extension.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt::Debug;

use alloc::vec::Vec;
use bytes::Bytes;
use derive_where::derive_where;

use crate::{Context, SignedExtension};

/// A set of vote extensions.
#[derive_where(Clone, Debug, Default, PartialEq, Eq)]
pub struct VoteExtensions<Ctx: Context> {
    /// The vote extensions together with the address of their proposer.
    pub extensions: Vec<(Ctx::Address, SignedExtension<Ctx>)>,
}

impl<Ctx: Context> VoteExtensions<Ctx> {
    /// Creates a new set of vote extensions.
    pub fn new(mut extensions: Vec<(Ctx::Address, SignedExtension<Ctx>)>) -> Self {
        // Sort vote extensions by their proposer's address
        extensions.sort_by(|(a, _), (b, _)| a.cmp(b));

        Self { extensions }
    }

    /// Returns the size of the extensions in bytes.
    pub fn size_bytes(&self) -> usize {
        self.extensions.iter().map(|(_, e)| e.size_bytes()).sum()
    }
}

/// Vote extensions allows applications to extend the pre-commit vote with arbitrary data.
/// This allows applications to force their validators to do more than just validate blocks within consensus.
pub trait Extension
where
    Self: Clone + Debug + Eq + Send + Sync + 'static,
{
    /// Returns the size of the extension in bytes.
    fn size_bytes(&self) -> usize;
}

impl Extension for () {
    fn size_bytes(&self) -> usize {
        0
    }
}

impl Extension for Vec<u8> {
    fn size_bytes(&self) -> usize {
        self.len()
    }
}

impl Extension for Bytes {
    fn size_bytes(&self) -> usize {
        self.len()
    }
}

impl<const N: usize> Extension for [u8; N] {
    fn size_bytes(&self) -> usize {
        N
    }
}

```
---
### `core-votekeeper/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-core-votekeeper"
description = "Voting system for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
malachitebft-core-types = { workspace = true }

derive-where = { workspace = true }
thiserror = { workspace = true, default-features = false }

[dev-dependencies]
malachitebft-test = { workspace = true }

```
---
### `core-votekeeper/src/count.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
//! For tallying votes of the same type.

use alloc::collections::BTreeSet;
use derive_where::derive_where;

use malachitebft_core_types::{Context, NilOrVal, ValueId, Vote};

use crate::value_weights::ValuesWeights;
use crate::{Threshold, ThresholdParam, Weight};

/// VoteCount tallys votes of the same type.
///
/// Votes are for nil or for some value.
#[derive_where(Clone, Debug, Default, PartialEq, Eq)]
pub struct VoteCount<Ctx: Context> {
    /// Weight of votes for the values, including nil
    pub values_weights: ValuesWeights<NilOrVal<ValueId<Ctx>>>,

    /// Addresses of validators who voted for the values
    pub validator_addresses: BTreeSet<Ctx::Address>,
}

impl<Ctx: Context> VoteCount<Ctx> {
    /// Create a new `VoteCount`.
    pub fn new() -> Self {
        VoteCount {
            values_weights: ValuesWeights::new(),
            validator_addresses: BTreeSet::new(),
        }
    }

    /// Add vote for a value (or nil) to internal counters, but only if we haven't seen
    /// a vote from that particular validator yet.
    pub fn add(&mut self, vote: &Ctx::Vote, weight: Weight) -> Weight {
        if self.validator_addresses.contains(vote.validator_address()) {
            // Validator has already voted, ignore this vote
            self.values_weights.get(vote.value())
        } else {
            self.validator_addresses
                .insert(vote.validator_address().clone());
            self.values_weights.add(vote.value().clone(), weight)
        }
    }

    /// Return the weight of votes for the given value (or nil).
    pub fn get(&self, value: &NilOrVal<ValueId<Ctx>>) -> Weight {
        self.values_weights.get(value)
    }

    /// Return the sum of weights of votes for all values.
    pub fn sum(&self) -> Weight {
        self.values_weights.sum()
    }

    /// Return whether or not the threshold is met, ie. if we have a quorum for that threshold.
    pub fn is_threshold_met(
        &self,
        threshold: Threshold<ValueId<Ctx>>,
        param: ThresholdParam,
        total_weight: Weight,
    ) -> bool {
        match threshold {
            Threshold::Value(value) => {
                let weight = self.values_weights.get(&NilOrVal::Val(value));
                param.is_met(weight, total_weight)
            }

            Threshold::Nil => {
                let weight = self.values_weights.get(&NilOrVal::Nil);
                param.is_met(weight, total_weight)
            }

            Threshold::Any => {
                let sum_weight = self.values_weights.sum();
                param.is_met(sum_weight, total_weight)
            }

            Threshold::Unreached => false,
        }
    }
}

```
---
### `core-votekeeper/src/evidence.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! Evidence of equivocation.

use alloc::collections::btree_map::BTreeMap;
use alloc::{vec, vec::Vec};

use derive_where::derive_where;

use malachitebft_core_types::{Context, SignedVote, Vote};

/// Keeps track of evidence of equivocation.
#[derive_where(Clone, Debug, Default)]
pub struct EvidenceMap<Ctx>
where
    Ctx: Context,
{
    #[allow(clippy::type_complexity)]
    map: BTreeMap<Ctx::Address, Vec<(SignedVote<Ctx>, SignedVote<Ctx>)>>,
}

impl<Ctx> EvidenceMap<Ctx>
where
    Ctx: Context,
{
    /// Create a new `EvidenceMap` instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Return whether or not there is any evidence of equivocation.
    pub fn is_empty(&self) -> bool {
        self.map.is_empty()
    }

    /// Return the evidence of equivocation for a given address, if any.
    pub fn get(&self, address: &Ctx::Address) -> Option<&Vec<(SignedVote<Ctx>, SignedVote<Ctx>)>> {
        self.map.get(address)
    }

    /// Add evidence of equivocation.
    pub fn add(&mut self, existing: SignedVote<Ctx>, vote: SignedVote<Ctx>) {
        debug_assert_eq!(existing.validator_address(), vote.validator_address());

        if let Some(evidence) = self.map.get_mut(vote.validator_address()) {
            evidence.push((existing, vote));
        } else {
            self.map
                .insert(vote.validator_address().clone(), vec![(existing, vote)]);
        }
    }
}

```
---
### `core-votekeeper/src/keeper.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
//! For tallying votes and emitting messages when certain thresholds are reached.

use derive_where::derive_where;
use thiserror::Error;

use alloc::collections::{BTreeMap, BTreeSet};

use malachitebft_core_types::{
    Context, NilOrVal, Round, SignedVote, Validator, ValidatorSet, ValueId, Vote, VoteType,
};

use crate::evidence::EvidenceMap;
use crate::round_votes::RoundVotes;
use crate::round_weights::RoundWeights;
use crate::{Threshold, ThresholdParams, Weight};

/// Messages emitted by the vote keeper
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Output<Value> {
    /// We have a quorum of prevotes for some value or nil
    PolkaAny,

    /// We have a quorum of prevotes for nil
    PolkaNil,

    /// We have a quorum of prevotes for specific value
    PolkaValue(Value),

    /// We have a quorum of precommits for some value or nil
    PrecommitAny,

    /// We have a quorum of precommits for a specific value
    PrecommitValue(Value),

    /// We have f+1 honest votes for a value at a higher round
    SkipRound(Round),
}

/// Keeps track of votes and emitted outputs for a given round.
#[derive_where(Clone, Debug, PartialEq, Eq, Default)]
pub struct PerRound<Ctx>
where
    Ctx: Context,
{
    /// The votes for this round.
    votes: RoundVotes<Ctx>,

    /// The addresses and their weights for this round.
    addresses_weights: RoundWeights<Ctx::Address>,

    /// All the votes received for this round.
    received_votes: BTreeSet<SignedVote<Ctx>>,

    /// The emitted outputs for this round.
    emitted_outputs: BTreeSet<Output<ValueId<Ctx>>>,
}

/// Errors can that be yielded when recording a vote.
#[derive(Error)]
pub enum RecordVoteError<Ctx>
where
    Ctx: Context,
{
    /// Attempted to record a conflicting vote.
    #[error("Conflicting vote: {existing} vs {conflicting}")]
    ConflictingVote {
        /// The vote already recorded.
        existing: SignedVote<Ctx>,
        /// The conflicting vote.
        conflicting: SignedVote<Ctx>,
    },
}

impl<Ctx> PerRound<Ctx>
where
    Ctx: Context,
{
    /// Create a new `PerRound` instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a vote to the round, checking for conflicts.
    pub fn add(
        &mut self,
        vote: SignedVote<Ctx>,
        weight: Weight,
    ) -> Result<(), RecordVoteError<Ctx>> {
        if let Some(existing) = self.get_vote(vote.vote_type(), vote.validator_address()) {
            if existing.value() != vote.value() {
                // This is an equivocating vote
                return Err(RecordVoteError::ConflictingVote {
                    existing: existing.clone(),
                    conflicting: vote,
                });
            }
        }

        // Tally this vote
        self.votes.add_vote(&vote, weight);

        // Update the weight of the validator
        self.addresses_weights
            .set_once(vote.validator_address(), weight);

        // Add the vote to the received votes
        self.received_votes.insert(vote);

        Ok(())
    }

    /// Return the vote of the given type received from the given validator.
    pub fn get_vote<'a>(
        &'a self,
        vote_type: VoteType,
        address: &'a Ctx::Address,
    ) -> Option<&'a SignedVote<Ctx>> {
        self.received_votes
            .iter()
            .find(move |vote| vote.vote_type() == vote_type && vote.validator_address() == address)
    }

    /// Return the votes for this round.
    pub fn votes(&self) -> &RoundVotes<Ctx> {
        &self.votes
    }

    /// Return the votes for this round.
    pub fn received_votes(&self) -> &BTreeSet<SignedVote<Ctx>> {
        &self.received_votes
    }

    /// Return the addresses and their weights for this round.
    pub fn addresses_weights(&self) -> &RoundWeights<Ctx::Address> {
        &self.addresses_weights
    }

    /// Return the emitted outputs for this round.
    pub fn emitted_outputs(&self) -> &BTreeSet<Output<ValueId<Ctx>>> {
        &self.emitted_outputs
    }
}

/// Keeps track of votes and emits messages when thresholds are reached.
#[derive_where(Clone, Debug)]
pub struct VoteKeeper<Ctx>
where
    Ctx: Context,
{
    /// The validator set for this height.
    validator_set: Ctx::ValidatorSet,

    /// The threshold parameters.
    threshold_params: ThresholdParams,

    /// The votes and emitted outputs for each round.
    per_round: BTreeMap<Round, PerRound<Ctx>>,

    /// Evidence of equivocation.
    evidence: EvidenceMap<Ctx>,
}

impl<Ctx> VoteKeeper<Ctx>
where
    Ctx: Context,
{
    /// Create a new `VoteKeeper` instance, for the given
    /// total network weight (ie. voting power) and threshold parameters.
    pub fn new(validator_set: Ctx::ValidatorSet, threshold_params: ThresholdParams) -> Self {
        Self {
            validator_set,
            threshold_params,
            per_round: BTreeMap::new(),
            evidence: EvidenceMap::new(),
        }
    }

    /// Return the current validator set
    pub fn validator_set(&self) -> &Ctx::ValidatorSet {
        &self.validator_set
    }

    /// Return the total weight (ie. voting power) of the network.
    pub fn total_weight(&self) -> Weight {
        self.validator_set.total_voting_power()
    }

    /// Return the votes for the given round.
    pub fn per_round(&self, round: Round) -> Option<&PerRound<Ctx>> {
        self.per_round.get(&round)
    }

    /// Return how many rounds we have seen votes for so far.
    pub fn rounds(&self) -> usize {
        self.per_round.len()
    }

    /// Return the highest round we have seen votes for so far.
    pub fn max_round(&self) -> Round {
        self.per_round.keys().max().copied().unwrap_or(Round::Nil)
    }

    /// Return the evidence of equivocation.
    pub fn evidence(&self) -> &EvidenceMap<Ctx> {
        &self.evidence
    }

    /// Check if we have already seen a vote.
    pub fn has_vote(&self, vote: &SignedVote<Ctx>) -> bool {
        self.per_round
            .get(&vote.round())
            .is_some_and(|per_round| per_round.received_votes().contains(vote))
    }

    /// Apply a vote with a given weight, potentially triggering an output.
    pub fn apply_vote(
        &mut self,
        vote: SignedVote<Ctx>,
        round: Round,
    ) -> Option<Output<ValueId<Ctx>>> {
        let total_weight = self.total_weight();
        let per_round = self.per_round.entry(vote.round()).or_default();

        let Some(validator) = self.validator_set.get_by_address(vote.validator_address()) else {
            // Vote from unknown validator, let's discard it.
            return None;
        };

        match per_round.add(vote.clone(), validator.voting_power()) {
            Ok(()) => (),
            Err(RecordVoteError::ConflictingVote {
                existing,
                conflicting,
            }) => {
                // This is an equivocating vote
                self.evidence.add(existing.clone(), conflicting);
                //panic!("Equivocating vote {:?}, existing {:?}", &vote, &existing);
                return None;
            }
        }

        if vote.round() > round {
            let combined_weight = per_round.addresses_weights.sum();

            let skip_round = self
                .threshold_params
                .honest
                .is_met(combined_weight, total_weight);

            if skip_round {
                let output = Output::SkipRound(vote.round());
                per_round.emitted_outputs.insert(output.clone());
                return Some(output);
            }
        }

        let threshold = compute_threshold(
            vote.vote_type(),
            per_round,
            vote.value(),
            self.threshold_params,
            total_weight,
        );

        let output = threshold_to_output(vote.vote_type(), threshold);

        match output {
            // Ensure we do not output the same message twice
            Some(output) if !per_round.emitted_outputs.contains(&output) => {
                per_round.emitted_outputs.insert(output.clone());
                Some(output)
            }
            _ => None,
        }
    }

    /// Check if a threshold is met, ie. if we have a quorum for that threshold.
    pub fn is_threshold_met(
        &self,
        round: &Round,
        vote_type: VoteType,
        threshold: Threshold<ValueId<Ctx>>,
    ) -> bool {
        self.per_round.get(round).is_some_and(|per_round| {
            per_round.votes.is_threshold_met(
                vote_type,
                threshold,
                self.threshold_params.quorum,
                self.total_weight(),
            )
        })
    }
}

/// Compute whether or not we have reached a threshold for the given value,
/// and return that threshold.
fn compute_threshold<Ctx>(
    vote_type: VoteType,
    round: &PerRound<Ctx>,
    value: &NilOrVal<ValueId<Ctx>>,
    thresholds: ThresholdParams,
    total_weight: Weight,
) -> Threshold<ValueId<Ctx>>
where
    Ctx: Context,
{
    let weight = round.votes.get_weight(vote_type, value);

    match value {
        NilOrVal::Val(value) if thresholds.quorum.is_met(weight, total_weight) => {
            Threshold::Value(value.clone())
        }

        NilOrVal::Nil if thresholds.quorum.is_met(weight, total_weight) => Threshold::Nil,

        _ => {
            let weight_sum = round.votes.weight_sum(vote_type);

            if thresholds.quorum.is_met(weight_sum, total_weight) {
                Threshold::Any
            } else {
                Threshold::Unreached
            }
        }
    }
}

/// Map a vote type and a threshold to a state machine output.
fn threshold_to_output<Value>(typ: VoteType, threshold: Threshold<Value>) -> Option<Output<Value>> {
    match (typ, threshold) {
        (_, Threshold::Unreached) => None,

        (VoteType::Prevote, Threshold::Any) => Some(Output::PolkaAny),
        (VoteType::Prevote, Threshold::Nil) => Some(Output::PolkaNil),
        (VoteType::Prevote, Threshold::Value(v)) => Some(Output::PolkaValue(v)),

        (VoteType::Precommit, Threshold::Any) => Some(Output::PrecommitAny),
        (VoteType::Precommit, Threshold::Nil) => Some(Output::PrecommitAny),
        (VoteType::Precommit, Threshold::Value(v)) => Some(Output::PrecommitValue(v)),
    }
}

```
---
### `core-votekeeper/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Infrastructure for tallying votes within the consensus engine.

#![no_std]
#![forbid(unsafe_code)]
#![deny(trivial_casts, trivial_numeric_casts)]
#![warn(
    missing_docs,
    rustdoc::broken_intra_doc_links,
    rustdoc::private_intra_doc_links,
    variant_size_differences
)]
#![cfg_attr(not(test), deny(clippy::unwrap_used, clippy::panic))]

extern crate alloc;

pub mod count;
pub mod evidence;
pub mod keeper;
pub mod round_votes;
pub mod round_weights;
pub mod value_weights;

/// Represents the weight of a vote,
/// ie. the voting power of the validator that cast the vote.
pub type Weight = malachitebft_core_types::VotingPower;

pub use malachitebft_core_types::{Threshold, ThresholdParam, ThresholdParams};

```
---
### `core-votekeeper/src/round_votes.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
//! For tallying all the votes for a single round

use derive_where::derive_where;

use malachitebft_core_types::{Context, NilOrVal, ValueId, Vote, VoteType};

use crate::count::VoteCount;
use crate::{Threshold, ThresholdParam, Weight};

/// Tracks all the votes for a single round
#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct RoundVotes<Ctx: Context> {
    /// The prevotes for this round.
    prevotes: VoteCount<Ctx>,
    /// The precommits for this round.
    precommits: VoteCount<Ctx>,
}

impl<Ctx: Context> RoundVotes<Ctx> {
    /// Create a new `RoundVotes` instance.
    pub fn new() -> Self {
        RoundVotes {
            prevotes: VoteCount::new(),
            precommits: VoteCount::new(),
        }
    }

    /// Return the prevotes for this round.
    pub fn prevotes(&self) -> &VoteCount<Ctx> {
        &self.prevotes
    }

    /// Return the precommits for this round.
    pub fn precommits(&self) -> &VoteCount<Ctx> {
        &self.precommits
    }

    /// Add a vote to the round, of the given type, from the given address,
    /// with the given value and weight.
    pub fn add_vote(&mut self, vote: &Ctx::Vote, weight: Weight) -> Weight {
        match vote.vote_type() {
            VoteType::Prevote => self.prevotes.add(vote, weight),
            VoteType::Precommit => self.precommits.add(vote, weight),
        }
    }

    /// Get the weight of the vote of the given type for the given value.
    ///
    /// If there is no vote for that value, return 0.
    pub fn get_weight(&self, vote_type: VoteType, value: &NilOrVal<ValueId<Ctx>>) -> Weight {
        match vote_type {
            VoteType::Prevote => self.prevotes.get(value),
            VoteType::Precommit => self.precommits.get(value),
        }
    }

    /// Get the sum of the weights of the votes of the given type.
    pub fn weight_sum(&self, vote_type: VoteType) -> Weight {
        match vote_type {
            VoteType::Prevote => self.prevotes.sum(),
            VoteType::Precommit => self.precommits.sum(),
        }
    }

    /// Get the sum of the weights of all votes, regardless of type, for the given value.
    pub fn combined_weight(&self, value: &NilOrVal<ValueId<Ctx>>) -> Weight {
        self.prevotes.get(value) + self.precommits.get(value)
    }

    /// Return whether or not the threshold is met, ie. if we have a quorum for that threshold.
    pub fn is_threshold_met(
        &self,
        vote_type: VoteType,
        threshold: Threshold<ValueId<Ctx>>,
        param: ThresholdParam,
        total_weight: Weight,
    ) -> bool {
        match vote_type {
            VoteType::Prevote => self
                .prevotes
                .is_threshold_met(threshold, param, total_weight),

            VoteType::Precommit => self
                .precommits
                .is_threshold_met(threshold, param, total_weight),
        }
    }
}

impl<Ctx: Context> Default for RoundVotes<Ctx> {
    fn default() -> Self {
        Self::new()
    }
}

```
---
### `core-votekeeper/src/round_weights.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! For tracking the weight (ie. voting power) of each validator.

use alloc::collections::BTreeMap;

use crate::Weight;

/// Keeps track of the weight (ie. voting power) of each validator.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct RoundWeights<Address> {
    map: BTreeMap<Address, Weight>,
}

impl<Address> RoundWeights<Address> {
    /// Create a new `RoundWeights` instance.
    pub fn new() -> Self {
        RoundWeights {
            map: BTreeMap::new(),
        }
    }

    /// Return the inner map.
    pub fn get_inner(&self) -> &BTreeMap<Address, Weight> {
        &self.map
    }

    /// Set the weight of the given address, if it is not already set.
    pub fn set_once(&mut self, address: &Address, weight: Weight)
    where
        Address: Clone + Ord,
    {
        if !self.map.contains_key(address) {
            self.map.insert(address.clone(), weight);
        }
    }

    /// Get the weight of the given address.
    pub fn get(&self, address: &Address) -> Weight
    where
        Address: Ord,
    {
        *self.map.get(address).unwrap_or(&0)
    }

    /// Return the sum of the weights of all the addresses.
    pub fn sum(&self) -> Weight {
        self.map.values().sum()
    }
}

impl<Address> Default for RoundWeights<Address> {
    fn default() -> Self {
        Self::new()
    }
}

```
---
### `core-votekeeper/src/value_weights.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
//! A value and the weight of votes for it.

use alloc::collections::BTreeMap;

use crate::Weight;

/// A value and the weight of votes for it.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ValuesWeights<Value> {
    value_weights: BTreeMap<Value, Weight>,
}

impl<Value> ValuesWeights<Value> {
    /// Create a new `ValuesWeights` instance.
    pub fn new() -> ValuesWeights<Value> {
        ValuesWeights {
            value_weights: BTreeMap::new(),
        }
    }

    /// Add weight to the value and return the new weight.
    pub fn add(&mut self, value: Value, weight: Weight) -> Weight
    where
        Value: Ord,
    {
        let entry = self.value_weights.entry(value).or_insert(0);
        *entry = entry
            .checked_add(weight)
            .expect("attempt to add with overflow");
        *entry
    }

    /// Return the weight of the value, or 0 if it is not present.
    pub fn get(&self, value: &Value) -> Weight
    where
        Value: Ord,
    {
        self.value_weights.get(value).copied().unwrap_or(0)
    }

    /// Return the sum of the weights of all values.
    pub fn sum(&self) -> Weight {
        let mut weight: Weight = 0;
        for w in self.value_weights.values() {
            weight = weight
                .checked_add(*w)
                .expect("attempt to sum with overflow");
        }
        weight
    }
}

impl<Value> Default for ValuesWeights<Value> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn values_weights() {
        let mut vw = ValuesWeights::new();

        assert_eq!(vw.get(&None), 0);
        assert_eq!(vw.get(&Some(1)), 0);

        assert_eq!(vw.add(None, 1), 1);
        assert_eq!(vw.get(&None), 1);
        assert_eq!(vw.get(&Some(1)), 0);

        assert_eq!(vw.add(Some(1), 1), 1);
        assert_eq!(vw.get(&None), 1);
        assert_eq!(vw.get(&Some(1)), 1);

        assert_eq!(vw.add(None, 1), 2);
        assert_eq!(vw.get(&None), 2);
        assert_eq!(vw.get(&Some(1)), 1);

        assert_eq!(vw.add(Some(1), 1), 2);
        assert_eq!(vw.get(&None), 2);
        assert_eq!(vw.get(&Some(1)), 2);

        assert_eq!(vw.add(Some(2), 1), 1);
        assert_eq!(vw.get(&None), 2);
        assert_eq!(vw.get(&Some(1)), 2);
        assert_eq!(vw.get(&Some(2)), 1);
    }

    #[test]
    #[should_panic(expected = "attempt to add with overflow")]
    fn values_weight_add_overflow() {
        let mut vw: ValuesWeights<Option<u64>> = ValuesWeights::new();
        vw.add(None, Weight::MAX);
        vw.add(None, 1);
    }

    #[test]
    #[should_panic(expected = "attempt to sum with overflow")]
    fn values_weight_sum_overflow() {
        let mut vw: ValuesWeights<Option<u64>> = ValuesWeights::new();
        vw.add(None, Weight::MAX);
        vw.add(Some(1), 1);
        vw.sum();
    }
}

```
---
### `core-votekeeper/tests/round_votes.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use malachitebft_core_types::{NilOrVal, Round};
use malachitebft_test::{Address, Height, TestContext, ValueId, Vote};

use informalsystems_malachitebft_core_votekeeper::round_votes::RoundVotes;

const ADDRESS1: Address = Address::new([41; 20]);
const ADDRESS2: Address = Address::new([42; 20]);
const ADDRESS3: Address = Address::new([43; 20]);
const ADDRESS4: Address = Address::new([44; 20]);
const ADDRESS5: Address = Address::new([45; 20]);
const ADDRESS6: Address = Address::new([46; 20]);

#[test]
fn add_votes_nil() {
    let h = Height::new(1);
    let r = Round::new(0);

    let mut round_votes = RoundVotes::<TestContext>::new();

    let vote1 = Vote::new_prevote(h, r, NilOrVal::Nil, ADDRESS1);
    let weight1 = round_votes.add_vote(&vote1, 1);
    assert_eq!(weight1, 1);

    let vote2 = Vote::new_prevote(h, r, NilOrVal::Nil, ADDRESS2);
    let weight2 = round_votes.add_vote(&vote2, 1);
    assert_eq!(weight2, 2);

    let vote3 = Vote::new_prevote(h, r, NilOrVal::Nil, ADDRESS3);
    let weight3 = round_votes.add_vote(&vote3, 1);
    assert_eq!(weight3, 3);
}

#[test]
fn add_votes_single_value() {
    let h = Height::new(1);
    let r = Round::new(0);
    let v = ValueId::new(1);
    let val = NilOrVal::Val(v);
    let weight = 1;

    let mut round_votes = RoundVotes::<TestContext>::new();

    // add a vote, nothing changes.
    let vote1 = Vote::new_prevote(h, r, val, ADDRESS1);
    let weight1 = round_votes.add_vote(&vote1, weight);
    assert_eq!(weight1, 1);

    // add it again, nothing changes.
    let vote2 = Vote::new_prevote(h, r, val, ADDRESS2);
    let weight3 = round_votes.add_vote(&vote2, weight);
    assert_eq!(weight3, 2);

    // add a vote for nil, get w::Any
    let vote3 = Vote::new_prevote(h, r, NilOrVal::Nil, ADDRESS3);
    let weight4 = round_votes.add_vote(&vote3, weight);
    assert_eq!(weight4, 1);

    // add vote for value, get w::Value
    let vote5 = Vote::new_prevote(h, r, val, ADDRESS4);
    let weight5 = round_votes.add_vote(&vote5, weight);
    assert_eq!(weight5, 3);
}

#[test]
fn add_votes_multi_values() {
    let h = Height::new(1);
    let r = Round::new(0);

    let v1 = ValueId::new(1);
    let v2 = ValueId::new(2);
    let val1 = NilOrVal::Val(v1);
    let val2 = NilOrVal::Val(v2);

    let mut round_votes = RoundVotes::<TestContext>::new();

    let vote1 = Vote::new_precommit(h, r, val1, ADDRESS1);
    let weight1 = round_votes.add_vote(&vote1, 1);
    assert_eq!(weight1, 1);

    let vote2 = Vote::new_precommit(h, r, val2, ADDRESS2);
    let weight2 = round_votes.add_vote(&vote2, 1);
    assert_eq!(weight2, 1);

    let vote3 = Vote::new_precommit(h, r, NilOrVal::Nil, ADDRESS3);
    let weight3 = round_votes.add_vote(&vote3, 1);
    assert_eq!(weight3, 1);

    let vote4 = Vote::new_precommit(h, r, val1, ADDRESS4);
    let weight4 = round_votes.add_vote(&vote4, 1);
    assert_eq!(weight4, 2);

    let vote5 = Vote::new_precommit(h, r, val2, ADDRESS5);
    let weight5 = round_votes.add_vote(&vote5, 1);
    assert_eq!(weight5, 2);

    let vote6 = Vote::new_precommit(h, r, val2, ADDRESS6);
    let weight6 = round_votes.add_vote(&vote6, 10);
    assert_eq!(weight6, 12);
}

```
---
### `core-votekeeper/tests/vote_count.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
#![allow(clippy::bool_assert_comparison)]

use malachitebft_core_types::{NilOrVal, Round};
use malachitebft_test::{Address, Height, TestContext, ValueId, Vote};

use informalsystems_malachitebft_core_votekeeper::count::VoteCount;
use informalsystems_malachitebft_core_votekeeper::{Threshold, ThresholdParam};

#[test]
fn vote_count_nil() {
    let t = 4;
    let q = ThresholdParam::TWO_F_PLUS_ONE;
    let h = Height::new(1);
    let r = Round::new(0);

    let mut vc = VoteCount::<TestContext>::new();

    let addr1 = Address::new([1; 20]);
    let addr2 = Address::new([2; 20]);
    let addr3 = Address::new([3; 20]);
    let addr4 = Address::new([4; 20]);

    let val1 = ValueId::new(1);
    let val2 = ValueId::new(2);

    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote1 = Vote::new_prevote(h, r, NilOrVal::Nil, addr1);
    assert_eq!(vc.add(&vote1, 1), 1);
    assert_eq!(vc.get(&NilOrVal::Nil), 1);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote2 = Vote::new_prevote(h, r, NilOrVal::Nil, addr2);
    assert_eq!(vc.add(&vote2, 1), 2);
    assert_eq!(vc.get(&NilOrVal::Nil), 2);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    // addr1 votes again, is ignored
    let vote3 = Vote::new_prevote(h, r, NilOrVal::Nil, addr1);
    assert_eq!(vc.add(&vote3, 1), 2);
    assert_eq!(vc.get(&NilOrVal::Nil), 2);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote4 = Vote::new_prevote(h, r, NilOrVal::Nil, addr3);
    assert_eq!(vc.add(&vote4, 1), 3);
    assert_eq!(vc.get(&NilOrVal::Nil), 3);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote5 = Vote::new_prevote(h, r, NilOrVal::Val(ValueId::new(1)), addr4);
    assert_eq!(vc.add(&vote5, 1), 1);
    assert_eq!(vc.get(&NilOrVal::Nil), 3);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 1);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);
}

#[test]
fn vote_count_value() {
    let t = 4;
    let q = ThresholdParam::TWO_F_PLUS_ONE;
    let h = Height::new(1);
    let r = Round::new(0);

    let mut vc = VoteCount::<TestContext>::new();

    let addr1 = Address::new([1; 20]);
    let addr2 = Address::new([2; 20]);
    let addr3 = Address::new([3; 20]);
    let addr4 = Address::new([4; 20]);

    let val1 = ValueId::new(1);
    let val2 = ValueId::new(2);
    let val3 = ValueId::new(3);

    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote1 = Vote::new_prevote(h, r, NilOrVal::Val(val1), addr1);
    assert_eq!(vc.add(&vote1, 1), 1);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 1);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote2 = Vote::new_prevote(h, r, NilOrVal::Val(val1), addr2);
    assert_eq!(vc.add(&vote2, 1), 2);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 2);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    // addr1 votes again, for nil this time, is ignored
    let vote3 = Vote::new_prevote(h, r, NilOrVal::Nil, addr1);
    assert_eq!(vc.add(&vote3, 1), 0);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 2);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote4 = Vote::new_prevote(h, r, NilOrVal::Val(val1), addr3);
    assert_eq!(vc.add(&vote4, 1), 3);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 3);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    // addr2 votes again, for the same value, is ignored
    let vote5 = Vote::new_prevote(h, r, NilOrVal::Val(val1), addr2);
    assert_eq!(vc.add(&vote5, 1), 3);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 3);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    let vote6 = Vote::new_prevote(h, r, NilOrVal::Val(val2), addr4);
    assert_eq!(vc.add(&vote6, 1), 1);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 3);
    assert_eq!(vc.get(&NilOrVal::Val(val2)), 1);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);

    // addr4 votes again, for a different value, is ignored
    let vote7 = Vote::new_prevote(h, r, NilOrVal::Val(val3), addr4);
    assert_eq!(vc.add(&vote7, 1), 0);
    assert_eq!(vc.get(&NilOrVal::Nil), 0);
    assert_eq!(vc.get(&NilOrVal::Val(val1)), 3);
    assert_eq!(vc.get(&NilOrVal::Val(val2)), 1);
    assert_eq!(vc.get(&NilOrVal::Val(val3)), 0);
    assert_eq!(vc.is_threshold_met(Threshold::Unreached, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Any, q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Nil, q, t), false);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val1), q, t), true);
    assert_eq!(vc.is_threshold_met(Threshold::Value(val2), q, t), false);
}

```
---
### `core-votekeeper/tests/vote_keeper.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
use malachitebft_core_types::{NilOrVal, Round, SignedVote};

use informalsystems_malachitebft_core_votekeeper::keeper::{Output, VoteKeeper};

use malachitebft_test::{
    Address, Height, PrivateKey, Signature, TestContext, Validator, ValidatorSet, ValueId, Vote,
};

fn setup<const N: usize>(vp: [u64; N]) -> ([Address; N], VoteKeeper<TestContext>) {
    let mut addrs = [Address::new([0; 20]); N];
    let mut vals = Vec::with_capacity(N);
    for i in 0..N {
        let pk = PrivateKey::from([i as u8; 32]);
        addrs[i] = Address::from_public_key(&pk.public_key());
        vals.push(Validator::new(pk.public_key(), vp[i]));
    }
    let keeper = VoteKeeper::new(ValidatorSet::new(vals), Default::default());
    (addrs, keeper)
}

fn new_signed_prevote(
    height: Height,
    round: Round,
    value: NilOrVal<ValueId>,
    addr: Address,
) -> SignedVote<TestContext> {
    SignedVote::new(
        Vote::new_prevote(height, round, value, addr),
        Signature::test(),
    )
}

fn new_signed_precommit(
    height: Height,
    round: Round,
    value: NilOrVal<ValueId>,
    addr: Address,
) -> SignedVote<TestContext> {
    SignedVote::new(
        Vote::new_precommit(height, round, value, addr),
        Signature::test(),
    )
}

#[test]
fn prevote_apply_nil() {
    let ([addr1, addr2, addr3], mut keeper) = setup([1, 1, 1]);

    let height = Height::new(1);
    let round = Round::new(0);

    let vote = new_signed_prevote(height, round, NilOrVal::Nil, addr1);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, round, NilOrVal::Nil, addr2);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, round, NilOrVal::Nil, addr3);
    let msg = keeper.apply_vote(vote, round);
    assert_eq!(msg, Some(Output::PolkaNil));
}

#[test]
fn precommit_apply_nil() {
    let ([addr1, addr2, addr3], mut keeper) = setup([1, 1, 1]);

    let height = Height::new(1);
    let round = Round::new(0);

    let vote = new_signed_precommit(height, round, NilOrVal::Nil, addr1);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, Round::new(0), NilOrVal::Nil, addr2);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, Round::new(0), NilOrVal::Nil, addr3);
    let msg = keeper.apply_vote(vote, round);
    assert_eq!(msg, Some(Output::PrecommitAny));
}

#[test]
fn prevote_apply_single_value() {
    let ([addr1, addr2, addr3, addr4], mut keeper) = setup([1, 1, 1, 1]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let round = Round::new(0);

    let vote = new_signed_prevote(height, Round::new(0), val, addr1);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, Round::new(0), val, addr2);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote_nil = new_signed_prevote(height, Round::new(0), NilOrVal::Nil, addr3);
    let msg = keeper.apply_vote(vote_nil, round);
    assert_eq!(msg, Some(Output::PolkaAny));

    let vote = new_signed_prevote(height, Round::new(0), val, addr4);
    let msg = keeper.apply_vote(vote, round);
    assert_eq!(msg, Some(Output::PolkaValue(id)));
}

#[test]
fn precommit_apply_single_value() {
    let ([addr1, addr2, addr3, addr4], mut keeper) = setup([1, 1, 1, 1]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let round = Round::new(0);

    let vote = new_signed_precommit(height, Round::new(0), val, addr1);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, Round::new(0), val, addr2);
    let msg = keeper.apply_vote(vote.clone(), round);
    assert_eq!(msg, None);

    let vote_nil = new_signed_precommit(height, Round::new(0), NilOrVal::Nil, addr3);
    let msg = keeper.apply_vote(vote_nil, round);
    assert_eq!(msg, Some(Output::PrecommitAny));

    let vote = new_signed_precommit(height, Round::new(0), val, addr4);
    let msg = keeper.apply_vote(vote, round);
    assert_eq!(msg, Some(Output::PrecommitValue(id)));
}

#[test]
fn skip_round_small_quorum_prevotes_two_vals() {
    let ([addr1, addr2, addr3, _], mut keeper) = setup([1, 1, 1, 1]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let cur_round = Round::new(0);
    let fut_round = Round::new(1);

    let vote = new_signed_prevote(height, cur_round, val, addr1);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, fut_round, val, addr3);
    let msg = keeper.apply_vote(vote, cur_round);
    assert_eq!(msg, Some(Output::SkipRound(Round::new(1))));
}

#[test]
fn skip_round_small_quorum_with_prevote_precommit_two_vals() {
    let ([addr1, addr2, addr3, _], mut keeper) = setup([1, 1, 1, 1]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let cur_round = Round::new(0);
    let fut_round = Round::new(1);

    let vote = new_signed_prevote(height, cur_round, val, addr1);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, fut_round, val, addr3);
    let msg = keeper.apply_vote(vote, cur_round);
    assert_eq!(msg, Some(Output::SkipRound(Round::new(1))));
}

#[test]
fn skip_round_full_quorum_with_prevote_precommit_two_vals() {
    let ([addr1, addr2, addr3], mut keeper) = setup::<3>([1, 1, 2]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let cur_round = Round::new(0);
    let fut_round = Round::new(1);

    let vote = new_signed_prevote(height, cur_round, val, addr1);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, fut_round, val, addr3);
    let msg = keeper.apply_vote(vote, cur_round);
    assert_eq!(msg, Some(Output::SkipRound(Round::new(1))));
}

#[test]
fn no_skip_round_small_quorum_with_same_val() {
    let ([addr1, addr2, ..], mut keeper) = setup([1, 1, 1, 1]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let cur_round = Round::new(0);
    let fut_round = Round::new(1);

    let vote = new_signed_prevote(height, cur_round, val, addr1);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote, cur_round);
    assert_eq!(msg, None);
}

#[test]
fn no_skip_round_full_quorum_with_same_val() {
    let ([addr1, addr2, ..], mut keeper) = setup([1, 1, 1, 1]);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);
    let height = Height::new(1);
    let cur_round = Round::new(0);
    let fut_round = Round::new(1);

    let vote = new_signed_prevote(height, cur_round, val, addr1);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_prevote(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote.clone(), cur_round);
    assert_eq!(msg, None);

    let vote = new_signed_precommit(height, fut_round, val, addr2);
    let msg = keeper.apply_vote(vote, cur_round);
    assert_eq!(msg, None);
}

#[test]
fn same_votes() {
    let ([addr1, ..], mut keeper) = setup([1, 1]);

    let height = Height::new(1);
    let round = Round::new(0);

    let id = ValueId::new(1);
    let val = NilOrVal::Val(id);

    let vote1 = new_signed_prevote(height, round, val, addr1);
    let msg = keeper.apply_vote(vote1.clone(), round);
    assert_eq!(msg, None);

    let vote2 = new_signed_prevote(height, round, val, addr1);
    let msg = keeper.apply_vote(vote2.clone(), round);
    assert_eq!(msg, None);

    assert!(keeper.evidence().is_empty());
    assert_eq!(keeper.evidence().get(&addr1), None);
}

#[test]
fn equivocation() {
    let ([addr1, addr2, ..], mut keeper) = setup([1, 1, 1]);

    let height = Height::new(1);
    let round = Round::new(0);

    let id1 = ValueId::new(1);
    let val1 = NilOrVal::Val(id1);

    let vote11 = new_signed_prevote(height, round, val1, addr1);
    let msg = keeper.apply_vote(vote11.clone(), round);
    assert_eq!(msg, None);

    let vote12 = new_signed_prevote(height, round, NilOrVal::Nil, addr1);
    let msg = keeper.apply_vote(vote12.clone(), round);
    assert_eq!(msg, None);

    assert!(!keeper.evidence().is_empty());
    assert_eq!(keeper.evidence().get(&addr1), Some(&vec![(vote11, vote12)]));

    let vote21 = new_signed_prevote(height, round, val1, addr2);
    let msg = keeper.apply_vote(vote21.clone(), round);
    assert_eq!(msg, None);

    let id2 = ValueId::new(2);
    let val2 = NilOrVal::Val(id2);

    let vote22 = new_signed_prevote(height, round, val2, addr2);
    let msg = keeper.apply_vote(vote22.clone(), round);
    assert_eq!(msg, None);

    assert_eq!(keeper.evidence().get(&addr2), Some(&vec![(vote21, vote22)]));
}

```
---
### `discovery/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-discovery"
description = "Discovery protocol for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[lints]
workspace = true

[dependencies]
malachitebft-metrics = { workspace = true }
libp2p = { workspace = true }
serde = { workspace = true }
tracing = { workspace = true }
tokio = { workspace = true }
either = { workspace = true }
rand = { workspace = true }

```
---
### `discovery/src/behaviour.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::collections::HashSet;
use std::iter;
use std::time::Duration;

use either::Either;
use libp2p::identity::Keypair;
use libp2p::kad::store::MemoryStore;
use libp2p::kad::{Addresses, KBucketKey, KBucketRef, Mode, RoutingUpdate};
use libp2p::request_response::{self, OutboundRequestId, ProtocolSupport, ResponseChannel};
use libp2p::swarm::behaviour::toggle::Toggle;
use libp2p::swarm::NetworkBehaviour;
use libp2p::{kad, Multiaddr, PeerId, StreamProtocol};
use serde::{Deserialize, Serialize};

use crate::config::BootstrapProtocol;
use crate::Config;

const DISCOVERY_KAD_PROTOCOL: &str = "/malachitebft-discovery/kad/v1beta1";
const DISCOVERY_REQRES_PROTOCOL: &str = "/malachitebft-discovery/reqres/v1beta1";

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Request {
    Peers(HashSet<(Option<PeerId>, Multiaddr)>),
    Connect(),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Response {
    Peers(HashSet<(Option<PeerId>, Multiaddr)>),
    Connect(bool),
}

#[derive(Debug)]
pub enum NetworkEvent {
    Kademlia(kad::Event),
    RequestResponse(request_response::Event<Request, Response>),
}

impl From<kad::Event> for NetworkEvent {
    fn from(event: kad::Event) -> Self {
        Self::Kademlia(event)
    }
}

impl From<request_response::Event<Request, Response>> for NetworkEvent {
    fn from(event: request_response::Event<Request, Response>) -> Self {
        Self::RequestResponse(event)
    }
}

impl<A, B> From<Either<A, B>> for NetworkEvent
where
    A: Into<NetworkEvent>,
    B: Into<NetworkEvent>,
{
    fn from(event: Either<A, B>) -> Self {
        match event {
            Either::Left(event) => event.into(),
            Either::Right(event) => event.into(),
        }
    }
}

#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "NetworkEvent")]
pub struct Behaviour {
    pub kademlia: Toggle<kad::Behaviour<MemoryStore>>,
    pub request_response: request_response::cbor::Behaviour<Request, Response>,
}

fn kademlia_config() -> kad::Config {
    let mut config = kad::Config::new(StreamProtocol::new(DISCOVERY_KAD_PROTOCOL));

    // In production, one might set this to a high value to keep a fresh view of the network
    config.set_periodic_bootstrap_interval(None);

    config
}

fn request_response_protocol() -> iter::Once<(StreamProtocol, ProtocolSupport)> {
    iter::once((
        StreamProtocol::new(DISCOVERY_REQRES_PROTOCOL),
        ProtocolSupport::Full,
    ))
}

fn request_response_config() -> request_response::Config {
    request_response::Config::default().with_request_timeout(Duration::from_secs(5))
}

impl Behaviour {
    pub fn new(keypair: &Keypair, config: Config) -> Self {
        let kademlia = Toggle::from(
            (config.enabled && config.bootstrap_protocol == BootstrapProtocol::Kademlia).then(
                || {
                    let mut kademlia = kad::Behaviour::with_config(
                        keypair.public().to_peer_id(),
                        MemoryStore::new(keypair.public().to_peer_id()),
                        kademlia_config(),
                    );

                    kademlia.set_mode(Some(Mode::Server));

                    kademlia
                },
            ),
        );

        let request_response = request_response::cbor::Behaviour::new(
            request_response_protocol(),
            request_response_config(),
        );

        Self {
            kademlia,
            request_response,
        }
    }
}

pub trait DiscoveryClient: NetworkBehaviour {
    fn add_address(&mut self, peer: &PeerId, address: Multiaddr) -> RoutingUpdate;

    fn kbuckets(&mut self) -> impl Iterator<Item = KBucketRef<'_, KBucketKey<PeerId>, Addresses>>;

    fn send_request(&mut self, peer_id: &PeerId, req: Request) -> OutboundRequestId;

    fn send_response(
        &mut self,
        ch: ResponseChannel<Response>,
        rs: Response,
    ) -> Result<(), Response>;
}

```
---
### `discovery/src/config.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::time::Duration;

const DEFAULT_NUM_OUTBOUND_PEERS: usize = 20;
const DEFAULT_NUM_INBOUND_PEERS: usize = 20;

const DEFAULT_EPHEMERAL_CONNECTION_TIMEOUT: Duration = Duration::from_secs(15);

const DEFAULT_DIAL_MAX_RETRIES: usize = 5;
const DEFAULT_PEERS_REQUEST_MAX_RETRIES: usize = 5;
const DEFAULT_CONNECT_REQUEST_MAX_RETRIES: usize = 0;

#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
pub enum BootstrapProtocol {
    #[default]
    Kademlia,
    Full,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Default)]
pub enum Selector {
    #[default]
    Kademlia,
    Random,
}

#[derive(Copy, Clone, Debug)]
pub struct Config {
    pub enabled: bool,

    pub bootstrap_protocol: BootstrapProtocol,
    pub selector: Selector,

    pub num_outbound_peers: usize,
    pub num_inbound_peers: usize,

    pub ephemeral_connection_timeout: Duration,

    pub dial_max_retries: usize,
    pub request_max_retries: usize,
    pub connect_request_max_retries: usize,
}

impl Default for Config {
    fn default() -> Self {
        if DEFAULT_NUM_INBOUND_PEERS < DEFAULT_NUM_OUTBOUND_PEERS {
            panic!("Number of inbound peers should be greater than or equal to number of outbound peers");
        }

        Self {
            enabled: true,

            bootstrap_protocol: BootstrapProtocol::default(),
            selector: Selector::default(),

            num_outbound_peers: DEFAULT_NUM_OUTBOUND_PEERS,
            num_inbound_peers: DEFAULT_NUM_INBOUND_PEERS,

            ephemeral_connection_timeout: DEFAULT_EPHEMERAL_CONNECTION_TIMEOUT,

            dial_max_retries: DEFAULT_DIAL_MAX_RETRIES,
            request_max_retries: DEFAULT_PEERS_REQUEST_MAX_RETRIES,
            connect_request_max_retries: DEFAULT_CONNECT_REQUEST_MAX_RETRIES,
        }
    }
}

impl Config {
    pub fn new(enabled: bool) -> Self {
        Self {
            enabled,
            ..Default::default()
        }
    }

    pub fn set_bootstrap_protocol(&mut self, protocol: BootstrapProtocol) {
        self.bootstrap_protocol = protocol;
    }

    pub fn set_selector(&mut self, selector: Selector) {
        self.selector = selector;
    }

    pub fn set_peers_bounds(&mut self, num_outbound_peers: usize, num_inbound_peers: usize) {
        if num_inbound_peers < num_outbound_peers {
            panic!("Number of inbound peers should be greater than or equal to number of outbound peers");
        }

        self.num_outbound_peers = num_outbound_peers;
        self.num_inbound_peers = num_inbound_peers;
    }

    pub fn set_ephemeral_connection_timeout(&mut self, timeout: Duration) {
        self.ephemeral_connection_timeout = timeout;
    }
}

```
---
### `discovery/src/connection.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use libp2p::{swarm::dial_opts::DialOpts, Multiaddr, PeerId};

use crate::util::Retry;

#[derive(Debug, Clone)]
pub struct ConnectionData {
    peer_id: Option<PeerId>,
    multiaddr: Multiaddr,
    pub retry: Retry,
}

impl ConnectionData {
    pub fn new(peer_id: Option<PeerId>, multiaddr: Multiaddr) -> Self {
        Self {
            peer_id,
            multiaddr,
            retry: Retry::new(),
        }
    }

    pub fn set_peer_id(&mut self, peer_id: PeerId) {
        self.peer_id = Some(peer_id);
    }

    pub fn peer_id(&self) -> Option<PeerId> {
        self.peer_id
    }

    pub fn multiaddr(&self) -> Multiaddr {
        self.multiaddr.clone()
    }

    pub fn build_dial_opts(&self) -> DialOpts {
        if let Some(peer_id) = self.peer_id {
            DialOpts::peer_id(peer_id)
                .addresses(vec![self.multiaddr.clone()])
                .allocate_new_port()
                .build()
        } else {
            DialOpts::unknown_peer_id()
                .address(self.multiaddr.clone())
                .allocate_new_port()
                .build()
        }
    }
}

```
---
### `discovery/src/controller.rs`
*2025-05-18 23:58:49 | 8 KB*
```rust
#![allow(clippy::bool_assert_comparison)]

use std::collections::{HashMap, HashSet};
use std::hash::Hash;
use std::time::Duration;

use libp2p::{request_response::OutboundRequestId, swarm::ConnectionId, Multiaddr, PeerId};
use tokio::sync::mpsc;
use tracing::error;

use crate::{request::RequestData, ConnectionData};

const DEFAULT_DIAL_CONCURRENT_FACTOR: usize = 20;
const DEFAULT_PEERS_REQUEST_CONCURRENT_FACTOR: usize = 20;
const DEFAULT_CONNECT_REQUEST_CONCURRENT_FACTOR: usize = 100;
const DEFAULT_CLOSE_CONCURRENT_FACTOR: usize = usize::MAX;

#[derive(Debug)]
pub struct Action<T, U, V> {
    tx_queue: mpsc::UnboundedSender<V>,
    rx_queue: mpsc::UnboundedReceiver<V>,
    done_on: HashSet<T>,
    concurrent_factor: usize,
    in_progress: HashMap<U, V>,
}

impl<T, U, V> Action<T, U, V>
where
    T: Eq + Hash,
    U: Eq + Hash,
    V: Send + 'static,
{
    pub(crate) fn new(concurrent_factor: usize) -> Self {
        let (tx_queue, rx_queue) = mpsc::unbounded_channel();

        Self {
            tx_queue,
            rx_queue,
            done_on: HashSet::new(),
            concurrent_factor,
            in_progress: HashMap::new(),
        }
    }

    pub(crate) fn add_to_queue(&mut self, value: V, delay: Option<Duration>) {
        // Avoid spawning a new task if the delay is None
        if delay.is_none() {
            self.tx_queue.send(value).unwrap_or_else(|e| {
                error!("Failed to send value to queue: {:?}", e);
            });
            return;
        }

        let tx_queue = self.tx_queue.clone();
        tokio::spawn(async move {
            if let Some(delay) = delay {
                tokio::time::sleep(delay).await;
            }
            tx_queue.send(value).unwrap_or_else(|e| {
                error!("Failed to send value to queue: {:?}", e);
            })
        });
    }

    pub(crate) fn queue_len(&self) -> usize {
        self.rx_queue.len()
    }

    pub async fn recv(&mut self) -> Option<V> {
        self.rx_queue.recv().await
    }

    pub(crate) fn register_done_on(&mut self, key: T) {
        self.done_on.insert(key);
    }

    pub(crate) fn is_done_on(&self, key: &T) -> bool {
        self.done_on.contains(key)
    }

    pub(crate) fn can_perform(&self) -> bool {
        self.in_progress.len() < self.concurrent_factor
    }

    pub(crate) fn register_in_progress(&mut self, key: U, value: V) {
        self.in_progress.insert(key, value);
    }

    pub(crate) fn get_in_progress_iter(&self) -> impl Iterator<Item = (&U, &V)> {
        self.in_progress.iter()
    }

    pub(crate) fn is_in_progress(&self, key: &U) -> bool {
        self.in_progress.contains_key(key)
    }

    pub(crate) fn get_in_progress_mut(&mut self, key: &U) -> Option<&mut V> {
        self.in_progress.get_mut(key)
    }

    pub(crate) fn remove_in_progress(&mut self, key: &U) -> Option<V> {
        self.in_progress.remove(key)
    }

    pub(crate) fn is_idle(&self) -> (bool, usize) {
        (self.in_progress.is_empty(), self.in_progress.len())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PeerData {
    PeerId(PeerId),
    Multiaddr(Multiaddr),
}

#[derive(Debug)]
pub struct Controller {
    pub dial: Action<PeerData, ConnectionId, ConnectionData>,
    pub peers_request: Action<PeerId, OutboundRequestId, RequestData>,
    pub connect_request: Action<PeerId, OutboundRequestId, RequestData>,
    pub close: Action<(), (), (PeerId, ConnectionId)>,
}

impl Controller {
    pub(crate) fn new() -> Self {
        Controller {
            dial: Action::new(DEFAULT_DIAL_CONCURRENT_FACTOR),
            peers_request: Action::new(DEFAULT_PEERS_REQUEST_CONCURRENT_FACTOR),
            connect_request: Action::new(DEFAULT_CONNECT_REQUEST_CONCURRENT_FACTOR),
            close: Action::new(DEFAULT_CLOSE_CONCURRENT_FACTOR),
        }
    }

    pub(crate) fn dial_register_done_on(&mut self, connection_data: &ConnectionData) {
        if let Some(peer_id) = connection_data.peer_id() {
            self.dial.register_done_on(PeerData::PeerId(peer_id));
        }
        self.dial
            .register_done_on(PeerData::Multiaddr(connection_data.multiaddr()));
    }

    pub(crate) fn dial_is_done_on(&self, connection_data: &ConnectionData) -> bool {
        connection_data
            .peer_id()
            .is_some_and(|peer_id| self.dial.is_done_on(&PeerData::PeerId(peer_id)))
            || self
                .dial
                .is_done_on(&PeerData::Multiaddr(connection_data.multiaddr()))
    }

    pub(crate) fn dial_add_peer_id_to_connection_data(
        &mut self,
        connection_id: ConnectionId,
        peer_id: PeerId,
    ) {
        if let Some(connection_data) = self.dial.get_in_progress_mut(&connection_id) {
            connection_data.set_peer_id(peer_id);
        }
    }

    pub(crate) fn dial_remove_matching_in_progress_connections(
        &mut self,
        peer_id: &PeerId,
    ) -> Vec<ConnectionData> {
        let matching_connection_ids = self
            .dial
            .get_in_progress_iter()
            .filter_map(|(connection_id, connection_data)| {
                if connection_data.peer_id() == Some(*peer_id) {
                    Some(*connection_id)
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        matching_connection_ids
            .into_iter()
            .filter_map(|connection_id| self.dial.remove_in_progress(&connection_id))
            .collect()
    }

    pub(crate) fn is_idle(&self) -> (bool, usize, usize) {
        let (is_dial_idle, in_progress_dial_len) = self.dial.is_idle();
        let (is_peers_request_idle, in_progress_peers_request_len) = self.peers_request.is_idle();
        (
            is_dial_idle && is_peers_request_idle,
            in_progress_dial_len,
            in_progress_peers_request_len,
        )
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use super::*;

    #[test]
    fn test_action() {
        let mut action = Action::<PeerData, u32, u32>::new(2);

        assert_eq!(action.can_perform(), true);
        assert_eq!(action.is_idle(), (true, 0));

        let peer_id = PeerId::random();
        let multiaddr = Multiaddr::from_str("/ip4/127.0.0.1/tcp/12345").unwrap();

        assert_eq!(action.is_done_on(&PeerData::PeerId(peer_id)), false);
        assert_eq!(
            action.is_done_on(&PeerData::Multiaddr(multiaddr.clone())),
            false
        );

        action.register_in_progress(1, 1);

        assert_eq!(action.can_perform(), true);
        assert_eq!(action.is_idle(), (false, 1));

        action.register_in_progress(2, 2);

        assert_eq!(action.can_perform(), false);
        assert_eq!(action.is_idle(), (false, 2));

        assert_eq!(action.remove_in_progress(&1), Some(1));
        assert_eq!(action.can_perform(), true);
        assert_eq!(action.is_idle(), (false, 1));
        assert_eq!(action.remove_in_progress(&1), None);

        action.register_done_on(PeerData::PeerId(peer_id));

        assert_eq!(action.is_done_on(&PeerData::PeerId(peer_id)), true);
        assert_eq!(
            action.is_done_on(&PeerData::Multiaddr(multiaddr.clone())),
            false
        );

        action.register_done_on(PeerData::Multiaddr(multiaddr.clone()));

        assert_eq!(action.is_done_on(&PeerData::PeerId(peer_id)), true);
        assert_eq!(
            action.is_done_on(&PeerData::Multiaddr(multiaddr.clone())),
            true
        );

        assert_eq!(action.remove_in_progress(&2), Some(2));
        assert_eq!(action.can_perform(), true);
        assert_eq!(action.is_idle(), (true, 0));
        assert_eq!(action.remove_in_progress(&2), None);
    }
}

```
---
### `discovery/src/handlers/bootstrap.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use libp2p::swarm;
use tracing::info;

use crate::{Discovery, DiscoveryClient, State};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub(crate) fn handle_successful_bootstrap(&mut self, swarm: &mut swarm::Swarm<C>) {
        // NOTE: A new bootstrap query is initiated every time a new peer is added
        // to the routing table (delayed with kad crate configuration parameter `automatic_bootstrap_throttle`
        // to avoid multiple queries in a short period of time).
        // Here, we only consider the first bootstrap query to determine the status of the discovery process.
        if self.state == State::Bootstrapping {
            info!(
                "Discovery bootstrap done in {}ms, found {} peers",
                self.metrics.elapsed().as_millis(),
                self.active_connections_len()
            );

            self.metrics.initial_bootstrap_finished();

            if self.active_connections_len() < self.config.num_outbound_peers {
                info!(
                    "Not enough active connections (got {}, expected {}) to select outbound peers",
                    self.active_connections_len(),
                    self.config.num_outbound_peers
                );

                self.initiate_extension_with_target(swarm, self.config.num_outbound_peers);
            } else {
                info!(
                    "Discovery found {} peers (expected {}) in {}ms",
                    self.discovered_peers.len(),
                    self.config.num_outbound_peers,
                    self.metrics.elapsed().as_millis()
                );

                self.adjust_connections(swarm);

                self.state = State::Idle;
            }
        }
    }

    pub(crate) fn handle_failed_bootstrap(&mut self) {
        if self.state == State::Bootstrapping {
            self.state = State::Idle;
        }
    }
}

```
---
### `discovery/src/handlers/close.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use libp2p::{swarm::ConnectionId, PeerId, Swarm};
use tracing::{debug, error, warn};

use crate::{Discovery, DiscoveryClient, State};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub fn can_close(&mut self) -> bool {
        self.state == State::Idle && self.controller.close.can_perform()
    }

    fn should_close(&self, peer_id: PeerId, connection_id: ConnectionId) -> bool {
        // Only close ephemeral connections (i.e not inbound/outbound connections)
        self.outbound_connections
            .get(&peer_id)
            .is_none_or(|out_conn| out_conn.connection_id != Some(connection_id))
            && self.inbound_connections.get(&peer_id) != Some(&connection_id)
    }

    pub fn close_connection(
        &mut self,
        swarm: &mut Swarm<C>,
        peer_id: PeerId,
        connection_id: ConnectionId,
    ) {
        if !self.should_close(peer_id, connection_id) {
            return;
        }

        if self
            .active_connections
            .get(&peer_id)
            .is_some_and(|connections| connections.contains(&connection_id))
        {
            if swarm.close_connection(connection_id) {
                debug!("Closing connection {connection_id} to peer {peer_id}");
            } else {
                error!("Error closing connection {connection_id} to peer {peer_id}");
            }
        } else {
            warn!("Tried to close an unknown connection {connection_id} to peer {peer_id}");
        }
    }

    pub fn handle_closed_connection(
        &mut self,
        swarm: &mut Swarm<C>,
        peer_id: PeerId,
        connection_id: ConnectionId,
    ) {
        if let Some(connections) = self.active_connections.get_mut(&peer_id) {
            if connections.contains(&connection_id) {
                warn!("Removing active connection {connection_id} to peer {peer_id}");
                connections.retain(|id| id != &connection_id);
                if connections.is_empty() {
                    self.active_connections.remove(&peer_id);
                }
            } else {
                warn!("Non-established connection {connection_id} to peer {peer_id} closed");
            }
        }

        // In case the connection was closed before identifying the peer
        self.controller.dial.remove_in_progress(&connection_id);

        if self
            .outbound_connections
            .get(&peer_id)
            .is_some_and(|out_conn| out_conn.connection_id == Some(connection_id))
        {
            warn!("Outbound connection {connection_id} to peer {peer_id} closed");

            self.outbound_connections.remove(&peer_id);

            if self.is_enabled() {
                self.repair_outbound_connection(swarm);
            }
        } else if self.inbound_connections.get(&peer_id) == Some(&connection_id) {
            warn!("Inbound connection {connection_id} to peer {peer_id} closed");

            self.inbound_connections.remove(&peer_id);
        }

        self.update_connections_metrics();
    }
}

```
---
### `discovery/src/handlers/connect_request.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use libp2p::{
    request_response::{OutboundRequestId, ResponseChannel},
    swarm::ConnectionId,
    PeerId, Swarm,
};
use tracing::{debug, error, trace};

use crate::{
    behaviour::{self, Response},
    request::RequestData,
    Discovery, DiscoveryClient,
};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub fn can_connect_request(&self) -> bool {
        self.controller.peers_request.can_perform()
    }

    fn should_connect_request(&self, request_data: &RequestData) -> bool {
        // Has not already requested, or has requested but retries are allowed
        !self
            .controller
            .connect_request
            .is_done_on(&request_data.peer_id())
            || request_data.retry.count() != 0
    }

    pub fn connect_request_peer(&mut self, swarm: &mut Swarm<C>, request_data: RequestData) {
        if !self.should_connect_request(&request_data) {
            return;
        }

        self.controller
            .connect_request
            .register_done_on(request_data.peer_id());

        // Do not count retries as new interactions
        if request_data.retry.count() == 0 {
            self.metrics.increment_total_connect_requests();
        }

        debug!(
            "Requesting persistent connection to peer {}, retry #{}",
            request_data.peer_id(),
            request_data.retry.count()
        );

        let request_id = swarm
            .behaviour_mut()
            .send_request(&request_data.peer_id(), behaviour::Request::Connect());

        self.controller
            .connect_request
            .register_in_progress(request_id, request_data);
    }

    pub(crate) fn handle_connect_request(
        &mut self,
        swarm: &mut Swarm<C>,
        channel: ResponseChannel<Response>,
        peer: PeerId,
        connection_id: ConnectionId,
    ) {
        let mut accepted: bool = false;

        if self.outbound_connections.contains_key(&peer) {
            debug!("Peer {peer} is already an outbound connection");

            accepted = true;
        } else if self.inbound_connections.contains_key(&peer) {
            debug!("Peer {peer} is already an inbound connection");

            accepted = true;
        } else if self.inbound_connections.len() < self.config.num_inbound_peers {
            debug!("Upgrading connection {connection_id} of peer {peer} to inbound connection");

            self.inbound_connections.insert(peer, connection_id);
            accepted = true;
        } else {
            debug!("Rejecting connection upgrade of peer {peer} to inbound connection as the limit is reached");
        }

        self.update_connections_metrics();

        if swarm
            .behaviour_mut()
            .send_response(channel, behaviour::Response::Connect(accepted))
            .is_err()
        {
            error!("Error sending connect response to {peer}");
        } else {
            trace!("Sent connect response to {peer}");
        }
    }

    pub(crate) fn handle_connect_response(
        &mut self,
        swarm: &mut Swarm<C>,
        request_id: OutboundRequestId,
        peer: PeerId,
        connection_id: ConnectionId,
        accepted: bool,
    ) {
        self.controller
            .connect_request
            .remove_in_progress(&request_id);

        if accepted {
            debug!("Successfully upgraded connection {connection_id} of peer {peer} to outbound connection");

            if let Some(out_conn) = self.outbound_connections.get_mut(&peer) {
                out_conn.is_persistent = true;
                // Update connection data with the correct connection id.
                out_conn.connection_id = Some(connection_id);
            }

            // if all outbound connections are persistent, discovery is done
            if self
                .outbound_connections
                .values()
                .all(|out_conn| out_conn.is_persistent)
            {
                debug!("All outbound connections are persistent");
                self.metrics.initial_discovery_finished();
                self.update_connections_metrics();
            }
        } else {
            debug!("Peer {peer} rejected connection upgrade to outbound connection");

            self.metrics.increment_total_rejected_connect_requests();

            self.handle_connect_rejection(swarm, peer);
        }
    }

    fn handle_connect_rejection(&mut self, swarm: &mut Swarm<C>, peer: PeerId) {
        self.outbound_connections.remove(&peer);

        if self.is_enabled() {
            self.repair_outbound_connection(swarm);
        }
    }

    pub(crate) fn handle_failed_connect_request(
        &mut self,
        swarm: &mut Swarm<C>,
        request_id: OutboundRequestId,
    ) {
        if let Some(mut request_data) = self
            .controller
            .connect_request
            .remove_in_progress(&request_id)
        {
            if request_data.retry.count() < self.config.connect_request_max_retries {
                // Retry request after a delay
                request_data.retry.inc_count();

                self.controller
                    .connect_request
                    .add_to_queue(request_data.clone(), Some(request_data.retry.next_delay()));
            } else {
                // No more trials left
                error!(
                    "Failed to send connect request to {0} after {1} trials",
                    request_data.peer_id(),
                    request_data.retry.count(),
                );

                self.metrics.increment_total_failed_connect_requests();

                self.handle_connect_rejection(swarm, request_data.peer_id());
            }
        }
    }
}

```
---
### `discovery/src/handlers/dial.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use libp2p::{core::ConnectedPoint, swarm::ConnectionId, PeerId, Swarm};
use tracing::{debug, error};

use crate::{connection::ConnectionData, controller::PeerData, Discovery, DiscoveryClient};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub fn can_dial(&self) -> bool {
        self.controller.dial.can_perform()
    }

    fn should_dial(
        &self,
        swarm: &Swarm<C>,
        connection_data: &ConnectionData,
        check_already_dialed: bool,
    ) -> bool {
        connection_data.peer_id().as_ref().is_none_or(|id| {
            // Is not itself (peer id)
            id != swarm.local_peer_id()
            // Is not already connected
            && !swarm.is_connected(id)
        })
            // Has not already dialed, or has dialed but retries are allowed
            && (!check_already_dialed || !self.controller.dial_is_done_on(connection_data) || connection_data.retry.count() != 0)
            // Is not itself (multiaddr)
            && !swarm.listeners().any(|addr| *addr == connection_data.multiaddr())
    }

    pub fn dial_peer(&mut self, swarm: &mut Swarm<C>, connection_data: ConnectionData) {
        // Not checking if the peer was already dialed because it is done when
        // adding to the dial queue
        if !self.should_dial(swarm, &connection_data, false) {
            return;
        }

        let dial_opts = connection_data.build_dial_opts();
        let connection_id = dial_opts.connection_id();

        self.controller.dial_register_done_on(&connection_data);

        self.controller
            .dial
            .register_in_progress(connection_id, connection_data.clone());

        // Do not count retries as new interactions
        if connection_data.retry.count() == 0 {
            self.metrics.increment_total_dials();
        }

        debug!(
            "Dialing peer at {}, retry #{}",
            connection_data.multiaddr(),
            connection_data.retry.count()
        );

        if let Err(e) = swarm.dial(dial_opts) {
            if let Some(peer_id) = connection_data.peer_id() {
                error!(
                    "Error dialing peer {} at {}: {}",
                    peer_id,
                    connection_data.multiaddr(),
                    e
                );
            } else {
                error!(
                    "Error dialing peer at {}: {}",
                    connection_data.multiaddr(),
                    e
                );
            }

            self.handle_failed_connection(swarm, connection_id);
        }
    }

    pub fn handle_connection(
        &mut self,
        swarm: &mut Swarm<C>,
        peer_id: PeerId,
        connection_id: ConnectionId,
        endpoint: ConnectedPoint,
    ) {
        match endpoint {
            ConnectedPoint::Dialer { .. } => {
                debug!(peer = %peer_id, %connection_id, "Connected to peer");
            }
            ConnectedPoint::Listener { .. } => {
                debug!(peer = %peer_id, %connection_id, "Accepted incoming connection from peer");
            }
        }

        // Needed in case the peer was dialed without knowing the peer id
        self.controller
            .dial
            .register_done_on(PeerData::PeerId(peer_id));

        // This check is necessary to handle the case where two
        // nodes dial each other at the same time, which can lead
        // to a connection established (dialer) event for one node
        // after the connection established (listener) event on the
        // same node. Hence it is possible that the peer was already
        // added to the active connections.
        if self.active_connections.contains_key(&peer_id) {
            self.controller.dial.remove_in_progress(&connection_id);
            // Trigger potential extension step
            self.make_extension_step(swarm);
            return;
        }

        // Needed in case the peer was dialed without knowing the peer id
        self.controller
            .dial_add_peer_id_to_connection_data(connection_id, peer_id);
    }

    pub fn handle_failed_connection(&mut self, swarm: &mut Swarm<C>, connection_id: ConnectionId) {
        if let Some(mut connection_data) = self.controller.dial.remove_in_progress(&connection_id) {
            if connection_data.retry.count() < self.config.dial_max_retries {
                // Retry dialing after a delay
                connection_data.retry.inc_count();

                let next_delay = connection_data.retry.next_delay();

                self.controller
                    .dial
                    .add_to_queue(connection_data.clone(), Some(next_delay));
            } else {
                // No more trials left
                error!(
                    "Failed to dial peer at {0} after {1} trials",
                    connection_data.multiaddr(),
                    connection_data.retry.count(),
                );

                self.metrics.increment_total_failed_dials();

                self.make_extension_step(swarm);
            }
        }
    }

    pub(crate) fn add_to_dial_queue(&mut self, swarm: &Swarm<C>, connection_data: ConnectionData) {
        if self.should_dial(swarm, &connection_data, true) {
            // Already register as dialed address to avoid flooding the dial queue
            // with the same dial attempts.
            self.controller.dial_register_done_on(&connection_data);

            self.controller.dial.add_to_queue(connection_data, None);
        }
    }

    pub fn dial_bootstrap_nodes(&mut self, swarm: &Swarm<C>) {
        for (peer_id, addr) in &self.bootstrap_nodes.clone() {
            self.add_to_dial_queue(swarm, ConnectionData::new(*peer_id, addr.clone()));
        }
    }
}

```
---
### `discovery/src/handlers/extension.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use libp2p::{PeerId, Swarm};
use tracing::{debug, info, warn};

use crate::{request::RequestData, Discovery, DiscoveryClient, State};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    fn get_next_peer_to_peers_request(&self) -> Option<PeerId> {
        self.discovered_peers
            .iter()
            .find(|(peer_id, _)| !self.controller.peers_request.is_done_on(peer_id))
            .map(|(peer_id, _)| *peer_id)
    }

    pub(crate) fn initiate_extension_with_target(&mut self, swarm: &mut Swarm<C>, target: usize) {
        if let State::Extending(curr_target) = self.state {
            debug!(
                "Updating extension target from {} to {}",
                curr_target,
                curr_target + target
            );
            self.state = State::Extending(curr_target + target);

            return;
        }

        debug!(
            "Initiating discovery extension with a target of {} peers",
            target
        );
        self.state = State::Extending(target);
        self.make_extension_step(swarm); // trigger extension
    }

    pub(crate) fn make_extension_step(&mut self, swarm: &mut Swarm<C>) {
        if !self.is_enabled() {
            return;
        }

        let target = match self.state {
            State::Extending(target) => target,
            _ => {
                // Not in extending state
                return;
            }
        };

        let (is_idle, pending_connections_len, pending_peers_requests_len) =
            self.controller.is_idle();
        let rx_dial_len = self.controller.dial.queue_len();
        let rx_peers_request_len = self.controller.peers_request.queue_len();

        if is_idle && rx_dial_len == 0 && rx_peers_request_len == 0 {
            // Done when we found enough peers to which we did not request persistent connection yet
            // to potentially upgrade them to outbound connections we are missing.
            if self
                .active_connections
                .iter()
                .filter(|(peer_id, _)| !self.controller.connect_request.is_done_on(peer_id))
                .count()
                < target
            {
                if let Some(peer_id) = self.get_next_peer_to_peers_request() {
                    debug!(
                        "Discovery extension in progress ({}ms), requesting peers from peer {}",
                        self.metrics.elapsed().as_millis(),
                        peer_id
                    );

                    self.controller
                        .peers_request
                        .add_to_queue(RequestData::new(peer_id), None);

                    return;
                } else {
                    warn!("No more peers to request peers from");
                }
            }

            info!("Discovery extension done");
            info!(
                "Discovery found {} peers (expected {}) in {}ms",
                self.discovered_peers.len(),
                self.config.num_outbound_peers,
                self.metrics.elapsed().as_millis()
            );

            self.adjust_connections(swarm);

            self.state = State::Idle;
        } else {
            debug!("Discovery extension in progress ({}ms), {} pending connections ({} in queue), {} pending requests ({} in queue)",
                self.metrics.elapsed().as_millis(),
                pending_connections_len,
                rx_dial_len,
                pending_peers_requests_len,
                rx_peers_request_len,
            );
        }
    }
}

```
---
### `discovery/src/handlers/helpers.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use tracing::info;

use crate::{Discovery, DiscoveryClient};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    fn active_connections_num_duplicates(&self) -> usize {
        self.active_connections
            .values()
            .map(|ids| ids.len() - 1)
            .sum()
    }

    pub(crate) fn update_connections_metrics(&mut self) {
        let num_inbound_connections = self.inbound_connections.len();
        let num_active_connections = self.active_connections_len();
        let num_outbound_connections = self.outbound_connections.len();
        let num_ephemeral_connections = num_active_connections
            .saturating_sub(num_outbound_connections + num_inbound_connections);

        if !self.is_enabled() {
            info!("Connections: {}", num_inbound_connections);
        } else {
            info!(
                "Active connections: {} (duplicates: {}), Outbound connections: {}, Inbound connections: {}, Ephemeral connections: {}",
                num_active_connections,
                self.active_connections_num_duplicates(),
                num_outbound_connections,
                num_inbound_connections,
                num_ephemeral_connections,
            );
        }

        self.metrics.set_connections_status(
            num_active_connections,
            num_outbound_connections,
            num_inbound_connections,
            num_ephemeral_connections,
        );
    }
}

```
---
### `discovery/src/handlers/identify.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use libp2p::{identify, swarm::ConnectionId, PeerId, Swarm};
use tracing::{debug, info, warn};

use crate::config::BootstrapProtocol;
use crate::{request::RequestData, Discovery, DiscoveryClient, OutboundConnection, State};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub fn handle_new_peer(
        &mut self,
        swarm: &mut Swarm<C>,
        connection_id: ConnectionId,
        peer_id: PeerId,
        info: identify::Info,
    ) {
        // Ignore identify intervals
        if self
            .active_connections
            .get(&peer_id)
            .is_some_and(|connections| connections.contains(&connection_id))
        {
            return;
        }

        if self
            .controller
            .dial
            .remove_in_progress(&connection_id)
            .is_none()
        {
            // Remove any matching in progress connections to avoid dangling data
            self.controller
                .dial_remove_matching_in_progress_connections(&peer_id);
        }

        match self.discovered_peers.insert(peer_id, info.clone()) {
            Some(_) => {
                info!(peer = %peer_id, "New connection from known peer");
            }
            None => {
                info!(peer = %peer_id, "Discovered peer");

                self.metrics.increment_total_discovered();

                // If the address belongs to a bootstrap node, save the peer id
                if let Some(bootstrap_node) = self
                    .bootstrap_nodes
                    .iter_mut()
                    .find(|(_, addr)| addr == info.listen_addrs.first().unwrap())
                {
                    *bootstrap_node = (Some(peer_id), info.listen_addrs.first().unwrap().clone());
                }
            }
        }

        if let Some(connection_ids) = self.active_connections.get_mut(&peer_id) {
            debug!(
                "Additional connection {connection_id} to peer {peer_id}, total connections: {}",
                connection_ids.len() + 1
            );

            connection_ids.push(connection_id);
        } else {
            self.active_connections.insert(peer_id, vec![connection_id]);
        }

        if self.is_enabled() {
            if self
                .outbound_connections
                .get(&peer_id)
                .is_some_and(|out_conn| out_conn.connection_id.is_none())
            {
                // This case happens when the peer was selected to be part of the outbound connections
                // but no connection was established yet. No need to trigger a connect request, it
                // was already done during the selection process.
                debug!(
                    peer = %peer_id, %connection_id,
                    "Connection is outbound (pending connect request)"
                );

                if let Some(out_conn) = self.outbound_connections.get_mut(&peer_id) {
                    out_conn.connection_id = Some(connection_id);
                }
            } else if self.state == State::Idle
                && self.outbound_connections.len() < self.config.num_outbound_peers
                // Not already an outbound connection
                && !self.outbound_connections.contains_key(&peer_id)
            {
                // If the initial discovery process is done and did not find enough peers,
                // the connection is outbound, otherwise it is ephemeral, except if later
                // the connection is requested to be persistent (inbound).
                debug!(
                    peer = %peer_id, %connection_id,
                    "Connection is outbound (incomplete initial discovery)"
                );

                self.outbound_connections.insert(
                    peer_id,
                    OutboundConnection {
                        connection_id: None, // Will be set once the response is received
                        is_persistent: false,
                    },
                );

                self.controller
                    .connect_request
                    .add_to_queue(RequestData::new(peer_id), None);

                if self.outbound_connections.len() >= self.config.num_outbound_peers {
                    debug!(
                        count = self.outbound_connections.len(),
                        "Minimum number of peers reached"
                    );
                }
            } else {
                debug!(peer = %peer_id, %connection_id, "Connection is ephemeral");

                self.controller.close.add_to_queue(
                    (peer_id, connection_id),
                    Some(self.config.ephemeral_connection_timeout),
                );

                // Check if the re-extension dials are done
                if let State::Extending(_) = self.state {
                    self.make_extension_step(swarm);
                }
            }
            // Add the address to the Kademlia routing table
            if self.config.bootstrap_protocol == BootstrapProtocol::Kademlia {
                swarm
                    .behaviour_mut()
                    .add_address(&peer_id, info.listen_addrs.first().unwrap().clone());
            }
        } else {
            // If discovery is disabled, all connections are inbound. The
            // maximum number of inbound connections is enforced by the
            // corresponding parameter in the configuration.
            if self.inbound_connections.len() < self.config.num_inbound_peers {
                debug!(peer = %peer_id, %connection_id, "Connection is inbound");

                self.inbound_connections.insert(peer_id, connection_id);
            } else {
                warn!(peer = %peer_id, %connection_id, "Connections limit reached, refusing connection");

                self.controller
                    .close
                    .add_to_queue((peer_id, connection_id), None);
            }
        }

        self.update_connections_metrics();
    }
}

```
---
### `discovery/src/handlers/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod selection;

pub mod bootstrap;
pub mod close;
pub mod connect_request;
pub mod dial;
pub mod extension;
pub mod helpers;
pub mod identify;
pub mod peers_management;
pub mod peers_request;

```
---
### `discovery/src/handlers/peers_management.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use libp2p::{swarm::ConnectionId, PeerId, Swarm};
use tracing::{debug, warn};

use crate::{request::RequestData, Discovery, DiscoveryClient, OutboundConnection};

use super::selection::selector::Selection;

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    fn select_outbound_connections(&mut self, swarm: &mut Swarm<C>) {
        let n = self
            .config
            .num_outbound_peers
            .saturating_sub(self.outbound_connections.len());

        let peers = match self.selector.try_select_n_outbound_candidates(
            swarm,
            &self.discovered_peers,
            self.get_excluded_peers(),
            n,
        ) {
            Selection::Exactly(peers) => {
                debug!("Selected exactly {} outbound candidates", peers.len());
                peers
            }
            Selection::Only(peers) => {
                warn!("Selected only {} outbound candidates", peers.len());
                peers
            }
            Selection::None => {
                warn!("No outbound candidates available");
                return;
            }
        };

        for peer_id in peers {
            self.outbound_connections.insert(
                peer_id,
                OutboundConnection {
                    connection_id: None, // Will be set once the response is received
                    is_persistent: false,
                },
            );

            self.controller
                .connect_request
                .add_to_queue(RequestData::new(peer_id), None);
        }

        // Safety check: make sure that the inbound connections are not part of the outbound connections
        self.inbound_connections.retain(|peer_id, connection_id| {
            self.outbound_connections
                .get(peer_id)
                .is_none_or(|out_conn| out_conn.connection_id != Some(*connection_id))
        });
    }

    pub(crate) fn adjust_connections(&mut self, swarm: &mut Swarm<C>) {
        if !self.is_enabled() {
            return;
        }

        debug!("Adjusting connections");

        self.select_outbound_connections(swarm);

        let connections_to_close: Vec<(PeerId, ConnectionId)> = self
            .active_connections
            .iter()
            .flat_map(|(peer_id, connection_ids)| {
                connection_ids
                    .iter()
                    .map(|connection_id| (*peer_id, *connection_id))
            })
            // Remove inbound connections
            .filter(|(peer_id, connection_id)| {
                self.inbound_connections
                    .get(peer_id)
                    .is_none_or(|in_conn_id| *in_conn_id != *connection_id)
            })
            // Remove outbound connections
            .filter(|(peer_id, connection_id)| {
                self.outbound_connections
                    .get(peer_id)
                    .is_none_or(|out_conn| out_conn.connection_id != Some(*connection_id))
            })
            .collect();

        debug!(
            "Connections adjusted by disconnecting {} peers",
            connections_to_close.len(),
        );

        for (peer_id, connection_id) in connections_to_close {
            self.controller.close.add_to_queue(
                (peer_id, connection_id),
                Some(self.config.ephemeral_connection_timeout),
            );
        }
    }

    pub(crate) fn repair_outbound_connection(&mut self, swarm: &mut Swarm<C>) {
        if !self.is_enabled() || self.outbound_connections.len() >= self.config.num_outbound_peers {
            return;
        }

        debug!("Repairing an outbound connection");

        // Upgrade any inbound connection to outbound if any is available
        if let Some((peer_id, connection_id)) = self
            .inbound_connections
            .iter()
            // Do not select inbound connections whose peer id is already in the outbound connections
            // with another connection id
            .find(|(peer_id, _)| !self.outbound_connections.contains_key(peer_id))
            .map(|(peer_id, connection_id)| (*peer_id, *connection_id))
        {
            debug!("Upgrading connection {connection_id} of peer {peer_id} to outbound connection");

            self.inbound_connections.remove(&peer_id);
            self.outbound_connections.insert(
                peer_id,
                OutboundConnection {
                    connection_id: None, // Will be set once the response is received
                    is_persistent: true, // persistent connection already established
                },
            );

            // Consider the connect request as done
            self.controller.connect_request.register_done_on(peer_id);

            self.update_connections_metrics();

            return;
        }

        // If no inbound connection is available, then select a candidate
        match self.selector.try_select_n_outbound_candidates(
            swarm,
            &self.discovered_peers,
            self.get_excluded_peers(),
            1,
        ) {
            Selection::Exactly(peers) => {
                if let Some(peer_id) = peers.first() {
                    debug!("Trying to connect to peer {peer_id} to repair outbound connections");
                    self.outbound_connections.insert(
                        *peer_id,
                        OutboundConnection {
                            connection_id: None, // Will be set once the response is received
                            is_persistent: false,
                        },
                    );

                    self.controller
                        .connect_request
                        .add_to_queue(RequestData::new(*peer_id), None);
                }
            }
            _ => {
                // If no candidate is available, then trigger the discovery extension
                warn!("No available peers to repair outbound connections");

                self.initiate_extension_with_target(swarm, 1);
            }
        }
    }
}

```
---
### `discovery/src/handlers/peers_request.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use std::collections::HashSet;

use libp2p::{
    request_response::{OutboundRequestId, ResponseChannel},
    Multiaddr, PeerId, Swarm,
};
use tracing::{debug, error, trace};

use crate::{
    behaviour::{self, Response},
    connection::ConnectionData,
    request::RequestData,
    Discovery, DiscoveryClient,
};

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub fn can_peers_request(&self) -> bool {
        self.controller.peers_request.can_perform()
    }

    fn should_peers_request(&self, request_data: &RequestData) -> bool {
        // Has not already requested, or has requested but retries are allowed
        !self
            .controller
            .peers_request
            .is_done_on(&request_data.peer_id())
            || request_data.retry.count() != 0
    }

    pub fn peers_request_peer(&mut self, swarm: &mut Swarm<C>, request_data: RequestData) {
        if !self.is_enabled() || !self.should_peers_request(&request_data) {
            return;
        }

        self.controller
            .peers_request
            .register_done_on(request_data.peer_id());

        // Do not count retries as new interactions
        if request_data.retry.count() == 0 {
            self.metrics.increment_total_peer_requests();
        }

        debug!(
            "Requesting peers from peer {}, retry #{}",
            request_data.peer_id(),
            request_data.retry.count()
        );

        let request_id = swarm.behaviour_mut().send_request(
            &request_data.peer_id(),
            behaviour::Request::Peers(self.get_all_peers_except(request_data.peer_id())),
        );

        self.controller
            .peers_request
            .register_in_progress(request_id, request_data);
    }

    pub(crate) fn handle_peers_request(
        &mut self,
        swarm: &mut Swarm<C>,
        peer: PeerId,
        channel: ResponseChannel<Response>,
        peers: HashSet<(Option<PeerId>, Multiaddr)>,
    ) {
        // Compute the difference between the discovered peers and the requested peers
        // to avoid sending the requesting peer the peers it already knows.
        let peers_difference = self
            .get_all_peers_except(peer)
            .difference(&peers)
            .cloned()
            .collect();

        if swarm
            .behaviour_mut()
            .send_response(channel, behaviour::Response::Peers(peers_difference))
            .is_err()
        {
            error!("Error sending peers to {peer}");
        } else {
            trace!("Sent peers to {peer}");
        }
    }

    pub(crate) fn handle_peers_response(
        &mut self,
        swarm: &mut Swarm<C>,
        request_id: OutboundRequestId,
        peers: HashSet<(Option<PeerId>, Multiaddr)>,
    ) {
        self.controller
            .peers_request
            .remove_in_progress(&request_id);

        self.process_received_peers(swarm, peers);

        self.make_extension_step(swarm);
    }

    pub(crate) fn handle_failed_peers_request(
        &mut self,
        swarm: &mut Swarm<C>,
        request_id: OutboundRequestId,
    ) {
        if let Some(mut request_data) = self
            .controller
            .peers_request
            .remove_in_progress(&request_id)
        {
            if request_data.retry.count() < self.config.request_max_retries {
                // Retry request after a delay
                request_data.retry.inc_count();

                self.controller
                    .peers_request
                    .add_to_queue(request_data.clone(), Some(request_data.retry.next_delay()));
            } else {
                // No more trials left
                error!(
                    "Failed to send peers request to {0} after {1} trials",
                    request_data.peer_id(),
                    request_data.retry.count(),
                );

                self.metrics.increment_total_failed_peer_requests();

                self.make_extension_step(swarm);
            }
        }
    }

    fn process_received_peers(
        &mut self,
        swarm: &mut Swarm<C>,
        peers: HashSet<(Option<PeerId>, Multiaddr)>,
    ) {
        for (peer_id, listen_addr) in peers {
            self.add_to_dial_queue(swarm, ConnectionData::new(peer_id, listen_addr));
        }
    }

    /// Returns all discovered peers, including bootstrap nodes, except the given peer.
    fn get_all_peers_except(&self, peer: PeerId) -> HashSet<(Option<PeerId>, Multiaddr)> {
        let mut remaining_bootstrap_nodes: Vec<_> = self.bootstrap_nodes.clone();

        let mut peers: HashSet<(Option<PeerId>, Multiaddr)> = self
            .discovered_peers
            .iter()
            .filter_map(|(peer_id, info)| {
                if let Some(addr) = info.listen_addrs.first() {
                    remaining_bootstrap_nodes.retain(|(_, x)| x != addr);

                    if peer_id == &peer {
                        return None;
                    }

                    Some((Some(*peer_id), addr.clone()))
                } else {
                    None
                }
            })
            .collect();

        for (peer_id, addr) in remaining_bootstrap_nodes {
            peers.insert((peer_id, addr));
        }

        peers
    }
}

```
---
### `discovery/src/handlers/selection/kademlia.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::collections::HashMap;

use libp2p::{identify, PeerId, Swarm};
use rand::seq::SliceRandom;
use tracing::{debug, warn};

use crate::DiscoveryClient;

use super::selector::{Selection, Selector};

#[derive(Debug)]
pub struct KademliaSelector {}

impl KademliaSelector {
    pub fn new() -> Self {
        KademliaSelector {}
    }

    fn kbuckets(&self, swarm: &mut Swarm<impl DiscoveryClient>) -> Vec<(u32, Vec<PeerId>)> {
        let mut kbuckets: Vec<(u32, Vec<PeerId>)> = Vec::new();

        for kbucket in swarm.behaviour_mut().kbuckets() {
            let peers = kbucket
                .iter()
                .map(|entry| *entry.node.key.preimage())
                .collect();
            let index = kbucket.range().0.ilog2().unwrap_or(0);
            kbuckets.push((index, peers));
        }

        kbuckets
    }
}

impl<C> Selector<C> for KademliaSelector
where
    C: DiscoveryClient,
{
    fn try_select_n_outbound_candidates(
        &mut self,
        swarm: &mut Swarm<C>,
        discovered: &HashMap<PeerId, identify::Info>,
        excluded: Vec<PeerId>,
        n: usize,
    ) -> Selection<PeerId> {
        if n == 0 {
            return Selection::None;
        }

        let mut candidates: Vec<PeerId> = Vec::new();

        let kbuckets_candidates: Vec<(u32, Vec<PeerId>)> = self
            .kbuckets(swarm)
            .into_iter()
            .map(|(index, peers)| {
                let filtered_peers = peers
                    .into_iter()
                    .filter(|peer_id| !excluded.contains(peer_id))
                    .collect();
                (index, filtered_peers)
            })
            .collect();

        if n < kbuckets_candidates.len() {
            warn!(
                "More kbuckets ({}) than the requested selection size ({})",
                kbuckets_candidates.len(),
                n
            );
        }

        let total_kbuckets_candidates: usize = kbuckets_candidates
            .iter()
            .map(|(_, peers)| peers.len())
            .sum();

        if total_kbuckets_candidates < n {
            for (_, peers) in &kbuckets_candidates {
                candidates.extend(peers.iter());
            }
        } else {
            // Select candidates in round-robin fashion based on kbucket index in reverse order
            for (_, peers) in kbuckets_candidates.iter().rev().cycle() {
                if candidates.len() >= n {
                    break;
                }
                if let Some(peer_id) = peers.iter().find(|peer_id| !candidates.contains(peer_id)) {
                    candidates.push(*peer_id);
                }
            }

            return Selection::Exactly(candidates);
        }

        debug!("Not enough peers in kbuckets, completing with random discovered peers");

        let mut rng = rand::thread_rng();
        let remaining = n - candidates.len();

        if discovered.len() < remaining {
            candidates.extend(discovered.keys().cloned());

            if candidates.is_empty() {
                return Selection::None;
            }
            return Selection::Only(candidates);
        }

        candidates.extend(
            discovered
                .keys()
                .filter(|peer_id| !candidates.contains(peer_id))
                .filter(|peer_id| !excluded.contains(peer_id))
                .cloned()
                .collect::<Vec<PeerId>>()
                .choose_multiple(&mut rng, remaining),
        );

        Selection::Exactly(candidates)
    }
}

```
---
### `discovery/src/handlers/selection/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod kademlia;
pub mod random;
pub mod selector;

```
---
### `discovery/src/handlers/selection/random.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::collections::HashMap;

use libp2p::{identify, PeerId, Swarm};
use rand::seq::SliceRandom;

use crate::DiscoveryClient;

use super::selector::{Selection, Selector};

#[derive(Debug)]
pub struct RandomSelector {}

impl RandomSelector {
    pub fn new() -> Self {
        RandomSelector {}
    }
}

impl<C> Selector<C> for RandomSelector
where
    C: DiscoveryClient,
{
    fn try_select_n_outbound_candidates(
        &mut self,
        _swarm: &mut Swarm<C>,
        discovered: &HashMap<PeerId, identify::Info>,
        excluded: Vec<PeerId>,
        n: usize,
    ) -> Selection<PeerId> {
        if n == 0 {
            return Selection::None;
        }

        let mut discovered_candidates: Vec<PeerId> = discovered
            .keys()
            .filter(|peer_id| !excluded.contains(peer_id))
            .cloned()
            .collect();

        let mut rng = rand::thread_rng();
        discovered_candidates.shuffle(&mut rng);

        let candidates: Vec<PeerId> = discovered_candidates.into_iter().take(n).collect();

        match candidates.len() {
            0 => Selection::None,
            len if len < n => Selection::Only(candidates),
            _ => Selection::Exactly(candidates),
        }
    }
}

```
---
### `discovery/src/handlers/selection/selector.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::{collections::HashMap, fmt::Debug};

use libp2p::{identify, PeerId, Swarm};
use tracing::info;

use crate::config;
use crate::{Discovery, DiscoveryClient};

use super::kademlia::KademliaSelector;
use super::random::RandomSelector;

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub(crate) fn get_selector(
        is_enabled: bool,
        bootstrap_protocol: config::BootstrapProtocol,
        selector: config::Selector,
    ) -> Box<dyn Selector<C>> {
        if !is_enabled {
            return Box::new(RandomSelector::new());
        }

        match selector {
            config::Selector::Kademlia => {
                if bootstrap_protocol != config::BootstrapProtocol::Kademlia {
                    panic!(
                        "Kademlia selector is only available with the Kademlia bootstrap protocol"
                    );
                }

                info!("Using Kademlia selector");
                Box::new(KademliaSelector::new())
            }

            config::Selector::Random => {
                info!("Using Random selector");
                Box::new(RandomSelector::new())
            }
        }
    }

    /// Excluded peers are those that are already outbound connections or have already
    /// been requested to be so.
    pub(crate) fn get_excluded_peers(&self) -> Vec<PeerId> {
        self.discovered_peers
            .keys()
            .filter(|peer_id| {
                self.outbound_connections.contains_key(peer_id)
                    || self.controller.connect_request.is_done_on(peer_id)
            })
            .cloned()
            .collect()
    }
}

pub enum Selection<T> {
    Exactly(Vec<T>),
    Only(Vec<T>),
    None,
}

pub trait Selector<C>: Debug + Send
where
    C: DiscoveryClient,
{
    /// Try to select `n` valid outbound candidates. It might return less than `n`
    ///  candidates if there are not enough valid peers.
    fn try_select_n_outbound_candidates(
        &mut self,
        swarm: &mut Swarm<C>,
        discovered: &HashMap<PeerId, identify::Info>,
        excluded: Vec<PeerId>,
        n: usize,
    ) -> Selection<PeerId>;
}

```
---
### `discovery/src/lib.rs`
*2025-05-18 23:58:49 | 8 KB*
```rust
use std::collections::HashMap;

use tracing::{debug, error, info, warn};

use malachitebft_metrics::Registry;

use libp2p::{identify, kad, request_response, swarm::ConnectionId, Multiaddr, PeerId, Swarm};

mod util;

mod behaviour;
pub use behaviour::*;

mod connection;
use connection::ConnectionData;

pub mod config;
pub use config::Config;

mod controller;
use controller::Controller;

mod handlers;
use handlers::selection::selector::Selector;

mod metrics;
use metrics::Metrics;

mod request;

#[derive(Debug, PartialEq)]
enum State {
    Bootstrapping,
    Extending(usize), // Target number of peers
    Idle,
}

// The usage of `OutboundConnection` is to keep track of the persistent connection status
// of a peer with its connection id. The connection id is an option as one can try to upgrade
// a connection that does not exist yet (hence, no connection id exists yet).
#[derive(Debug)]
struct OutboundConnection {
    connection_id: Option<ConnectionId>,
    is_persistent: bool,
}

#[derive(Debug)]
pub struct Discovery<C>
where
    C: DiscoveryClient,
{
    config: Config,
    state: State,

    selector: Box<dyn Selector<C>>,

    bootstrap_nodes: Vec<(Option<PeerId>, Multiaddr)>,
    discovered_peers: HashMap<PeerId, identify::Info>,
    active_connections: HashMap<PeerId, Vec<ConnectionId>>,
    outbound_connections: HashMap<PeerId, OutboundConnection>,
    inbound_connections: HashMap<PeerId, ConnectionId>,

    pub controller: Controller,
    metrics: Metrics,
}

impl<C> Discovery<C>
where
    C: DiscoveryClient,
{
    pub fn new(config: Config, bootstrap_nodes: Vec<Multiaddr>, registry: &mut Registry) -> Self {
        info!(
            "Discovery is {}",
            if config.enabled {
                "enabled"
            } else {
                "disabled"
            }
        );

        let state = if config.enabled && bootstrap_nodes.is_empty() {
            warn!("No bootstrap nodes provided");
            info!("Discovery found 0 peers in 0ms");
            State::Idle
        } else if config.enabled {
            match config.bootstrap_protocol {
                config::BootstrapProtocol::Kademlia => {
                    debug!("Using Kademlia bootstrap");

                    State::Bootstrapping
                }

                config::BootstrapProtocol::Full => {
                    debug!("Using full bootstrap");

                    State::Extending(config.num_outbound_peers)
                }
            }
        } else {
            State::Idle
        };

        Self {
            config,
            state,

            selector: Discovery::get_selector(
                config.enabled,
                config.bootstrap_protocol,
                config.selector,
            ),

            bootstrap_nodes: bootstrap_nodes
                .clone()
                .into_iter()
                .map(|addr| (None, addr))
                .collect(),
            discovered_peers: HashMap::new(),
            active_connections: HashMap::new(),
            outbound_connections: HashMap::new(),
            inbound_connections: HashMap::new(),

            controller: Controller::new(),
            metrics: Metrics::new(registry, !config.enabled || bootstrap_nodes.is_empty()),
        }
    }

    pub fn is_enabled(&self) -> bool {
        self.config.enabled
    }

    fn active_connections_len(&self) -> usize {
        self.active_connections.values().map(Vec::len).sum()
    }

    pub fn on_network_event(
        &mut self,
        swarm: &mut Swarm<C>,
        network_event: behaviour::NetworkEvent,
    ) {
        match network_event {
            behaviour::NetworkEvent::Kademlia(kad::Event::OutboundQueryProgressed {
                result,
                step,
                ..
            }) => match result {
                kad::QueryResult::Bootstrap(Ok(_)) => {
                    if step.last && self.state == State::Bootstrapping {
                        debug!("Discovery bootstrap successful");

                        self.handle_successful_bootstrap(swarm);
                    }
                }

                kad::QueryResult::Bootstrap(Err(error)) => {
                    error!("Discovery bootstrap failed: {error}");

                    if self.state == State::Bootstrapping {
                        self.handle_failed_bootstrap();
                    }
                }

                _ => {}
            },

            behaviour::NetworkEvent::Kademlia(_) => {}

            behaviour::NetworkEvent::RequestResponse(event) => {
                match event {
                    request_response::Event::Message {
                        peer,
                        connection_id,
                        message:
                            request_response::Message::Request {
                                request, channel, ..
                            },
                    } => match request {
                        behaviour::Request::Peers(peers) => {
                            debug!(peer_id = %peer, %connection_id, "Received peers request");

                            self.handle_peers_request(swarm, peer, channel, peers);
                        }

                        behaviour::Request::Connect() => {
                            debug!(peer_id = %peer, %connection_id, "Received connect request");

                            self.handle_connect_request(swarm, channel, peer, connection_id);
                        }
                    },

                    request_response::Event::Message {
                        peer,
                        connection_id,
                        message:
                            request_response::Message::Response {
                                response,
                                request_id,
                                ..
                            },
                    } => match response {
                        behaviour::Response::Peers(peers) => {
                            debug!(%peer, %connection_id, count = peers.len(), "Received peers response");

                            self.handle_peers_response(swarm, request_id, peers);
                        }

                        behaviour::Response::Connect(accepted) => {
                            debug!(%peer, %connection_id, accepted, "Received connect response");

                            self.handle_connect_response(
                                swarm,
                                request_id,
                                peer,
                                connection_id,
                                accepted,
                            );
                        }
                    },

                    request_response::Event::OutboundFailure {
                        peer,
                        request_id,
                        connection_id,
                        error,
                    } => {
                        error!(%peer, %connection_id, "Outbound request to failed: {error}");

                        if self.controller.peers_request.is_in_progress(&request_id) {
                            self.handle_failed_peers_request(swarm, request_id);
                        } else if self.controller.connect_request.is_in_progress(&request_id) {
                            self.handle_failed_connect_request(swarm, request_id);
                        } else {
                            // This should not happen
                            error!(%peer, %connection_id, "Unknown outbound request failure");
                        }
                    }

                    _ => {}
                }
            }
        }
    }
}

```
---
### `discovery/src/metrics.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use std::time::{Duration, Instant};

use malachitebft_metrics::prometheus::metrics::counter::Counter;

use malachitebft_metrics::prometheus::metrics::gauge::Gauge;
use malachitebft_metrics::Registry;

#[derive(Debug)]
pub(crate) struct Metrics {
    /// Time at which discovery started
    start_time: Instant,
    /// Time at which the Kademlia bootstrap process finished
    initial_bootstrap_finished: Option<Instant>,
    /// Time at which initial discovery process finished
    initial_discovery_finished: Option<Instant>,

    /// Total number of discovered peers
    total_discovered: Counter,

    /// Number of active connections
    num_active_connections: Gauge,
    /// Number of outbound connections
    num_outbound_connections: Gauge,
    /// Number of inbound connections
    num_inbound_connections: Gauge,
    /// Number of ephemeral connections
    num_ephemeral_connections: Gauge,

    /// Total number of dial attempts
    total_dials: Counter,
    /// Total number of failed dial attempts
    total_failed_dials: Counter,
    /// Total number of peers request attempts
    total_peer_requests: Counter,
    /// Total number of failed peer request attempts
    total_failed_peer_requests: Counter,
    /// Total number of connect request attempts
    total_connect_requests: Counter,
    /// Total number of failed connect request attempts
    total_failed_connect_requests: Counter,
    /// Total number of rejected connect request attempts
    total_rejected_connect_requests: Counter,
}

impl Metrics {
    pub(crate) fn new(registry: &mut Registry, set_finished: bool) -> Self {
        let now = Instant::now();

        let this = Self {
            start_time: now,
            initial_bootstrap_finished: if set_finished { Some(now) } else { None },
            initial_discovery_finished: if set_finished { Some(now) } else { None },

            total_discovered: Counter::default(),

            num_active_connections: Gauge::default(),
            num_outbound_connections: Gauge::default(),
            num_inbound_connections: Gauge::default(),
            num_ephemeral_connections: Gauge::default(),

            total_dials: Counter::default(),
            total_failed_dials: Counter::default(),
            total_peer_requests: Counter::default(),
            total_failed_peer_requests: Counter::default(),
            total_connect_requests: Counter::default(),
            total_failed_connect_requests: Counter::default(),
            total_rejected_connect_requests: Counter::default(),
        };

        registry.register(
            "total_discovered",
            "Total number of discovered peers",
            this.total_discovered.clone(),
        );

        registry.register(
            "num_active_connections",
            "Number of active connections",
            this.num_active_connections.clone(),
        );

        registry.register(
            "num_outbound_connections",
            "Number of outbound connections",
            this.num_outbound_connections.clone(),
        );

        registry.register(
            "num_inbound_connections",
            "Number of inbound connections",
            this.num_inbound_connections.clone(),
        );

        registry.register(
            "num_ephemeral_connections",
            "Number of ephemeral connections",
            this.num_ephemeral_connections.clone(),
        );

        registry.register(
            "total_dials",
            "Total number of dial attempts",
            this.total_dials.clone(),
        );

        registry.register(
            "total_failed_dials",
            "Total number of failed dial attempts",
            this.total_failed_dials.clone(),
        );

        registry.register(
            "total_peer_requests",
            "Total number of peer request attempts",
            this.total_peer_requests.clone(),
        );

        registry.register(
            "total_failed_peer_requests",
            "Total number of failed peer request attempts",
            this.total_failed_peer_requests.clone(),
        );

        registry.register(
            "total_connect_requests",
            "Total number of connect request attempts",
            this.total_connect_requests.clone(),
        );

        registry.register(
            "total_failed_connect_requests",
            "Total number of failed connect request attempts",
            this.total_failed_connect_requests.clone(),
        );

        registry.register(
            "total_rejected_connect_requests",
            "Total number of rejected connect request attempts",
            this.total_rejected_connect_requests.clone(),
        );

        this
    }

    pub(crate) fn elapsed(&self) -> Duration {
        self.start_time.elapsed()
    }

    pub(crate) fn initial_bootstrap_finished(&mut self) {
        self.initial_bootstrap_finished
            .get_or_insert(Instant::now());
    }

    pub(crate) fn _initial_bootstrap_duration(&self) -> Duration {
        self.initial_bootstrap_finished
            .unwrap_or(self.start_time)
            .duration_since(self.start_time)
    }

    pub(crate) fn initial_discovery_finished(&mut self) {
        self.initial_discovery_finished
            .get_or_insert(Instant::now());
    }

    pub(crate) fn _initial_discovery_duration(&self) -> Duration {
        self.initial_discovery_finished
            .unwrap_or(self.start_time)
            .duration_since(self.start_time)
    }

    pub(crate) fn increment_total_discovered(&self) {
        self.total_discovered.inc();
    }

    pub(crate) fn set_connections_status(
        &self,
        num_active: usize,
        num_outbound: usize,
        num_inbound: usize,
        num_ephemeral: usize,
    ) {
        self.num_active_connections.set(num_active as i64);
        self.num_outbound_connections.set(num_outbound as i64);
        self.num_inbound_connections.set(num_inbound as i64);
        self.num_ephemeral_connections.set(num_ephemeral as i64);
    }

    pub(crate) fn increment_total_dials(&self) {
        self.total_dials.inc();
    }

    pub(crate) fn increment_total_failed_dials(&self) {
        self.total_failed_dials.inc();
    }

    pub(crate) fn increment_total_peer_requests(&self) {
        self.total_peer_requests.inc();
    }

    pub(crate) fn increment_total_failed_peer_requests(&self) {
        self.total_failed_peer_requests.inc();
    }

    pub(crate) fn increment_total_connect_requests(&self) {
        self.total_connect_requests.inc();
    }

    pub(crate) fn increment_total_failed_connect_requests(&self) {
        self.total_failed_connect_requests.inc();
        // A failure is also considered a rejection
        self.total_rejected_connect_requests.inc();
    }

    pub(crate) fn increment_total_rejected_connect_requests(&self) {
        self.total_rejected_connect_requests.inc();
    }

    pub(crate) fn _get_total_rejected_connect_requests(&self) -> u64 {
        self.total_rejected_connect_requests.get()
    }
}

```
---
### `discovery/src/request.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use libp2p::PeerId;

use crate::util::Retry;

#[derive(Debug, Clone)]
pub struct RequestData {
    peer_id: PeerId,
    pub retry: Retry,
}

impl RequestData {
    pub fn new(peer_id: PeerId) -> Self {
        Self {
            peer_id,
            retry: Retry::new(),
        }
    }

    pub fn peer_id(&self) -> PeerId {
        self.peer_id
    }
}

```
---
### `discovery/src/util.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::time::Duration;

#[derive(Debug, Clone)]
struct FibonacciBackoff {
    current: u64,
    next: u64,
}

impl FibonacciBackoff {
    pub fn new() -> Self {
        // Start from 1 second
        Self {
            current: 1000,
            next: 1000,
        }
    }
}

impl Iterator for FibonacciBackoff {
    type Item = Duration;

    fn next(&mut self) -> Option<Self::Item> {
        let new_next = self.current + self.next;
        self.current = self.next;
        self.next = new_next;

        Some(Duration::from_millis(self.current))
    }
}

#[derive(Debug, Clone)]
pub struct Retry {
    count: usize,
    backoff: FibonacciBackoff,
}

impl Retry {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Self {
            count: 0,
            backoff: FibonacciBackoff::new(),
        }
    }

    pub fn count(&self) -> usize {
        self.count
    }

    pub fn inc_count(&mut self) {
        self.count += 1;
    }

    pub fn next_delay(&mut self) -> Duration {
        self.backoff
            .next()
            .expect("FibonacciBackoff is an infinite iterator")
    }
}

```
---
### `engine/Cargo.toml`
*2025-05-18 23:58:49 | 2 KB*
```toml
[package]
name = "informalsystems-malachitebft-engine"
description = "Implementation of the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[lints]
workspace = true

[dependencies]
malachitebft-codec.workspace = true
malachitebft-config.workspace = true
malachitebft-core-consensus.workspace = true
malachitebft-core-types.workspace = true
malachitebft-network.workspace = true
malachitebft-metrics.workspace = true
malachitebft-sync.workspace = true
malachitebft-wal.workspace = true

async-trait = { workspace = true }
async-recursion = { workspace = true }
bytes = { workspace = true, features = ["serde"] }
byteorder = { workspace = true }
derive-where = { workspace = true }
eyre = { workspace = true }
libp2p = { workspace = true }
ractor = { workspace = true }
rand = { workspace = true }
tokio = { workspace = true, features = ["full"] }
tracing = { workspace = true }

```
---
### `engine/src/consensus.rs`
*2025-05-18 23:58:49 | 43 KB*
```rust
use core::fmt;
use std::collections::BTreeSet;
use std::sync::Arc;
use std::time::Duration;

use async_recursion::async_recursion;
use async_trait::async_trait;
use derive_where::derive_where;
use eyre::eyre;
use ractor::{Actor, ActorProcessingErr, ActorRef};
use tokio::time::Instant;
use tracing::{debug, error, error_span, info, warn};

use malachitebft_codec as codec;
use malachitebft_config::TimeoutConfig;
use malachitebft_core_consensus::{
    Effect, LivenessMsg, PeerId, Resumable, Resume, SignedConsensusMsg, VoteExtensionError,
};
use malachitebft_core_types::{
    Context, Proposal, Round, SigningProvider, SigningProviderExt, Timeout, TimeoutKind,
    ValidatorSet, ValueId, ValueOrigin, Vote,
};
use malachitebft_metrics::Metrics;
use malachitebft_sync::{self as sync, ValueResponse};

use crate::host::{HostMsg, HostRef, LocallyProposedValue, ProposedValue};
use crate::network::{NetworkEvent, NetworkMsg, NetworkRef};
use crate::sync::Msg as SyncMsg;
use crate::sync::SyncRef;
use crate::util::events::{Event, TxEvent};
use crate::util::msg_buffer::MessageBuffer;
use crate::util::streaming::StreamMessage;
use crate::util::timers::{TimeoutElapsed, TimerScheduler};
use crate::wal::{Msg as WalMsg, WalEntry, WalRef};

pub use malachitebft_core_consensus::Error as ConsensusError;
pub use malachitebft_core_consensus::Params as ConsensusParams;
pub use malachitebft_core_consensus::State as ConsensusState;

/// Codec for consensus messages.
///
/// This trait is automatically implemented for any type that implements:
/// - [`codec::Codec<Ctx::ProposalPart>`]
/// - [`codec::Codec<SignedConsensusMsg<Ctx>>`]
/// - [`codec::Codec<PolkaCertificate<Ctx>>`]
/// - [`codec::Codec<StreamMessage<Ctx::ProposalPart>>`]
pub trait ConsensusCodec<Ctx>
where
    Ctx: Context,
    Self: codec::Codec<Ctx::ProposalPart>,
    Self: codec::Codec<SignedConsensusMsg<Ctx>>,
    Self: codec::Codec<LivenessMsg<Ctx>>,
    Self: codec::Codec<StreamMessage<Ctx::ProposalPart>>,
{
}

impl<Ctx, Codec> ConsensusCodec<Ctx> for Codec
where
    Ctx: Context,
    Self: codec::Codec<Ctx::ProposalPart>,
    Self: codec::Codec<SignedConsensusMsg<Ctx>>,
    Self: codec::Codec<LivenessMsg<Ctx>>,
    Self: codec::Codec<StreamMessage<Ctx::ProposalPart>>,
{
}

pub type ConsensusRef<Ctx> = ActorRef<Msg<Ctx>>;

pub struct Consensus<Ctx>
where
    Ctx: Context,
{
    ctx: Ctx,
    params: ConsensusParams<Ctx>,
    timeout_config: TimeoutConfig,
    signing_provider: Box<dyn SigningProvider<Ctx>>,
    network: NetworkRef<Ctx>,
    host: HostRef<Ctx>,
    wal: WalRef<Ctx>,
    sync: Option<SyncRef<Ctx>>,
    metrics: Metrics,
    tx_event: TxEvent<Ctx>,
    span: tracing::Span,
}

pub type ConsensusMsg<Ctx> = Msg<Ctx>;

#[derive_where(Debug)]
pub enum Msg<Ctx: Context> {
    /// Start consensus for the given height with the given validator set
    StartHeight(Ctx::Height, Ctx::ValidatorSet),

    /// Received an event from the gossip layer
    NetworkEvent(NetworkEvent<Ctx>),

    /// A timeout has elapsed
    TimeoutElapsed(TimeoutElapsed<Timeout>),

    /// The proposal builder has built a value and can be used in a new proposal consensus message
    ProposeValue(LocallyProposedValue<Ctx>),

    /// Received and assembled the full value proposed by a validator
    ReceivedProposedValue(ProposedValue<Ctx>, ValueOrigin),

    /// Instructs consensus to restart at a given height with the given validator set.
    ///
    /// On this input consensus resets the Write-Ahead Log.
    /// # Warning
    /// This operation should be used with extreme caution as it can lead to safety violations:
    /// 1. The application must clean all state associated with the height for which commit has failed
    /// 2. Since consensus resets its write-ahead log, the node may equivocate on proposals and votes
    ///    for the restarted height, potentially violating protocol safety
    RestartHeight(Ctx::Height, Ctx::ValidatorSet),
}

impl<Ctx: Context> fmt::Display for Msg<Ctx> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Msg::StartHeight(height, _) => write!(f, "StartHeight(height={})", height),
            Msg::NetworkEvent(event) => match event {
                NetworkEvent::Proposal(_, proposal) => write!(
                    f,
                    "NetworkEvent(Proposal height={} round={})",
                    proposal.height(),
                    proposal.round()
                ),
                NetworkEvent::ProposalPart(_, part) => {
                    write!(f, "NetworkEvent(ProposalPart sequence={})", part.sequence)
                }
                NetworkEvent::Vote(_, vote) => write!(
                    f,
                    "NetworkEvent(Vote height={} round={})",
                    vote.height(),
                    vote.round()
                ),
                _ => write!(f, "NetworkEvent"),
            },
            Msg::TimeoutElapsed(timeout) => write!(f, "TimeoutElapsed({})", timeout.display_key()),
            Msg::ProposeValue(value) => write!(
                f,
                "ProposeValue(height={} round={})",
                value.height, value.round
            ),
            Msg::ReceivedProposedValue(value, _) => write!(
                f,
                "ReceivedProposedValue(height={} round={})",
                value.height, value.round
            ),
            Msg::RestartHeight(height, _) => write!(f, "RestartHeight(height={})", height),
        }
    }
}

impl<Ctx: Context> From<NetworkEvent<Ctx>> for Msg<Ctx> {
    fn from(event: NetworkEvent<Ctx>) -> Self {
        Self::NetworkEvent(event)
    }
}

type ConsensusInput<Ctx> = malachitebft_core_consensus::Input<Ctx>;

impl<Ctx: Context> From<TimeoutElapsed<Timeout>> for Msg<Ctx> {
    fn from(msg: TimeoutElapsed<Timeout>) -> Self {
        Msg::TimeoutElapsed(msg)
    }
}

type Timers = TimerScheduler<Timeout>;

struct Timeouts {
    config: TimeoutConfig,
}

impl Timeouts {
    pub fn new(config: TimeoutConfig) -> Self {
        Self { config }
    }

    fn reset(&mut self, config: TimeoutConfig) {
        self.config = config;
    }

    fn duration_for(&self, step: TimeoutKind) -> Duration {
        match step {
            TimeoutKind::Propose => self.config.timeout_propose,
            TimeoutKind::Prevote => self.config.timeout_prevote,
            TimeoutKind::Precommit => self.config.timeout_precommit,
            TimeoutKind::Rebroadcast => {
                self.config.timeout_propose
                    + self.config.timeout_prevote
                    + self.config.timeout_precommit
            }
        }
    }

    fn increase_timeout(&mut self, step: TimeoutKind) {
        let c = &mut self.config;
        match step {
            TimeoutKind::Propose => c.timeout_propose += c.timeout_propose_delta,
            TimeoutKind::Prevote => c.timeout_prevote += c.timeout_prevote_delta,
            TimeoutKind::Precommit => c.timeout_precommit += c.timeout_precommit_delta,
            TimeoutKind::Rebroadcast => {
                c.timeout_rebroadcast +=
                    c.timeout_propose_delta + c.timeout_prevote_delta + c.timeout_precommit_delta
            }
        };
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum Phase {
    Unstarted,
    Ready,
    Running,
    Recovering,
}

/// Maximum number of messages to buffer while consensus is
/// in the `Unstarted` or `Recovering` phase
const MAX_BUFFER_SIZE: usize = 1024;

pub struct State<Ctx: Context> {
    /// Scheduler for timers
    timers: Timers,

    /// Timeouts configuration
    timeouts: Timeouts,

    /// The state of the consensus state machine
    consensus: ConsensusState<Ctx>,

    /// The set of peers we are connected to.
    connected_peers: BTreeSet<PeerId>,

    /// The current phase
    phase: Phase,

    /// A buffer of messages that were received while
    /// consensus was `Unstarted` or in the `Recovering` phase
    msg_buffer: MessageBuffer<Ctx>,
}

impl<Ctx> State<Ctx>
where
    Ctx: Context,
{
    pub fn height(&self) -> Ctx::Height {
        self.consensus.height()
    }

    fn set_phase(&mut self, phase: Phase) {
        if self.phase != phase {
            info!(prev = ?self.phase, new = ?phase, "Phase transition");
            self.phase = phase;
        }
    }
}

struct HandlerState<'a, Ctx: Context> {
    phase: Phase,
    height: Ctx::Height,
    timers: &'a mut Timers,
    timeouts: &'a mut Timeouts,
}

impl<Ctx> Consensus<Ctx>
where
    Ctx: Context,
{
    #[allow(clippy::too_many_arguments)]
    pub async fn spawn(
        ctx: Ctx,
        params: ConsensusParams<Ctx>,
        timeout_config: TimeoutConfig,
        signing_provider: Box<dyn SigningProvider<Ctx>>,
        network: NetworkRef<Ctx>,
        host: HostRef<Ctx>,
        wal: WalRef<Ctx>,
        sync: Option<SyncRef<Ctx>>,
        metrics: Metrics,
        tx_event: TxEvent<Ctx>,
        span: tracing::Span,
    ) -> Result<ActorRef<Msg<Ctx>>, ractor::SpawnErr> {
        let node = Self {
            ctx,
            params,
            timeout_config,
            signing_provider,
            network,
            host,
            wal,
            sync,
            metrics,
            tx_event,
            span,
        };

        let (actor_ref, _) = Actor::spawn(None, node, ()).await?;
        Ok(actor_ref)
    }

    async fn process_input(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
        input: ConsensusInput<Ctx>,
    ) -> Result<(), ConsensusError<Ctx>> {
        let height = state.height();

        malachitebft_core_consensus::process!(
            input: input,
            state: &mut state.consensus,
            metrics: &self.metrics,
            with: effect => {
                let handler_state = HandlerState {
                    phase: state.phase,
                    height,
                    timers: &mut state.timers,
                    timeouts: &mut state.timeouts,
                };

                self.handle_effect(myself, handler_state, effect).await
            }
        )
    }

    #[async_recursion]
    async fn process_buffered_msgs(&self, myself: &ActorRef<Msg<Ctx>>, state: &mut State<Ctx>) {
        if state.msg_buffer.is_empty() {
            return;
        }

        info!(count = %state.msg_buffer.len(), "Replaying buffered messages");

        while let Some(msg) = state.msg_buffer.pop() {
            debug!("Replaying buffered message: {msg}");

            if let Err(e) = self.handle_msg(myself.clone(), state, msg).await {
                error!("Error when handling buffered message: {e:?}");
            }
        }
    }

    async fn handle_msg(
        &self,
        myself: ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
        msg: Msg<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        let is_restart = matches!(msg, Msg::RestartHeight(_, _));

        match msg {
            Msg::StartHeight(height, validator_set) | Msg::RestartHeight(height, validator_set) => {
                self.tx_event
                    .send(|| Event::StartedHeight(height, is_restart));

                // Fetch entries from the WAL or reset the WAL if this is a restart
                let wal_entries = if is_restart {
                    self.wal_reset(height).await?;
                    vec![]
                } else {
                    self.wal_fetch(height).await?
                };

                if !wal_entries.is_empty() {
                    // Set the phase to `Recovering` while we replay the WAL
                    state.set_phase(Phase::Recovering);
                }

                // Start consensus for the given height
                let result = self
                    .process_input(
                        &myself,
                        state,
                        ConsensusInput::StartHeight(height, validator_set),
                    )
                    .await;

                if let Err(e) = result {
                    error!(%height, "Error when starting height: {e}");
                }

                if !wal_entries.is_empty() {
                    self.wal_replay(&myself, state, height, wal_entries).await;
                }

                // Set the phase to `Running` now that we have replayed the WAL
                state.set_phase(Phase::Running);

                // Process any buffered messages, now that we are in the `Running` phase
                self.process_buffered_msgs(&myself, state).await;

                // Notify the sync actor that we have started a new height
                if let Some(sync) = &self.sync {
                    if let Err(e) = sync.cast(SyncMsg::StartedHeight(height, is_restart)) {
                        error!(%height, "Error when notifying sync of started height: {e}")
                    }
                }

                Ok(())
            }

            Msg::ProposeValue(value) => {
                let result = self
                    .process_input(&myself, state, ConsensusInput::Propose(value.clone()))
                    .await;

                if let Err(e) = result {
                    error!(
                        height = %value.height, round = %value.round,
                        "Error when processing ProposeValue message: {e}"
                    );
                }

                self.tx_event.send(|| Event::ProposedValue(value));

                Ok(())
            }

            Msg::NetworkEvent(event) => {
                match event {
                    NetworkEvent::Listening(address) => {
                        info!(%address, "Listening");

                        if state.phase == Phase::Unstarted {
                            state.set_phase(Phase::Ready);

                            self.host.cast(HostMsg::ConsensusReady(myself.clone()))?;
                        }
                    }

                    NetworkEvent::PeerConnected(peer_id) => {
                        if !state.connected_peers.insert(peer_id) {
                            // We already saw that peer, ignoring...
                            return Ok(());
                        }

                        info!(%peer_id, "Connected to peer");

                        let validator_set = state.consensus.validator_set();
                        let connected_peers = state.connected_peers.len();
                        let total_peers = validator_set.count() - 1;

                        debug!(connected = %connected_peers, total = %total_peers, "Connected to another peer");

                        self.metrics.connected_peers.inc();
                    }

                    NetworkEvent::PeerDisconnected(peer_id) => {
                        info!(%peer_id, "Disconnected from peer");

                        if state.connected_peers.remove(&peer_id) {
                            self.metrics.connected_peers.dec();
                        }
                    }

                    NetworkEvent::Response(
                        request_id,
                        peer,
                        sync::Response::ValueResponse(ValueResponse { height, value }),
                    ) => {
                        debug!(%height, %request_id, "Received sync response");

                        let Some(value) = value else {
                            error!(%height, %request_id, "Received empty value sync response");
                            return Ok(());
                        };

                        if let Err(e) = self
                            .process_input(
                                &myself,
                                state,
                                ConsensusInput::CommitCertificate(value.certificate.clone()),
                            )
                            .await
                        {
                            error!(%height, %request_id, "Error when processing received synced block: {e}");

                            let Some(sync) = self.sync.as_ref() else {
                                warn!("Received sync response but sync actor is not available");
                                return Ok(());
                            };

                            if let ConsensusError::InvalidCommitCertificate(certificate, e) = e {
                                sync.cast(SyncMsg::InvalidCommitCertificate(peer, certificate, e))
                                    .map_err(|e| {
                                        eyre!(
                                            "Error when notifying sync of invalid certificate: {e}"
                                        )
                                    })?;
                            }
                        }

                        self.host.call_and_forward(
                            |reply_to| HostMsg::ProcessSyncedValue {
                                height: value.certificate.height,
                                round: value.certificate.round,
                                validator_address: state.consensus.address().clone(),
                                value_bytes: value.value_bytes.clone(),
                                reply_to,
                            },
                            &myself,
                            |proposed| {
                                Msg::<Ctx>::ReceivedProposedValue(proposed, ValueOrigin::Sync)
                            },
                            None,
                        )?;
                    }

                    NetworkEvent::Vote(from, vote) => {
                        if let Err(e) = self
                            .process_input(&myself, state, ConsensusInput::Vote(vote))
                            .await
                        {
                            error!(%from, "Error when processing vote: {e}");
                        }
                    }

                    NetworkEvent::Proposal(from, proposal) => {
                        if state.consensus.params.value_payload.parts_only() {
                            error!(%from, "Properly configured peer should never send proposal messages in BlockPart mode");
                            return Ok(());
                        }

                        if let Err(e) = self
                            .process_input(&myself, state, ConsensusInput::Proposal(proposal))
                            .await
                        {
                            error!(%from, "Error when processing proposal: {e}");
                        }
                    }

                    NetworkEvent::PolkaCertificate(from, certificate) => {
                        if let Err(e) = self
                            .process_input(
                                &myself,
                                state,
                                ConsensusInput::PolkaCertificate(certificate),
                            )
                            .await
                        {
                            error!(%from, "Error when processing polka certificate: {e}");
                        }
                    }

                    NetworkEvent::RoundCertificate(from, certificate) => {
                        info!(
                            %from,
                            %certificate.height,
                            %certificate.round,
                            number_of_votes = certificate.round_signatures.len(),
                            "Received round certificate"
                        );
                        if let Err(e) = self
                            .process_input(
                                &myself,
                                state,
                                ConsensusInput::RoundCertificate(certificate),
                            )
                            .await
                        {
                            error!(%from, "Error when processing round certificate: {e}");
                        }
                    }

                    NetworkEvent::ProposalPart(from, part) => {
                        if state.consensus.params.value_payload.proposal_only() {
                            error!(%from, "Properly configured peer should never send proposal part messages in Proposal mode");
                            return Ok(());
                        }

                        self.host
                            .call_and_forward(
                                |reply_to| HostMsg::ReceivedProposalPart {
                                    from,
                                    part,
                                    reply_to,
                                },
                                &myself,
                                |value| Msg::ReceivedProposedValue(value, ValueOrigin::Consensus),
                                None,
                            )
                            .map_err(|e| {
                                eyre!("Error when forwarding proposal parts to host: {e}")
                            })?;
                    }

                    _ => {}
                }

                Ok(())
            }

            Msg::TimeoutElapsed(elapsed) => {
                let Some(timeout) = state.timers.intercept_timer_msg(elapsed) else {
                    // Timer was cancelled or already processed, ignore
                    return Ok(());
                };

                if let Err(e) = self.timeout_elapsed(&myself, state, timeout).await {
                    error!("Error when processing TimeoutElapsed message: {e:?}");
                }

                Ok(())
            }

            Msg::ReceivedProposedValue(value, origin) => {
                self.tx_event
                    .send(|| Event::ReceivedProposedValue(value.clone(), origin));

                let result = self
                    .process_input(&myself, state, ConsensusInput::ProposedValue(value, origin))
                    .await;

                if let Err(e) = result {
                    error!("Error when processing ReceivedProposedValue message: {e}");
                }

                Ok(())
            }
        }
    }

    async fn timeout_elapsed(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
        timeout: Timeout,
    ) -> Result<(), ActorProcessingErr> {
        // Make sure the associated timer is cancelled
        state.timers.cancel(&timeout);

        // Increase the timeout for the next round
        state.timeouts.increase_timeout(timeout.kind);

        // Print debug information if the timeout is for a prevote or precommit
        if matches!(
            timeout.kind,
            TimeoutKind::Prevote | TimeoutKind::Precommit | TimeoutKind::Rebroadcast
        ) {
            warn!(step = ?timeout.kind, "Timeout elapsed");
            state.consensus.print_state();
        }

        // Process the timeout event
        self.process_input(myself, state, ConsensusInput::TimeoutElapsed(timeout))
            .await?;

        Ok(())
    }

    async fn wal_reset(&self, height: Ctx::Height) -> Result<(), ActorProcessingErr> {
        let result = ractor::call!(self.wal, WalMsg::Reset, height);

        match result {
            Ok(Ok(())) => {
                // Success
            }
            Ok(Err(e)) => {
                error!("Resetting the WAL failed: {e}");
            }
            Err(e) => {
                error!("Failed to send Reset command to WAL actor: {e}");
            }
        }

        Ok(())
    }

    async fn wal_fetch(
        &self,
        height: Ctx::Height,
    ) -> Result<Vec<WalEntry<Ctx>>, ActorProcessingErr> {
        let result = ractor::call!(self.wal, WalMsg::StartedHeight, height)?;

        match result {
            Ok(None) => {
                // Nothing to replay
                debug!(%height, "No WAL entries to replay");
                Ok(Default::default())
            }

            Ok(Some(entries)) => {
                info!("Found {} WAL entries", entries.len());

                Ok(entries)
            }

            Err(e) => {
                error!(%height, "Error when notifying WAL of started height: {e}");
                self.tx_event
                    .send(|| Event::WalReplayError(Arc::new(e.into())));
                Ok(Default::default())
            }
        }
    }

    async fn wal_replay(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
        height: Ctx::Height,
        entries: Vec<WalEntry<Ctx>>,
    ) {
        use SignedConsensusMsg::*;

        assert_eq!(state.phase, Phase::Recovering);

        info!("Replaying {} WAL entries", entries.len());

        if entries.is_empty() {
            return;
        }

        self.tx_event
            .send(|| Event::WalReplayBegin(height, entries.len()));

        for entry in entries {
            self.tx_event.send(|| Event::WalReplayEntry(entry.clone()));

            match entry {
                WalEntry::ConsensusMsg(Vote(vote)) => {
                    info!("Replaying vote: {vote:?}");

                    if let Err(e) = self
                        .process_input(myself, state, ConsensusInput::Vote(vote))
                        .await
                    {
                        error!("Error when replaying vote: {e}");

                        self.tx_event
                            .send(|| Event::WalReplayError(Arc::new(e.into())));
                    }
                }

                WalEntry::ConsensusMsg(Proposal(proposal)) => {
                    info!("Replaying proposal: {proposal:?}");

                    if let Err(e) = self
                        .process_input(myself, state, ConsensusInput::Proposal(proposal))
                        .await
                    {
                        error!("Error when replaying Proposal: {e}");

                        self.tx_event
                            .send(|| Event::WalReplayError(Arc::new(e.into())));
                    }
                }

                WalEntry::Timeout(timeout) => {
                    info!("Replaying timeout: {timeout:?}");

                    if let Err(e) = self.timeout_elapsed(myself, state, timeout).await {
                        error!("Error when replaying TimeoutElapsed: {e}");

                        self.tx_event.send(|| Event::WalReplayError(Arc::new(e)));
                    }
                }

                WalEntry::ProposedValue(value) => {
                    info!("Replaying proposed value: {value:?}");

                    if let Err(e) = self
                        .process_input(
                            myself,
                            state,
                            ConsensusInput::ProposedValue(value, ValueOrigin::Consensus),
                        )
                        .await
                    {
                        error!("Error when replaying LocallyProposedValue: {e}");

                        self.tx_event
                            .send(|| Event::WalReplayError(Arc::new(e.into())));
                    }
                }
            }
        }

        self.tx_event.send(|| Event::WalReplayDone(state.height()));
    }

    fn get_value(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        height: Ctx::Height,
        round: Round,
        timeout: Duration,
    ) -> Result<(), ActorProcessingErr> {
        // Call `GetValue` on the Host actor, and forward the reply
        // to the current actor, wrapping it in `Msg::ProposeValue`.
        self.host.call_and_forward(
            |reply_to| HostMsg::GetValue {
                height,
                round,
                timeout,
                reply_to,
            },
            myself,
            Msg::<Ctx>::ProposeValue,
            None,
        )?;

        Ok(())
    }

    async fn get_validator_set(
        &self,
        height: Ctx::Height,
    ) -> Result<Option<Ctx::ValidatorSet>, ActorProcessingErr> {
        let validator_set = ractor::call!(self.host, |reply_to| HostMsg::GetValidatorSet {
            height,
            reply_to
        })
        .map_err(|e| eyre!("Failed to get validator set at height {height}: {e:?}"))?;

        Ok(validator_set)
    }

    async fn extend_vote(
        &self,
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
    ) -> Result<Option<Ctx::Extension>, ActorProcessingErr> {
        ractor::call!(self.host, |reply_to| HostMsg::ExtendVote {
            height,
            round,
            value_id,
            reply_to
        })
        .map_err(|e| eyre!("Failed to get earliest block height: {e:?}").into())
    }

    async fn verify_vote_extension(
        &self,
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        extension: Ctx::Extension,
    ) -> Result<Result<(), VoteExtensionError>, ActorProcessingErr> {
        ractor::call!(self.host, |reply_to| HostMsg::VerifyVoteExtension {
            height,
            round,
            value_id,
            extension,
            reply_to
        })
        .map_err(|e| eyre!("Failed to verify vote extension: {e:?}").into())
    }

    async fn wal_append(
        &self,
        height: Ctx::Height,
        entry: WalEntry<Ctx>,
        phase: Phase,
    ) -> Result<(), ActorProcessingErr> {
        if phase == Phase::Recovering {
            return Ok(());
        }

        let result = ractor::call!(self.wal, WalMsg::Append, height, entry);

        match result {
            Ok(Ok(())) => {
                // Success
            }
            Ok(Err(e)) => {
                error!("Failed to append entry to WAL: {e}");
            }
            Err(e) => {
                error!("Failed to send Append command to WAL actor: {e}");
            }
        }

        Ok(())
    }

    async fn wal_flush(&self, phase: Phase) -> Result<(), ActorProcessingErr> {
        if phase == Phase::Recovering {
            return Ok(());
        }

        let result = ractor::call!(self.wal, WalMsg::Flush);

        match result {
            Ok(Ok(())) => {
                // Success
            }
            Ok(Err(e)) => {
                error!("Failed to flush WAL to disk: {e}");
            }
            Err(e) => {
                error!("Failed to send Flush command to WAL: {e}");
            }
        }

        Ok(())
    }

    async fn handle_effect(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        state: HandlerState<'_, Ctx>,
        effect: Effect<Ctx>,
    ) -> Result<Resume<Ctx>, ActorProcessingErr> {
        match effect {
            Effect::ResetTimeouts(r) => {
                state.timeouts.reset(self.timeout_config);
                Ok(r.resume_with(()))
            }

            Effect::CancelAllTimeouts(r) => {
                state.timers.cancel_all();
                Ok(r.resume_with(()))
            }

            Effect::CancelTimeout(timeout, r) => {
                state.timers.cancel(&timeout);
                Ok(r.resume_with(()))
            }

            Effect::ScheduleTimeout(timeout, r) => {
                let duration = state.timeouts.duration_for(timeout.kind);
                state.timers.start_timer(timeout, duration);

                Ok(r.resume_with(()))
            }

            Effect::StartRound(height, round, proposer, r) => {
                self.wal_flush(state.phase).await?;

                self.host.cast(HostMsg::StartedRound {
                    height,
                    round,
                    proposer,
                })?;

                self.tx_event.send(|| Event::StartedRound(height, round));

                Ok(r.resume_with(()))
            }

            Effect::SignProposal(proposal, r) => {
                let start = Instant::now();

                let signed_proposal = self.signing_provider.sign_proposal(proposal);

                self.metrics
                    .signature_signing_time
                    .observe(start.elapsed().as_secs_f64());

                Ok(r.resume_with(signed_proposal))
            }

            Effect::SignVote(vote, r) => {
                let start = Instant::now();

                let signed_vote = self.signing_provider.sign_vote(vote);

                self.metrics
                    .signature_signing_time
                    .observe(start.elapsed().as_secs_f64());

                Ok(r.resume_with(signed_vote))
            }

            Effect::VerifySignature(msg, pk, r) => {
                use malachitebft_core_consensus::ConsensusMsg as Msg;

                let start = Instant::now();

                let valid = match msg.message {
                    Msg::Vote(v) => {
                        self.signing_provider
                            .verify_signed_vote(&v, &msg.signature, &pk)
                    }
                    Msg::Proposal(p) => {
                        self.signing_provider
                            .verify_signed_proposal(&p, &msg.signature, &pk)
                    }
                };

                self.metrics
                    .signature_verification_time
                    .observe(start.elapsed().as_secs_f64());

                Ok(r.resume_with(valid))
            }

            Effect::VerifyCommitCertificate(certificate, validator_set, thresholds, r) => {
                let result = self.signing_provider.verify_commit_certificate(
                    &self.ctx,
                    &certificate,
                    &validator_set,
                    thresholds,
                );

                Ok(r.resume_with(result))
            }

            Effect::VerifyPolkaCertificate(certificate, validator_set, thresholds, r) => {
                let result = self.signing_provider.verify_polka_certificate(
                    &self.ctx,
                    &certificate,
                    &validator_set,
                    thresholds,
                );

                Ok(r.resume_with(result))
            }

            Effect::ExtendVote(height, round, value_id, r) => {
                if let Some(extension) = self.extend_vote(height, round, value_id).await? {
                    let signed_extension = self.signing_provider.sign_vote_extension(extension);
                    Ok(r.resume_with(Some(signed_extension)))
                } else {
                    Ok(r.resume_with(None))
                }
            }

            Effect::VerifyVoteExtension(height, round, value_id, signed_extension, pk, r) => {
                let valid = self.signing_provider.verify_signed_vote_extension(
                    &signed_extension.message,
                    &signed_extension.signature,
                    &pk,
                );

                if !valid {
                    return Ok(r.resume_with(Err(VoteExtensionError::InvalidSignature)));
                }

                let result = self
                    .verify_vote_extension(height, round, value_id, signed_extension.message)
                    .await?;

                Ok(r.resume_with(result))
            }

            Effect::PublishConsensusMsg(msg, r) => {
                // Sync the WAL to disk before we broadcast the message
                // NOTE: The message has already been append to the WAL by the `WalAppend` effect.
                self.wal_flush(state.phase).await?;

                // Notify any subscribers that we are about to publish a message
                self.tx_event.send(|| Event::Published(msg.clone()));

                self.network
                    .cast(NetworkMsg::PublishConsensusMsg(msg))
                    .map_err(|e| eyre!("Error when broadcasting consensus message: {e:?}"))?;

                Ok(r.resume_with(()))
            }

            Effect::PublishLivenessMsg(msg, r) => {
                match msg {
                    LivenessMsg::Vote(ref msg) => {
                        self.tx_event.send(|| Event::RebroadcastVote(msg.clone()));
                    }
                    LivenessMsg::PolkaCertificate(ref certificate) => {
                        self.tx_event
                            .send(|| Event::PolkaCertificate(certificate.clone()));
                    }
                    LivenessMsg::SkipRoundCertificate(ref certificate) => {
                        self.tx_event
                            .send(|| Event::SkipRoundCertificate(certificate.clone()));
                    }
                }

                self.network
                    .cast(NetworkMsg::PublishLivenessMsg(msg))
                    .map_err(|e| eyre!("Error when broadcasting liveness message: {e:?}"))?;

                Ok(r.resume_with(()))
            }

            Effect::RebroadcastVote(msg, r) => {
                // Notify any subscribers that we are about to rebroadcast a vote
                self.tx_event.send(|| Event::RebroadcastVote(msg.clone()));

                self.network
                    .cast(NetworkMsg::PublishLivenessMsg(LivenessMsg::Vote(msg)))
                    .map_err(|e| eyre!("Error when rebroadcasting vote message: {e:?}"))?;

                Ok(r.resume_with(()))
            }

            Effect::RebroadcastRoundCertificate(certificate, r) => {
                // Notify any subscribers that we are about to rebroadcast a round certificate
                self.tx_event
                    .send(|| Event::RebroadcastRoundCertificate(certificate.clone()));

                self.network
                    .cast(NetworkMsg::PublishLivenessMsg(
                        LivenessMsg::SkipRoundCertificate(certificate),
                    ))
                    .map_err(|e| {
                        eyre!("Error when rebroadcasting round certificate message: {e:?}")
                    })?;

                Ok(r.resume_with(()))
            }

            Effect::GetValue(height, round, timeout, r) => {
                let timeout_duration = state.timeouts.duration_for(timeout.kind);

                self.get_value(myself, height, round, timeout_duration)
                    .map_err(|e| {
                        eyre!("Error when asking application for value to propose: {e:?}")
                    })?;

                Ok(r.resume_with(()))
            }

            Effect::GetValidatorSet(height, r) => {
                let validator_set = self
                    .get_validator_set(height)
                    .await
                    .map_err(|e| {
                        warn!("Error while asking application for the validator set at height {height}: {e:?}")
                    })
                    .ok(); // If call fails, send back `None` to consensus

                Ok(r.resume_with(validator_set.unwrap_or_default()))
            }

            Effect::RestreamProposal(height, round, valid_round, address, value_id, r) => {
                self.host
                    .cast(HostMsg::RestreamValue {
                        height,
                        round,
                        valid_round,
                        address,
                        value_id,
                    })
                    .map_err(|e| eyre!("Error when sending decided value to host: {e:?}"))?;

                Ok(r.resume_with(()))
            }

            Effect::Decide(certificate, extensions, r) => {
                assert!(!certificate.commit_signatures.is_empty());

                self.wal_flush(state.phase).await?;

                self.tx_event.send(|| Event::Decided(certificate.clone()));

                let height = certificate.height;

                self.host
                    .cast(HostMsg::Decided {
                        certificate,
                        extensions,
                        consensus: myself.clone(),
                    })
                    .map_err(|e| eyre!("Error when sending decided value to host: {e:?}"))?;

                if let Some(sync) = &self.sync {
                    sync.cast(SyncMsg::Decided(height))
                        .map_err(|e| eyre!("Error when sending decided height to sync: {e:?}"))?;
                }

                Ok(r.resume_with(()))
            }

            Effect::WalAppend(entry, r) => {
                self.wal_append(state.height, entry, state.phase).await?;
                Ok(r.resume_with(()))
            }
        }
    }
}

#[async_trait]
impl<Ctx> Actor for Consensus<Ctx>
where
    Ctx: Context,
{
    type Msg = Msg<Ctx>;
    type State = State<Ctx>;
    type Arguments = ();

    #[tracing::instrument(
        name = "consensus",
        parent = &self.span,
        skip_all,
    )]
    async fn pre_start(
        &self,
        myself: ActorRef<Msg<Ctx>>,
        _args: (),
    ) -> Result<State<Ctx>, ActorProcessingErr> {
        info!("Consensus is starting");

        self.network
            .cast(NetworkMsg::Subscribe(Box::new(myself.clone())))?;

        Ok(State {
            timers: Timers::new(Box::new(myself)),
            timeouts: Timeouts::new(self.timeout_config),
            consensus: ConsensusState::new(self.ctx.clone(), self.params.clone()),
            connected_peers: BTreeSet::new(),
            phase: Phase::Unstarted,
            msg_buffer: MessageBuffer::new(MAX_BUFFER_SIZE),
        })
    }

    #[tracing::instrument(
        name = "consensus",
        parent = &self.span,
        skip_all,
        fields(
            height = %state.consensus.height(),
            round = %state.consensus.round()
        )
    )]
    async fn post_start(
        &self,
        _myself: ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        info!("Consensus has started");

        state.timers.cancel_all();
        Ok(())
    }

    #[tracing::instrument(
        name = "consensus",
        parent = &self.span,
        skip_all,
        fields(
            height = %span_height(state.consensus.height(), &msg),
            round = %span_round(state.consensus.round(), &msg)
        )
    )]
    async fn handle(
        &self,
        myself: ActorRef<Msg<Ctx>>,
        msg: Msg<Ctx>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        if state.phase != Phase::Running && should_buffer(&msg) {
            let _span = error_span!("buffer", phase = ?state.phase).entered();
            state.msg_buffer.buffer(msg);
            return Ok(());
        }

        if let Err(e) = self.handle_msg(myself.clone(), state, msg).await {
            error!("Error when handling message: {e:?}");
        }

        Ok(())
    }

    #[tracing::instrument(
        name = "consensus",
        parent = &self.span,
        skip_all,
        fields(
            height = %state.consensus.height(),
            round = %state.consensus.round()
        )
    )]
    async fn post_stop(
        &self,
        _myself: ActorRef<Self::Msg>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        info!("Consensus has stopped");
        state.timers.cancel_all();
        Ok(())
    }
}

fn should_buffer<Ctx: Context>(msg: &Msg<Ctx>) -> bool {
    !matches!(
        msg,
        Msg::StartHeight(..)
            | Msg::NetworkEvent(NetworkEvent::Listening(..))
            | Msg::NetworkEvent(NetworkEvent::PeerConnected(..))
            | Msg::NetworkEvent(NetworkEvent::PeerDisconnected(..))
    )
}

/// Use the height we are about to start instead of the consensus state height
/// for the tracing span of the Consensus actor when starting a new height.
fn span_height<Ctx: Context>(height: Ctx::Height, msg: &Msg<Ctx>) -> Ctx::Height {
    if let Msg::StartHeight(h, _) = msg {
        *h
    } else {
        height
    }
}

/// Use round 0 instead of the consensus state round for the tracing span of
/// the Consensus actor when starting a new height.
fn span_round<Ctx: Context>(round: Round, msg: &Msg<Ctx>) -> Round {
    if let Msg::StartHeight(_, _) = msg {
        Round::new(0)
    } else {
        round
    }
}

```
---
### `engine/src/host.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use bytes::Bytes;
use std::time::Duration;

use derive_where::derive_where;
use ractor::{ActorRef, RpcReplyPort};

use malachitebft_core_consensus::VoteExtensionError;
use malachitebft_core_types::{CommitCertificate, Context, Round, ValueId, VoteExtensions};
use malachitebft_sync::{PeerId, RawDecidedValue};

use crate::consensus::ConsensusRef;
use crate::util::streaming::StreamMessage;

pub use malachitebft_core_consensus::{LocallyProposedValue, ProposedValue};

/// A reference to the host actor.
pub type HostRef<Ctx> = ActorRef<HostMsg<Ctx>>;

/// Messages that need to be handled by the host actor.
#[derive_where(Debug)]
pub enum HostMsg<Ctx: Context> {
    /// Consensus is ready
    ConsensusReady(ConsensusRef<Ctx>),

    /// Consensus has started a new round.
    StartedRound {
        height: Ctx::Height,
        round: Round,
        proposer: Ctx::Address,
    },

    /// Request to build a local value to propose
    GetValue {
        height: Ctx::Height,
        round: Round,
        timeout: Duration,
        reply_to: RpcReplyPort<LocallyProposedValue<Ctx>>,
    },

    /// ExtendVote allows the application to extend the pre-commit vote with arbitrary data.
    ///
    /// When consensus is preparing to send a pre-commit vote, it first calls `ExtendVote`.
    /// The application then returns a blob of data called a vote extension.
    /// This data is opaque to the consensus algorithm but can contain application-specific information.
    /// The proposer of the next block will receive all vote extensions along with the commit certificate.
    ExtendVote {
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        reply_to: RpcReplyPort<Option<Ctx::Extension>>,
    },

    /// Verify a vote extension
    ///
    /// If the vote extension is deemed invalid, the vote it was part of
    /// will be discarded altogether.
    VerifyVoteExtension {
        height: Ctx::Height,
        round: Round,
        value_id: ValueId<Ctx>,
        extension: Ctx::Extension,
        reply_to: RpcReplyPort<Result<(), VoteExtensionError>>,
    },

    /// Request to restream an existing block/value from Driver
    RestreamValue {
        height: Ctx::Height,
        round: Round,
        valid_round: Round,
        address: Ctx::Address,
        value_id: ValueId<Ctx>,
    },

    /// Request the earliest block height in the block store
    GetHistoryMinHeight { reply_to: RpcReplyPort<Ctx::Height> },

    /// ProposalPart received <-- consensus <-- gossip
    ReceivedProposalPart {
        from: PeerId,
        part: StreamMessage<Ctx::ProposalPart>,
        reply_to: RpcReplyPort<ProposedValue<Ctx>>,
    },

    /// Get the validator set at a given height
    GetValidatorSet {
        height: Ctx::Height,
        reply_to: RpcReplyPort<Option<Ctx::ValidatorSet>>,
    },

    /// Consensus has decided on a value.
    Decided {
        /// The commit certificate containing the ID of the value that was decided on,
        /// the the height and round at which it was decided, and the aggregated signatures
        /// of the validators that committed to it.
        certificate: CommitCertificate<Ctx>,

        /// Vote extensions that were received for this height.
        extensions: VoteExtensions<Ctx>,

        /// Reference to the `Consensus` actor for starting a new height.
        consensus: ConsensusRef<Ctx>,
    },

    // Retrieve decided value from the block store
    GetDecidedValue {
        height: Ctx::Height,
        reply_to: RpcReplyPort<Option<RawDecidedValue<Ctx>>>,
    },

    // Process a value synced from another node via the ValueSync protocol.
    // If the encoded value within is valid, reply with that value to be proposed.
    ProcessSyncedValue {
        height: Ctx::Height,
        round: Round,
        validator_address: Ctx::Address,
        value_bytes: Bytes,
        reply_to: RpcReplyPort<ProposedValue<Ctx>>,
    },
}

```
---
### `engine/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod consensus;
pub mod host;
pub mod network;
pub mod node;
pub mod sync;
pub mod util;
pub mod wal;

```
---
### `engine/src/network.rs`
*2025-05-18 23:58:49 | 17 KB*
```rust
use std::collections::{BTreeSet, HashMap};
use std::marker::PhantomData;

use async_trait::async_trait;
use derive_where::derive_where;
use eyre::eyre;
use libp2p::identity::Keypair;
use libp2p::request_response;
use ractor::{Actor, ActorProcessingErr, ActorRef, RpcReplyPort};
use tokio::task::JoinHandle;
use tracing::{error, trace};

use malachitebft_sync::{
    self as sync, InboundRequestId, OutboundRequestId, RawMessage, Request, Response,
};

use malachitebft_codec as codec;
use malachitebft_core_consensus::{LivenessMsg, SignedConsensusMsg};
use malachitebft_core_types::{
    Context, PolkaCertificate, RoundCertificate, SignedProposal, SignedVote,
};
use malachitebft_metrics::SharedRegistry;
use malachitebft_network::handle::CtrlHandle;
use malachitebft_network::{Channel, Config, Event, Multiaddr, PeerId};

use crate::consensus::ConsensusCodec;
use crate::sync::SyncCodec;
use crate::util::output_port::{OutputPort, OutputPortSubscriberTrait};
use crate::util::streaming::StreamMessage;

pub type NetworkRef<Ctx> = ActorRef<Msg<Ctx>>;
pub type NetworkMsg<Ctx> = Msg<Ctx>;

pub trait Subscriber<Msg>: OutputPortSubscriberTrait<Msg>
where
    Msg: Clone + ractor::Message,
{
    fn send(&self, msg: Msg);
}

impl<Msg, To> Subscriber<Msg> for ActorRef<To>
where
    Msg: Clone + ractor::Message,
    To: From<Msg> + ractor::Message,
{
    fn send(&self, msg: Msg) {
        if let Err(e) = self.cast(To::from(msg)) {
            error!("Failed to send message to subscriber: {e:?}");
        }
    }
}

pub struct Network<Ctx, Codec> {
    codec: Codec,
    span: tracing::Span,
    marker: PhantomData<Ctx>,
}

impl<Ctx, Codec> Network<Ctx, Codec> {
    pub fn new(codec: Codec, span: tracing::Span) -> Self {
        Self {
            codec,
            span,
            marker: PhantomData,
        }
    }
}

impl<Ctx, Codec> Network<Ctx, Codec>
where
    Ctx: Context,
    Codec: ConsensusCodec<Ctx>,
    Codec: SyncCodec<Ctx>,
{
    pub async fn spawn(
        keypair: Keypair,
        config: Config,
        metrics: SharedRegistry,
        codec: Codec,
        span: tracing::Span,
    ) -> Result<ActorRef<Msg<Ctx>>, ractor::SpawnErr> {
        let args = Args {
            keypair,
            config,
            metrics,
        };

        let (actor_ref, _) = Actor::spawn(None, Self::new(codec, span), args).await?;
        Ok(actor_ref)
    }
}

pub struct Args {
    pub keypair: Keypair,
    pub config: Config,
    pub metrics: SharedRegistry,
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum NetworkEvent<Ctx: Context> {
    Listening(Multiaddr),

    PeerConnected(PeerId),
    PeerDisconnected(PeerId),

    Vote(PeerId, SignedVote<Ctx>),

    Proposal(PeerId, SignedProposal<Ctx>),
    ProposalPart(PeerId, StreamMessage<Ctx::ProposalPart>),

    PolkaCertificate(PeerId, PolkaCertificate<Ctx>),

    RoundCertificate(PeerId, RoundCertificate<Ctx>),

    Status(PeerId, Status<Ctx>),

    Request(InboundRequestId, PeerId, Request<Ctx>),
    Response(OutboundRequestId, PeerId, Response<Ctx>),
}

pub enum State<Ctx: Context> {
    Stopped,
    Running {
        listen_addrs: Vec<Multiaddr>,
        peers: BTreeSet<PeerId>,
        output_port: OutputPort<NetworkEvent<Ctx>>,
        ctrl_handle: CtrlHandle,
        recv_task: JoinHandle<()>,
        inbound_requests: HashMap<InboundRequestId, request_response::InboundRequestId>,
    },
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct Status<Ctx: Context> {
    pub tip_height: Ctx::Height,
    pub history_min_height: Ctx::Height,
}

impl<Ctx: Context> Status<Ctx> {
    pub fn new(tip_height: Ctx::Height, history_min_height: Ctx::Height) -> Self {
        Self {
            tip_height,
            history_min_height,
        }
    }
}

pub enum Msg<Ctx: Context> {
    /// Subscribe this actor to receive gossip events
    Subscribe(Box<dyn Subscriber<NetworkEvent<Ctx>>>),

    /// Publish a signed consensus message
    PublishConsensusMsg(SignedConsensusMsg<Ctx>),

    /// Publish a liveness message
    PublishLivenessMsg(LivenessMsg<Ctx>),

    /// Publish a proposal part
    PublishProposalPart(StreamMessage<Ctx::ProposalPart>),

    /// Broadcast status to all direct peers
    BroadcastStatus(Status<Ctx>),

    /// Send a request to a peer, returning the outbound request ID
    OutgoingRequest(PeerId, Request<Ctx>, RpcReplyPort<OutboundRequestId>),

    /// Send a response for a request to a peer
    OutgoingResponse(InboundRequestId, Response<Ctx>),

    /// Request for number of peers from gossip
    GetState { reply: RpcReplyPort<usize> },

    // Event emitted by the gossip layer
    #[doc(hidden)]
    NewEvent(Event),
}

#[async_trait]
impl<Ctx, Codec> Actor for Network<Ctx, Codec>
where
    Ctx: Context,
    Codec: Send + Sync + 'static,
    Codec: codec::Codec<Ctx::ProposalPart>,
    Codec: codec::Codec<SignedConsensusMsg<Ctx>>,
    Codec: codec::Codec<StreamMessage<Ctx::ProposalPart>>,
    Codec: codec::Codec<sync::Status<Ctx>>,
    Codec: codec::Codec<sync::Request<Ctx>>,
    Codec: codec::Codec<sync::Response<Ctx>>,
    Codec: codec::Codec<LivenessMsg<Ctx>>,
{
    type Msg = Msg<Ctx>;
    type State = State<Ctx>;
    type Arguments = Args;

    async fn pre_start(
        &self,
        myself: ActorRef<Msg<Ctx>>,
        args: Args,
    ) -> Result<Self::State, ActorProcessingErr> {
        let handle = malachitebft_network::spawn(args.keypair, args.config, args.metrics).await?;

        let (mut recv_handle, ctrl_handle) = handle.split();

        let recv_task = tokio::spawn(async move {
            while let Some(event) = recv_handle.recv().await {
                if let Err(e) = myself.cast(Msg::NewEvent(event)) {
                    error!("Actor has died, stopping network: {e:?}");
                    break;
                }
            }
        });

        Ok(State::Running {
            listen_addrs: Vec::new(),
            peers: BTreeSet::new(),
            output_port: OutputPort::with_capacity(128),
            ctrl_handle,
            recv_task,
            inbound_requests: HashMap::new(),
        })
    }

    async fn post_start(
        &self,
        _myself: ActorRef<Msg<Ctx>>,
        _state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        Ok(())
    }

    #[tracing::instrument(name = "network", parent = &self.span, skip_all)]
    async fn handle(
        &self,
        _myself: ActorRef<Msg<Ctx>>,
        msg: Msg<Ctx>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        let State::Running {
            listen_addrs,
            peers,
            output_port,
            ctrl_handle,
            inbound_requests,
            ..
        } = state
        else {
            return Ok(());
        };

        match msg {
            Msg::Subscribe(subscriber) => {
                for addr in listen_addrs.iter() {
                    subscriber.send(NetworkEvent::Listening(addr.clone()));
                }

                for peer in peers.iter() {
                    subscriber.send(NetworkEvent::PeerConnected(*peer));
                }

                subscriber.subscribe_to_port(output_port);
            }

            Msg::PublishConsensusMsg(msg) => match self.codec.encode(&msg) {
                Ok(data) => ctrl_handle.publish(Channel::Consensus, data).await?,
                Err(e) => error!("Failed to encode consensus message: {e:?}"),
            },

            Msg::PublishLivenessMsg(msg) => match self.codec.encode(&msg) {
                Ok(data) => ctrl_handle.publish(Channel::Liveness, data).await?,
                Err(e) => error!("Failed to encode liveness message: {e:?}"),
            },

            Msg::PublishProposalPart(msg) => {
                trace!(
                    stream_id = %msg.stream_id,
                    sequence = %msg.sequence,
                    "Broadcasting proposal part"
                );

                let data = self.codec.encode(&msg);
                match data {
                    Ok(data) => ctrl_handle.publish(Channel::ProposalParts, data).await?,
                    Err(e) => error!("Failed to encode proposal part: {e:?}"),
                }
            }

            Msg::BroadcastStatus(status) => {
                let status = sync::Status {
                    peer_id: ctrl_handle.peer_id(),
                    tip_height: status.tip_height,
                    history_min_height: status.history_min_height,
                };

                let data = self.codec.encode(&status);
                match data {
                    Ok(data) => ctrl_handle.broadcast(Channel::Sync, data).await?,
                    Err(e) => error!("Failed to encode status message: {e:?}"),
                }
            }

            Msg::OutgoingRequest(peer_id, request, reply_to) => {
                let request = self.codec.encode(&request);

                match request {
                    Ok(data) => {
                        let p2p_request_id = ctrl_handle.sync_request(peer_id, data).await?;
                        reply_to.send(OutboundRequestId::new(p2p_request_id))?;
                    }
                    Err(e) => error!("Failed to encode request message: {e:?}"),
                }
            }

            Msg::OutgoingResponse(request_id, response) => {
                let response = self.codec.encode(&response);

                match response {
                    Ok(data) => {
                        let request_id = inbound_requests
                            .remove(&request_id)
                            .ok_or_else(|| eyre!("Unknown inbound request ID: {request_id}"))?;

                        ctrl_handle.sync_reply(request_id, data).await?
                    }
                    Err(e) => {
                        error!(%request_id, "Failed to encode response message: {e:?}");
                        return Ok(());
                    }
                };
            }

            Msg::NewEvent(Event::Listening(addr)) => {
                listen_addrs.push(addr.clone());
                output_port.send(NetworkEvent::Listening(addr));
            }

            Msg::NewEvent(Event::PeerConnected(peer_id)) => {
                peers.insert(peer_id);
                output_port.send(NetworkEvent::PeerConnected(peer_id));
            }

            Msg::NewEvent(Event::PeerDisconnected(peer_id)) => {
                peers.remove(&peer_id);
                output_port.send(NetworkEvent::PeerDisconnected(peer_id));
            }

            Msg::NewEvent(Event::LivenessMessage(Channel::Liveness, from, data)) => {
                let msg = match self.codec.decode(data) {
                    Ok(msg) => msg,
                    Err(e) => {
                        error!(%from, "Failed to decode liveness message: {e:?}");
                        return Ok(());
                    }
                };

                let event = match msg {
                    LivenessMsg::PolkaCertificate(polka_cert) => {
                        NetworkEvent::PolkaCertificate(from, polka_cert)
                    }
                    LivenessMsg::SkipRoundCertificate(round_cert) => {
                        NetworkEvent::RoundCertificate(from, round_cert)
                    }
                    LivenessMsg::Vote(vote) => NetworkEvent::Vote(from, vote),
                };

                output_port.send(event);
            }

            Msg::NewEvent(Event::LivenessMessage(channel, from, _)) => {
                error!(%from, "Unexpected liveness message on {channel} channel");
                return Ok(());
            }

            Msg::NewEvent(Event::ConsensusMessage(Channel::Consensus, from, data)) => {
                let msg = match self.codec.decode(data) {
                    Ok(msg) => msg,
                    Err(e) => {
                        error!(%from, "Failed to decode consensus message: {e:?}");
                        return Ok(());
                    }
                };

                let event = match msg {
                    SignedConsensusMsg::Vote(vote) => NetworkEvent::Vote(from, vote),
                    SignedConsensusMsg::Proposal(proposal) => {
                        NetworkEvent::Proposal(from, proposal)
                    }
                };

                output_port.send(event);
            }

            Msg::NewEvent(Event::ConsensusMessage(Channel::ProposalParts, from, data)) => {
                let msg: StreamMessage<Ctx::ProposalPart> = match self.codec.decode(data) {
                    Ok(stream_msg) => stream_msg,
                    Err(e) => {
                        error!(%from, "Failed to decode stream message: {e:?}");
                        return Ok(());
                    }
                };

                trace!(
                    %from,
                    stream_id = %msg.stream_id,
                    sequence = %msg.sequence,
                    "Received proposal part"
                );

                output_port.send(NetworkEvent::ProposalPart(from, msg));
            }

            Msg::NewEvent(Event::ConsensusMessage(Channel::Sync, from, data)) => {
                let status: sync::Status<Ctx> = match self.codec.decode(data) {
                    Ok(status) => status,
                    Err(e) => {
                        error!(%from, "Failed to decode status message: {e:?}");
                        return Ok(());
                    }
                };

                if from != status.peer_id {
                    error!(%from, %status.peer_id, "Mismatched peer ID in status message");
                    return Ok(());
                }

                trace!(%from, tip_height = %status.tip_height, "Received status");

                output_port.send(NetworkEvent::Status(
                    status.peer_id,
                    Status::new(status.tip_height, status.history_min_height),
                ));
            }

            Msg::NewEvent(Event::ConsensusMessage(channel, from, _)) => {
                error!(%from, "Unexpected consensus message on {channel} channel");
                return Ok(());
            }

            Msg::NewEvent(Event::Sync(raw_msg)) => match raw_msg {
                RawMessage::Request {
                    request_id,
                    peer,
                    body,
                } => {
                    let request: sync::Request<Ctx> = match self.codec.decode(body) {
                        Ok(request) => request,
                        Err(e) => {
                            error!(%peer, "Failed to decode sync request: {e:?}");
                            return Ok(());
                        }
                    };

                    inbound_requests.insert(InboundRequestId::new(request_id), request_id);

                    output_port.send(NetworkEvent::Request(
                        InboundRequestId::new(request_id),
                        peer,
                        request,
                    ));
                }

                RawMessage::Response {
                    request_id,
                    peer,
                    body,
                } => {
                    let response: sync::Response<Ctx> = match self.codec.decode(body) {
                        Ok(response) => response,
                        Err(e) => {
                            error!(%peer, "Failed to decode sync response: {e:?}");
                            return Ok(());
                        }
                    };

                    output_port.send(NetworkEvent::Response(
                        OutboundRequestId::new(request_id),
                        peer,
                        response,
                    ));
                }
            },

            Msg::GetState { reply } => {
                let number_peers = match state {
                    State::Stopped => 0,
                    State::Running { peers, .. } => peers.len(),
                };
                reply.send(number_peers)?;
            }
        }

        Ok(())
    }

    async fn post_stop(
        &self,
        _myself: ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        let state = std::mem::replace(state, State::Stopped);

        if let State::Running {
            ctrl_handle,
            recv_task,
            ..
        } = state
        {
            ctrl_handle.wait_shutdown().await?;
            recv_task.await?;
        }

        Ok(())
    }
}

```
---
### `engine/src/node.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use async_trait::async_trait;
use ractor::{Actor, ActorProcessingErr, ActorRef, SupervisionEvent};
use tokio::task::JoinHandle;
use tracing::{error, info, warn};

use malachitebft_core_types::Context;

use crate::consensus::ConsensusRef;
use crate::host::HostRef;
use crate::network::NetworkRef;
use crate::sync::SyncRef;
use crate::wal::WalRef;

pub type NodeRef = ActorRef<()>;

#[allow(dead_code)]
pub struct Node<Ctx: Context> {
    ctx: Ctx,
    network: NetworkRef<Ctx>,
    consensus: ConsensusRef<Ctx>,
    wal: WalRef<Ctx>,
    sync: Option<SyncRef<Ctx>>,
    host: HostRef<Ctx>,
    span: tracing::Span,
}

impl<Ctx> Node<Ctx>
where
    Ctx: Context,
{
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        ctx: Ctx,
        network: NetworkRef<Ctx>,
        consensus: ConsensusRef<Ctx>,
        wal: WalRef<Ctx>,
        sync: Option<SyncRef<Ctx>>,
        host: HostRef<Ctx>,
        span: tracing::Span,
    ) -> Self {
        Self {
            ctx,
            network,
            consensus,
            wal,
            sync,
            host,
            span,
        }
    }

    pub async fn spawn(self) -> Result<(ActorRef<()>, JoinHandle<()>), ractor::SpawnErr> {
        Actor::spawn(None, self, ()).await
    }
}

#[async_trait]
impl<Ctx> Actor for Node<Ctx>
where
    Ctx: Context,
{
    type Msg = ();
    type State = ();
    type Arguments = ();

    async fn pre_start(
        &self,
        myself: ActorRef<Self::Msg>,
        _args: (),
    ) -> Result<(), ActorProcessingErr> {
        // Set ourselves as the supervisor of the other actors
        self.network.link(myself.get_cell());
        self.consensus.link(myself.get_cell());
        self.host.link(myself.get_cell());
        self.wal.link(myself.get_cell());

        if let Some(actor) = &self.sync {
            actor.link(myself.get_cell());
        }

        Ok(())
    }

    #[tracing::instrument(name = "node", parent = &self.span, skip_all)]
    async fn handle(
        &self,
        _myself: ActorRef<Self::Msg>,
        _msg: Self::Msg,
        _state: &mut (),
    ) -> Result<(), ActorProcessingErr> {
        Ok(())
    }

    #[tracing::instrument(name = "node", parent = &self.span, skip_all)]
    async fn handle_supervisor_evt(
        &self,
        _myself: ActorRef<Self::Msg>,
        evt: SupervisionEvent,
        _state: &mut (),
    ) -> Result<(), ActorProcessingErr> {
        match evt {
            SupervisionEvent::ActorStarted(cell) => {
                info!(actor = %cell.get_id(), "Actor has started");
            }
            SupervisionEvent::ActorTerminated(cell, _state, reason) => {
                warn!(
                    "Actor {} has terminated: {}",
                    cell.get_id(),
                    reason.unwrap_or_default()
                );
            }
            SupervisionEvent::ActorFailed(cell, error) => {
                error!("Actor {} has failed: {error}", cell.get_id());
            }
            SupervisionEvent::ProcessGroupChanged(_) => (),
        }

        Ok(())
    }
}

```
---
### `engine/src/sync.rs`
*2025-05-18 23:58:49 | 14 KB*
```rust
use std::collections::HashMap;
use std::time::Duration;

use async_trait::async_trait;
use bytes::Bytes;
use derive_where::derive_where;
use eyre::eyre;

use ractor::{Actor, ActorProcessingErr, ActorRef};
use rand::SeedableRng;
use tokio::task::JoinHandle;
use tracing::{debug, error, info, warn, Instrument};

use malachitebft_codec as codec;
use malachitebft_core_consensus::PeerId;
use malachitebft_core_types::{CertificateError, CommitCertificate, Context};
use malachitebft_sync::{self as sync, InboundRequestId, OutboundRequestId, Response};
use malachitebft_sync::{RawDecidedValue, Request};

use crate::host::{HostMsg, HostRef};
use crate::network::{NetworkEvent, NetworkMsg, NetworkRef, Status};
use crate::util::ticker::ticker;
use crate::util::timers::{TimeoutElapsed, TimerScheduler};

/// Codec for sync protocol messages
///
/// This trait is automatically implemented for any type that implements:
/// - [`codec::Codec<sync::Status<Ctx>>`]
/// - [`codec::Codec<sync::Request<Ctx>>`]
/// - [`codec::Codec<sync::Response<Ctx>>`]
pub trait SyncCodec<Ctx>
where
    Ctx: Context,
    Self: codec::Codec<sync::Status<Ctx>>,
    Self: codec::Codec<sync::Request<Ctx>>,
    Self: codec::Codec<sync::Response<Ctx>>,
{
}

impl<Ctx, Codec> SyncCodec<Ctx> for Codec
where
    Ctx: Context,
    Codec: codec::Codec<sync::Status<Ctx>>,
    Codec: codec::Codec<sync::Request<Ctx>>,
    Codec: codec::Codec<sync::Response<Ctx>>,
{
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub enum Timeout {
    Request(OutboundRequestId),
}

type Timers = TimerScheduler<Timeout>;

pub type SyncRef<Ctx> = ActorRef<Msg<Ctx>>;

#[derive_where(Clone, Debug)]
pub struct RawDecidedBlock<Ctx: Context> {
    pub height: Ctx::Height,
    pub certificate: CommitCertificate<Ctx>,
    pub value_bytes: Bytes,
}

#[derive_where(Clone, Debug)]
pub struct InflightRequest<Ctx: Context> {
    pub peer_id: PeerId,
    pub request_id: OutboundRequestId,
    pub request: Request<Ctx>,
}

pub type InflightRequests<Ctx> = HashMap<OutboundRequestId, InflightRequest<Ctx>>;

#[derive_where(Debug)]
pub enum Msg<Ctx: Context> {
    /// Internal tick
    Tick,

    /// Receive an even from gossip layer
    NetworkEvent(NetworkEvent<Ctx>),

    /// Consensus has decided on a value at the given height
    Decided(Ctx::Height),

    /// Consensus has (re)started a new height.
    /// The boolean indicates whether this is a restart or not.
    StartedHeight(Ctx::Height, bool),

    /// Host has a response for the blocks request
    GotDecidedBlock(InboundRequestId, Ctx::Height, Option<RawDecidedValue<Ctx>>),

    /// A timeout has elapsed
    TimeoutElapsed(TimeoutElapsed<Timeout>),

    /// We received an invalid [`CommitCertificate`] from a peer
    InvalidCommitCertificate(PeerId, CommitCertificate<Ctx>, CertificateError<Ctx>),
}

impl<Ctx: Context> From<NetworkEvent<Ctx>> for Msg<Ctx> {
    fn from(event: NetworkEvent<Ctx>) -> Self {
        Msg::NetworkEvent(event)
    }
}

impl<Ctx: Context> From<TimeoutElapsed<Timeout>> for Msg<Ctx> {
    fn from(elapsed: TimeoutElapsed<Timeout>) -> Self {
        Msg::TimeoutElapsed(elapsed)
    }
}

#[derive(Debug)]
pub struct Params {
    pub status_update_interval: Duration,
    pub request_timeout: Duration,
}

impl Default for Params {
    fn default() -> Self {
        Self {
            status_update_interval: Duration::from_secs(5),
            request_timeout: Duration::from_secs(10),
        }
    }
}

pub struct State<Ctx: Context> {
    /// The state of the sync state machine
    sync: sync::State<Ctx>,

    /// Scheduler for timers
    timers: Timers,

    /// In-flight requests
    inflight: InflightRequests<Ctx>,

    /// Task for sending status updates
    ticker: JoinHandle<()>,
}

#[allow(dead_code)]
pub struct Sync<Ctx: Context> {
    ctx: Ctx,
    gossip: NetworkRef<Ctx>,
    host: HostRef<Ctx>,
    params: Params,
    metrics: sync::Metrics,
    span: tracing::Span,
}

impl<Ctx> Sync<Ctx>
where
    Ctx: Context,
{
    pub fn new(
        ctx: Ctx,
        gossip: NetworkRef<Ctx>,
        host: HostRef<Ctx>,
        params: Params,
        metrics: sync::Metrics,
        span: tracing::Span,
    ) -> Self {
        Self {
            ctx,
            gossip,
            host,
            params,
            metrics,
            span,
        }
    }

    pub async fn spawn(
        ctx: Ctx,
        gossip: NetworkRef<Ctx>,
        host: HostRef<Ctx>,
        params: Params,
        metrics: sync::Metrics,
        span: tracing::Span,
    ) -> Result<SyncRef<Ctx>, ractor::SpawnErr> {
        let actor = Self::new(ctx, gossip, host, params, metrics, span);
        let (actor_ref, _) = Actor::spawn(None, actor, ()).await?;
        Ok(actor_ref)
    }

    async fn process_input(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        state: &mut State<Ctx>,
        input: sync::Input<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        malachitebft_sync::process!(
            input: input,
            state: &mut state.sync,
            metrics: &self.metrics,
            with: effect => {
                self.handle_effect(myself, &mut state.timers, &mut state.inflight, effect).await
            }
        )
    }

    async fn get_history_min_height(&self) -> Result<Ctx::Height, ActorProcessingErr> {
        ractor::call!(self.host, |reply_to| HostMsg::GetHistoryMinHeight {
            reply_to
        })
        .map_err(|e| eyre!("Failed to get earliest history height: {e:?}").into())
    }

    async fn handle_effect(
        &self,
        myself: &ActorRef<Msg<Ctx>>,
        timers: &mut Timers,
        inflight: &mut InflightRequests<Ctx>,
        effect: sync::Effect<Ctx>,
    ) -> Result<sync::Resume<Ctx>, ActorProcessingErr> {
        use sync::Effect;

        match effect {
            Effect::BroadcastStatus(height) => {
                let history_min_height = self.get_history_min_height().await?;

                self.gossip.cast(NetworkMsg::BroadcastStatus(Status::new(
                    height,
                    history_min_height,
                )))?;
            }

            Effect::SendValueRequest(peer_id, value_request) => {
                let request = Request::ValueRequest(value_request);
                let result = ractor::call!(self.gossip, |reply_to| {
                    NetworkMsg::OutgoingRequest(peer_id, request.clone(), reply_to)
                });

                match result {
                    Ok(request_id) => {
                        let request_id = OutboundRequestId::new(request_id);

                        timers.start_timer(
                            Timeout::Request(request_id.clone()),
                            self.params.request_timeout,
                        );

                        inflight.insert(
                            request_id.clone(),
                            InflightRequest {
                                peer_id,
                                request_id,
                                request,
                            },
                        );
                    }
                    Err(e) => {
                        error!("Failed to send request to network layer: {e}");
                    }
                }
            }

            Effect::SendValueResponse(request_id, value_response) => {
                let response = Response::ValueResponse(value_response);
                self.gossip
                    .cast(NetworkMsg::OutgoingResponse(request_id, response))?;
            }

            Effect::GetDecidedValue(request_id, height) => {
                self.host.call_and_forward(
                    |reply_to| HostMsg::GetDecidedValue { height, reply_to },
                    myself,
                    move |synced_value| {
                        Msg::<Ctx>::GotDecidedBlock(request_id, height, synced_value)
                    },
                    None,
                )?;
            }
        }

        Ok(sync::Resume::default())
    }

    async fn handle_msg(
        &self,
        myself: ActorRef<Msg<Ctx>>,
        msg: Msg<Ctx>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        match msg {
            Msg::Tick => {
                self.process_input(&myself, state, sync::Input::Tick)
                    .await?;
            }

            Msg::NetworkEvent(NetworkEvent::PeerDisconnected(peer_id)) => {
                info!(%peer_id, "Disconnected from peer");

                if state.sync.peers.remove(&peer_id).is_some() {
                    debug!(%peer_id, "Removed disconnected peer");
                }
            }

            Msg::NetworkEvent(NetworkEvent::Status(peer_id, status)) => {
                let status = sync::Status {
                    peer_id,
                    tip_height: status.tip_height,
                    history_min_height: status.history_min_height,
                };

                self.process_input(&myself, state, sync::Input::Status(status))
                    .await?;
            }

            Msg::NetworkEvent(NetworkEvent::Request(request_id, from, request)) => {
                match request {
                    Request::ValueRequest(value_request) => {
                        self.process_input(
                            &myself,
                            state,
                            sync::Input::ValueRequest(request_id, from, value_request),
                        )
                        .await?;
                    }
                };
            }

            Msg::NetworkEvent(NetworkEvent::Response(request_id, peer, response)) => {
                // Cancel the timer associated with the request for which we just received a response
                state.timers.cancel(&Timeout::Request(request_id.clone()));

                match response {
                    Response::ValueResponse(value_response) => {
                        self.process_input(
                            &myself,
                            state,
                            sync::Input::ValueResponse(request_id, peer, value_response),
                        )
                        .await?;
                    }
                }
            }

            Msg::NetworkEvent(_) => {
                // Ignore other gossip events
            }

            // (Re)Started a new height
            Msg::StartedHeight(height, restart) => {
                self.process_input(&myself, state, sync::Input::StartedHeight(height, restart))
                    .await?
            }

            // Decided on a value
            Msg::Decided(height) => {
                self.process_input(&myself, state, sync::Input::Decided(height))
                    .await?;
            }

            Msg::GotDecidedBlock(request_id, height, block) => {
                self.process_input(
                    &myself,
                    state,
                    sync::Input::GotDecidedValue(request_id, height, block),
                )
                .await?;
            }

            Msg::InvalidCommitCertificate(peer, certificate, error) => {
                self.process_input(
                    &myself,
                    state,
                    sync::Input::InvalidCertificate(peer, certificate, error),
                )
                .await?
            }

            Msg::TimeoutElapsed(elapsed) => {
                let Some(timeout) = state.timers.intercept_timer_msg(elapsed) else {
                    // Timer was cancelled or already processed, ignore
                    return Ok(());
                };

                warn!(?timeout, "Timeout elapsed");

                match timeout {
                    Timeout::Request(request_id) => {
                        if let Some(inflight) = state.inflight.remove(&request_id) {
                            self.process_input(
                                &myself,
                                state,
                                sync::Input::SyncRequestTimedOut(
                                    inflight.peer_id,
                                    inflight.request,
                                ),
                            )
                            .await?;
                        } else {
                            debug!(%request_id, "Timeout for unknown request");
                        }
                    }
                }
            }
        }

        Ok(())
    }
}

#[async_trait]
impl<Ctx> Actor for Sync<Ctx>
where
    Ctx: Context,
{
    type Msg = Msg<Ctx>;
    type State = State<Ctx>;
    type Arguments = ();

    async fn pre_start(
        &self,
        myself: ActorRef<Self::Msg>,
        _args: Self::Arguments,
    ) -> Result<Self::State, ActorProcessingErr> {
        self.gossip
            .cast(NetworkMsg::Subscribe(Box::new(myself.clone())))?;

        let ticker = tokio::spawn(
            ticker(self.params.status_update_interval, myself.clone(), || {
                Msg::Tick
            })
            .in_current_span(),
        );

        let rng = Box::new(rand::rngs::StdRng::from_entropy());

        Ok(State {
            sync: sync::State::new(rng),
            timers: Timers::new(Box::new(myself.clone())),
            inflight: HashMap::new(),
            ticker,
        })
    }

    #[tracing::instrument(
        name = "sync",
        parent = &self.span,
        skip_all,
        fields(
            height.tip = %state.sync.tip_height,
            height.sync = %state.sync.sync_height,
        ),
    )]
    async fn handle(
        &self,
        myself: ActorRef<Self::Msg>,
        msg: Self::Msg,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        if let Err(e) = self.handle_msg(myself, msg, state).await {
            error!("Error handling message: {e:?}");
        }

        Ok(())
    }

    async fn post_stop(
        &self,
        _myself: ActorRef<Self::Msg>,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        state.ticker.abort();
        Ok(())
    }
}

```
---
### `engine/src/util/events.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use core::fmt;
use std::sync::Arc;

use derive_where::derive_where;
use ractor::ActorProcessingErr;
use tokio::sync::broadcast;

use malachitebft_core_consensus::{
    LocallyProposedValue, ProposedValue, SignedConsensusMsg, WalEntry,
};
use malachitebft_core_types::{
    CommitCertificate, Context, PolkaCertificate, Round, RoundCertificate, SignedVote, ValueOrigin,
};

pub type RxEvent<Ctx> = broadcast::Receiver<Event<Ctx>>;

#[derive_where(Clone)]
pub struct TxEvent<Ctx: Context> {
    tx: broadcast::Sender<Event<Ctx>>,
}

impl<Ctx: Context> TxEvent<Ctx> {
    pub fn new() -> Self {
        let (tx, _) = broadcast::channel(128);
        Self { tx }
    }

    pub fn subscribe(&self) -> broadcast::Receiver<Event<Ctx>> {
        self.tx.subscribe()
    }

    pub fn send(&self, event: impl FnOnce() -> Event<Ctx>) {
        if self.tx.receiver_count() > 0 {
            let _ = self.tx.send(event());
        }
    }
}

impl<Ctx: Context> Default for TxEvent<Ctx> {
    fn default() -> Self {
        Self::new()
    }
}

#[derive_where(Clone, Debug)]
pub enum Event<Ctx: Context> {
    StartedHeight(Ctx::Height, bool),
    StartedRound(Ctx::Height, Round),
    Published(SignedConsensusMsg<Ctx>),
    ProposedValue(LocallyProposedValue<Ctx>),
    ReceivedProposedValue(ProposedValue<Ctx>, ValueOrigin),
    Decided(CommitCertificate<Ctx>),
    RebroadcastVote(SignedVote<Ctx>),
    RebroadcastRoundCertificate(RoundCertificate<Ctx>),
    SkipRoundCertificate(RoundCertificate<Ctx>),
    PolkaCertificate(PolkaCertificate<Ctx>),
    WalReplayBegin(Ctx::Height, usize),
    WalReplayEntry(WalEntry<Ctx>),
    WalReplayDone(Ctx::Height),
    WalReplayError(Arc<ActorProcessingErr>),
}

impl<Ctx: Context> fmt::Display for Event<Ctx> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Event::StartedHeight(height, restart) => {
                write!(f, "StartedHeight(height: {height}, restart: {restart})")
            }
            Event::StartedRound(height, round) => {
                write!(f, "StartedRound(height: {height}, round: {round})")
            }
            Event::Published(msg) => write!(f, "Published(msg: {msg:?})"),
            Event::ProposedValue(value) => write!(f, "ProposedValue(value: {value:?})"),
            Event::ReceivedProposedValue(value, origin) => {
                write!(
                    f,
                    "ReceivedProposedValue(value: {value:?}, origin: {origin:?})"
                )
            }
            Event::Decided(cert) => write!(f, "Decided(value: {})", cert.value_id),
            Event::RebroadcastVote(vote) => write!(f, "RebroadcastVote(vote: {vote:?})"),
            Event::RebroadcastRoundCertificate(certificate) => write!(
                f,
                "RebroadcastRoundCertificate(certificate: {certificate:?})"
            ),
            Event::WalReplayBegin(height, count) => {
                write!(f, "WalReplayBegin(height: {height}, count: {count})")
            }
            Event::WalReplayEntry(entry) => write!(f, "WalReplayEntry(entry: {entry:?})"),
            Event::WalReplayDone(height) => write!(f, "WalReplayDone(height: {height})"),
            Event::WalReplayError(error) => write!(f, "WalReplayError({error})"),
            Event::PolkaCertificate(certificate) => {
                write!(f, "PolkaCertificate: {certificate:?})")
            }
            Event::SkipRoundCertificate(certificate) => {
                write!(f, "SkipRoundCertificate: {certificate:?})")
            }
        }
    }
}

```
---
### `engine/src/util/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod events;
pub mod msg_buffer;
pub mod output_port;
pub mod streaming;
pub mod ticker;
pub mod timers;

```
---
### `engine/src/util/msg_buffer.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::collections::VecDeque;

use malachitebft_core_types::Context;
use tracing::{info, warn};

use crate::consensus::ConsensusMsg;

pub struct MessageBuffer<Ctx: Context> {
    messages: VecDeque<ConsensusMsg<Ctx>>,
    max_size: usize,
}

impl<Ctx: Context> MessageBuffer<Ctx> {
    pub fn new(max_size: usize) -> Self {
        Self {
            messages: VecDeque::new(),
            max_size,
        }
    }

    pub fn buffer(&mut self, msg: ConsensusMsg<Ctx>) -> bool {
        if self.messages.len() < self.max_size {
            info!("Buffering message: {msg:?}");
            self.messages.push_back(msg);
            true
        } else {
            warn!("Buffer is full, dropping message: {msg:?}");
            false
        }
    }

    pub fn pop(&mut self) -> Option<ConsensusMsg<Ctx>> {
        self.messages.pop_front()
    }

    pub fn is_empty(&self) -> bool {
        self.messages.is_empty()
    }

    pub fn len(&self) -> usize {
        self.messages.len()
    }
}

```
---
### `engine/src/util/output_port.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
// Copyright (c) Sean Lawlor
//
// This source code is licensed under both the MIT license found in the
// LICENSE-MIT file in the root directory of this source tree.

//! Output ports for publish-subscribe notifications between actors
//!
//! This notion extends beyond traditional actors in this that is a publish-subscribe
//! mechanism we've added in `ractor`. Output ports are ports which can have messages published
//! to them which are automatically forwarded to downstream actors waiting for inputs. They optionally
//! have a message transformer attached to them to convert them to the appropriate message type

use std::sync::RwLock;

use ractor::concurrency::JoinHandle;
use ractor::{ActorRef, Message};
use tokio::sync::broadcast as pubsub;

/// Output messages, since they need to be replicated, require [Clone] in addition
/// to the base [Message] constraints
pub trait OutputMessage: Message + Clone {}
impl<T: Message + Clone> OutputMessage for T {}

/// An [OutputPort] is a publish-subscribe mechanism for connecting actors together.
/// It allows actors to emit messages without knowing which downstream actors are subscribed.
///
/// You can subscribe to the output port with an [ActorRef] and a message converter from the output
/// type to the actor's expected input type. If the actor is dropped or stops, the subscription will
/// be dropped and if the output port is dropped, then the subscription will also be dropped
/// automatically.
pub struct OutputPort<TMsg>
where
    TMsg: OutputMessage,
{
    tx: pubsub::Sender<Option<TMsg>>,
    subscriptions: RwLock<Vec<OutputPortSubscription>>,
}

impl<TMsg> Default for OutputPort<TMsg>
where
    TMsg: OutputMessage,
{
    fn default() -> Self {
        // We only need enough buffer for the subscription task to forward to the input port
        // of the receiving actor. Hence 10 should be plenty.
        Self::with_capacity(10)
    }
}

impl<TMsg> OutputPort<TMsg>
where
    TMsg: OutputMessage,
{
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_capacity(capacity: usize) -> Self {
        let (tx, _rx) = pubsub::channel(capacity);
        Self {
            tx,
            subscriptions: RwLock::new(vec![]),
        }
    }

    /// Subscribe to the output port, passing in a converter to convert to the input message
    /// of another actor
    ///
    /// * `receiver` - The reference to the actor which will receive forwarded messages
    /// * `converter` - The converter which will convert the output message type to the
    ///   receiver's input type and return [Some(_)] if the message should be forwarded, [None]
    ///   if the message should be skipped.
    pub fn subscribe<TReceiverMsg, F>(&self, receiver: ActorRef<TReceiverMsg>, converter: F)
    where
        F: Fn(TMsg) -> Option<TReceiverMsg> + Send + 'static,
        TReceiverMsg: Message,
    {
        let mut subs = self.subscriptions.write().unwrap();

        // filter out dead subscriptions, since they're no longer valid
        subs.retain(|sub| !sub.is_dead());

        let sub = OutputPortSubscription::new::<TMsg, F, TReceiverMsg>(
            self.tx.subscribe(),
            converter,
            receiver,
        );
        subs.push(sub);
    }

    /// Send a message on the output port
    ///
    /// * `msg`: The message to send
    pub fn send(&self, msg: TMsg) {
        if self.tx.receiver_count() > 0 {
            let _ = self.tx.send(Some(msg));
        }
    }
}

impl<TMsg> Drop for OutputPort<TMsg>
where
    TMsg: OutputMessage,
{
    fn drop(&mut self) {
        let mut subs = self.subscriptions.write().unwrap();
        for sub in subs.iter_mut() {
            sub.stop();
        }
        subs.clear();
    }
}

// ============== Subscription implementation ============== //

/// The output port's subscription handle. It holds a handle to a [JoinHandle]
/// which listens to the [pubsub::Receiver] to see if there's a new message, and if there is
/// forwards it to the [ActorRef] asynchronously using the specified converter.
struct OutputPortSubscription {
    handle: JoinHandle<()>,
}

impl OutputPortSubscription {
    /// Determine if the subscription is dead
    pub fn is_dead(&self) -> bool {
        self.handle.is_finished()
    }

    /// Stop the subscription, by aborting the underlying [JoinHandle]
    pub fn stop(&mut self) {
        self.handle.abort();
    }

    /// Create a new subscription
    pub fn new<TMsg, F, TReceiverMsg>(
        mut port: pubsub::Receiver<Option<TMsg>>,
        converter: F,
        receiver: ActorRef<TReceiverMsg>,
    ) -> Self
    where
        TMsg: OutputMessage,
        F: Fn(TMsg) -> Option<TReceiverMsg> + Send + 'static,
        TReceiverMsg: Message,
    {
        let handle = ractor::concurrency::spawn(async move {
            loop {
                match port.recv().await {
                    Err(tokio::sync::broadcast::error::RecvError::Lagged(l)) => {
                        tracing::warn!("Output port is lagging, we've dropped {l} messages!");
                    }
                    Ok(Some(msg)) => {
                        if let Some(new_msg) = converter(msg) {
                            if receiver.cast(new_msg).is_err() {
                                // kill the subscription process, as the forwarding agent is stopped
                                return;
                            }
                        }
                    }
                    Ok(None) => {
                        // skip this message
                    }
                    Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                        tracing::warn!("Subscription is dying due to closed channel!");
                        return;
                    }
                }
            }
        });

        Self { handle }
    }
}

/// Represents a boxed `ActorRef` subscriber capable of handling messages from a
/// publisher via an `OutputPort`, employing a publish-subscribe pattern to
/// decouple message broadcasting from handling. For a subscriber `ActorRef` to
/// function as an `OutputPortSubscriber<T>`, its message type must implement
/// `From<T>` to convert the published message type to its own message format.
///
/// # Example
/// ```
/// // First, define the publisher's message types, including a variant for
/// // subscribing `OutputPortSubscriber`s and another for publishing messages:
/// use ractor::{
///     cast,
///     port::{OutputPort, OutputPortSubscriber},
///     Actor, ActorProcessingErr, ActorRef, Message,
/// };
///
/// enum PublisherMessage {
///     Publish(u8),                         // Message type for publishing
///     Subscribe(OutputPortSubscriber<u8>), // Message type for subscribing an actor to the output port
/// }
///
/// #[cfg(feature = "cluster")]
/// impl Message for PublisherMessage {
///     fn serializable() -> bool {
///         false
///     }
/// }
///
/// // In the publisher actor's `handle` function, handle subscription requests and
/// // publish messages accordingly:
///
/// struct Publisher;
/// struct State {
///     output_port: OutputPort<u8>,
/// }
///
/// #[cfg_attr(feature = "async-trait", ractor::async_trait)]
/// impl Actor for Publisher {
///     type State = State;
///     type Msg = PublisherMessage;
///     type Arguments = ();
///
///     async fn pre_start(
///         &self,
///         _myself: ActorRef<Self::Msg>,
///         _: (),
///     ) -> Result<Self::State, ActorProcessingErr> {
///         Ok(State {
///             output_port: OutputPort::default(),
///         })
///     }
///
///     async fn handle(
///         &self,
///         _myself: ActorRef<Self::Msg>,
///         message: Self::Msg,
///         state: &mut Self::State,
///     ) -> Result<(), ActorProcessingErr> {
///         match message {
///             PublisherMessage::Subscribe(subscriber) => {
///                 // Subscribes the `OutputPortSubscriber` wrapped actor to the `OutputPort`
///                 subscriber.subscribe_to_port(&state.output_port);
///             }
///             PublisherMessage::Publish(value) => {
///                 // Broadcasts the `u8` value to all subscribed actors, which will handle the type conversion
///                 state.output_port.send(value);
///             }
///         }
///         Ok(())
///     }
/// }
///
/// // The subscriber's message type demonstrates how to transform the publisher's
/// // message type by implementing `From<T>`:
///
/// #[derive(Debug)]
/// enum SubscriberMessage {
///     Handle(String), // Subscriber's intent for message handling
/// }
///
/// #[cfg(feature = "cluster")]
/// impl Message for SubscriberMessage {
///     fn serializable() -> bool {
///         false
///     }
/// }
///
/// impl From<u8> for SubscriberMessage {
///     fn from(value: u8) -> Self {
///         SubscriberMessage::Handle(value.to_string()) // Converts u8 to String
///     }
/// }
///
/// // To subscribe a subscriber actor to the publisher and broadcast a message:
/// struct Subscriber;
/// #[cfg_attr(feature = "async-trait", ractor::async_trait)]
/// impl Actor for Subscriber {
///     type State = ();
///     type Msg = SubscriberMessage;
///     type Arguments = ();
///
///     async fn pre_start(
///         &self,
///         _myself: ActorRef<Self::Msg>,
///         _: (),
///     ) -> Result<Self::State, ActorProcessingErr> {
///         Ok(())
///     }
///
///     async fn handle(
///         &self,
///         _myself: ActorRef<Self::Msg>,
///         message: Self::Msg,
///         _state: &mut Self::State,
///     ) -> Result<(), ActorProcessingErr> {
///         Ok(())
///     }
/// }
/// async fn example() {
///     let (publisher_actor_ref, publisher_actor_handle) =
///         Actor::spawn(None, Publisher, ()).await.unwrap();
///     let (subscriber_actor_ref, subscriber_actor_handle) =
///         Actor::spawn(None, Subscriber, ()).await.unwrap();
///
///     publisher_actor_ref
///         .send_message(PublisherMessage::Subscribe(Box::new(subscriber_actor_ref)))
///         .unwrap();
///
///     // Broadcasting a message to all subscribers
///     publisher_actor_ref
///         .send_message(PublisherMessage::Publish(123))
///         .unwrap();
///
///     publisher_actor_handle.await.unwrap();
///     subscriber_actor_handle.await.unwrap();
/// }
/// ```
pub type OutputPortSubscriber<InputMessage> = Box<dyn OutputPortSubscriberTrait<InputMessage>>;

/// A trait for subscribing to an [OutputPort]
pub trait OutputPortSubscriberTrait<I>: Send
where
    I: Message + Clone,
{
    /// Subscribe to the output port
    fn subscribe_to_port(&self, port: &OutputPort<I>);
}

impl<I, O> OutputPortSubscriberTrait<I> for ActorRef<O>
where
    I: Message + Clone,
    O: Message + From<I>,
{
    fn subscribe_to_port(&self, port: &OutputPort<I>) {
        port.subscribe(self.clone(), |msg| Some(O::from(msg)));
    }
}

```
---
### `engine/src/util/streaming.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt;

use bytes::Bytes;

pub type Sequence = u64;

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StreamId(Bytes);

impl StreamId {
    pub fn new(bytes: Bytes) -> Self {
        Self(bytes)
    }

    pub fn to_bytes(&self) -> Bytes {
        self.0.clone()
    }
}

impl fmt::Display for StreamId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for byte in &self.0 {
            write!(f, "{byte:02x}")?;
        }
        Ok(())
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct StreamMessage<T> {
    /// Receivers identify streams by (sender, stream_id).
    /// This means each node can allocate stream_ids independently
    /// and that many streams can be sent on a single network topic.
    pub stream_id: StreamId,

    /// Identifies the sequence of each message in the stream starting from 0.
    pub sequence: Sequence,

    /// The content of this stream message
    pub content: StreamContent<T>,
}

impl<T> StreamMessage<T> {
    pub fn new(stream_id: StreamId, sequence: Sequence, content: StreamContent<T>) -> Self {
        Self {
            stream_id,
            sequence,
            content,
        }
    }

    pub fn is_first(&self) -> bool {
        self.sequence == 0
    }

    pub fn is_fin(&self) -> bool {
        self.content.is_fin()
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum StreamContent<T> {
    /// Serialized content.
    Data(T),

    /// Indicates the end of the stream.
    Fin,
}

impl<T> StreamContent<T> {
    pub fn as_data(&self) -> Option<&T> {
        match self {
            Self::Data(data) => Some(data),
            _ => None,
        }
    }

    pub fn into_data(self) -> Option<T> {
        match self {
            Self::Data(data) => Some(data),
            _ => None,
        }
    }

    pub fn is_fin(&self) -> bool {
        matches!(self, Self::Fin)
    }
}

```
---
### `engine/src/util/ticker.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::time::Duration;

use ractor::message::Message;
use ractor::ActorRef;

pub async fn ticker<Msg>(interval: Duration, target: ActorRef<Msg>, msg: impl Fn() -> Msg)
where
    Msg: Message,
{
    loop {
        tokio::time::sleep(interval).await;

        if let Err(e) = target.cast(msg()) {
            tracing::error!(target = %target.get_id(), "Failed to send tick message: {e}");
            break;
        }
    }
}

```
---
### `engine/src/util/timers.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
use core::fmt;
use std::collections::hash_map::Entry;
use std::collections::HashMap;
use std::fmt::Debug;
use std::hash::Hash;
use std::ops::RangeFrom;
use std::sync::Arc;
use std::time::Duration;

use tokio::task::JoinHandle;
use tracing::trace;

use super::output_port::{OutputPort, OutputPortSubscriber};

#[derive(Debug)]
struct Timer<Key> {
    /// Message to give to the actor when the timer expires
    key: Key,

    // Task that will notify the actor that the timer has elapsed
    task: JoinHandle<()>,

    /// Generation counter to the timer to check if we received a timeout
    /// message from an old timer that was enqueued in mailbox before canceled
    generation: u64,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct TimeoutElapsed<Key> {
    key: Key,
    generation: u64,
}

impl<Key> TimeoutElapsed<Key> {
    pub fn display_key(&self) -> &dyn fmt::Display
    where
        Key: fmt::Display,
    {
        &self.key
    }
}

pub struct TimerScheduler<Key>
where
    Key: Clone + Eq + Hash + Send + 'static,
{
    output_port: Arc<OutputPort<TimeoutElapsed<Key>>>,
    timers: HashMap<Key, Timer<Key>>,
    generations: RangeFrom<u64>,
}

impl<Key> TimerScheduler<Key>
where
    Key: Clone + Eq + Hash + Send + 'static,
{
    pub fn new(subscriber: OutputPortSubscriber<TimeoutElapsed<Key>>) -> Self {
        let output_port = OutputPort::with_capacity(32);
        subscriber.subscribe_to_port(&output_port);

        Self {
            output_port: Arc::new(output_port),
            timers: HashMap::new(),
            generations: 1..,
        }
    }

    /// Start a timer that will send `msg` once to the actor after the given `timeout`.
    ///
    /// Each timer has a key and if a new timer with same key is started
    /// the previous is cancelled.
    ///
    /// # Warning
    /// It is NOT guaranteed that a message from the previous timer is not received,
    /// as it could already be enqueued in the mailbox when the new timer was started.
    ///
    /// When the actor receives a timeout message for timer from the scheduler, it should
    /// check if the timer is still active by calling [`TimerScheduler::intercept_timer_msg`]
    /// and ignore the message otherwise.
    pub fn start_timer(&mut self, key: Key, timeout: Duration)
    where
        Key: Clone + Send + 'static,
    {
        self.cancel(&key);

        let generation = self
            .generations
            .next()
            .expect("generation counter overflowed");

        let task = {
            let key = key.clone();
            let output_port = Arc::clone(&self.output_port);

            tokio::spawn(async move {
                tokio::time::sleep(timeout).await;
                output_port.send(TimeoutElapsed { key, generation })
            })
        };

        self.timers.insert(
            key.clone(),
            Timer {
                key,
                task,
                generation,
            },
        );
    }

    /// Check if a timer with a given `key` is active, ie. it hasn't been canceled nor has it elapsed yet.
    pub fn is_timer_active(&self, key: &Key) -> bool {
        self.timers.contains_key(key)
    }

    /// Cancel a timer with a given `key`.
    ///
    /// If canceling a timer that was already canceled, or key never was used to start a timer
    /// this operation will do nothing.
    ///
    /// # Warning
    /// It is NOT guaranteed that a message from a canceled timer, including its previous incarnation
    /// for the same key, will not be received by the actor, as the message might already
    /// be enqueued in the mailbox when cancel is called.
    ///
    /// When the actor receives a timeout message for timer from the scheduler, it should
    /// check if the timer is still active by calling [`TimerScheduler::intercept_timer_msg`]
    /// and ignore the message otherwise.
    pub fn cancel(&mut self, key: &Key) {
        if let Some(timer) = self.timers.remove(key) {
            timer.task.abort();
        }
    }

    /// Cancel all timers.
    pub fn cancel_all(&mut self) {
        self.timers.drain().for_each(|(_, timer)| {
            timer.task.abort();
        });
    }

    /// Intercepts a timer message and checks the state of the timer associated with the provided `timer_msg`:
    ///
    /// 1. If the timer message was from canceled timer that was already enqueued in mailbox, returns `None`.
    /// 2. If the timer message was from an old timer that was enqueued in mailbox before being canceled, returns `None`.
    /// 3. Otherwise it is a valid timer message, returns the associated `Key` wrapped in `Some`.
    pub fn intercept_timer_msg(&mut self, timer_msg: TimeoutElapsed<Key>) -> Option<Key>
    where
        Key: Debug,
    {
        match self.timers.entry(timer_msg.key) {
            // The timer message was from canceled timer that was already enqueued in mailbox
            Entry::Vacant(entry) => {
                let key = entry.key();
                trace!("Received timer {key:?} that has been removed, discarding");
                None
            }

            // The timer message was from an old timer that was enqueued in mailbox before being canceled
            Entry::Occupied(entry) if timer_msg.generation != entry.get().generation => {
                let (key, timer) = (entry.key(), entry.get());

                trace!(
                    "Received timer {key:?} from old generation {}, expected generation {}, discarding",
                    timer_msg.generation,
                    timer.generation,
                );

                None
            }

            // Valid timer message
            Entry::Occupied(entry) => {
                let timer = entry.remove();
                Some(timer.key)
            }
        }
    }
}

impl<Key> Drop for TimerScheduler<Key>
where
    Key: Clone + Eq + Hash + Send + 'static,
{
    fn drop(&mut self) {
        self.cancel_all();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use ractor::{Actor, ActorRef};
    use std::time::Duration;
    use tokio::time::sleep;

    #[derive(Copy, Debug, Clone, PartialEq, Eq, Hash)]
    struct TestKey(&'static str);

    #[derive(Debug)]
    struct TestMsg(TimeoutElapsed<TestKey>);

    impl From<TimeoutElapsed<TestKey>> for TestMsg {
        fn from(timer_msg: TimeoutElapsed<TestKey>) -> Self {
            TestMsg(timer_msg)
        }
    }

    struct TestActor;

    #[async_trait::async_trait]
    impl Actor for TestActor {
        type State = ();
        type Arguments = ();
        type Msg = TestMsg;

        async fn pre_start(
            &self,
            _myself: ActorRef<TestMsg>,
            _args: (),
        ) -> Result<(), ractor::ActorProcessingErr> {
            Ok(())
        }

        async fn handle(
            &self,
            _myself: ActorRef<TestMsg>,
            TestMsg(elapsed): TestMsg,
            _state: &mut (),
        ) -> Result<(), ractor::ActorProcessingErr> {
            println!("Received timer message: {elapsed:?}");
            Ok(())
        }
    }

    async fn spawn() -> TimerScheduler<TestKey> {
        let actor_ref = TestActor::spawn(None, TestActor, ()).await.unwrap().0;
        // let subscriber: OutputPortSubscriber<TimeoutElapsed<TestKey>> = ;
        TimerScheduler::new(Box::new(actor_ref))
    }

    #[tokio::test]
    async fn test_start_timer() {
        let mut scheduler = spawn().await;
        let key = TestKey("timer1");

        scheduler.start_timer(key, Duration::from_millis(100));
        assert!(scheduler.is_timer_active(&key));

        sleep(Duration::from_millis(150)).await;
        let elapsed_key = scheduler.intercept_timer_msg(TimeoutElapsed { key, generation: 1 });
        assert_eq!(elapsed_key, Some(key));

        assert!(!scheduler.is_timer_active(&key));
    }

    #[tokio::test]
    async fn test_cancel_timer() {
        let mut scheduler = spawn().await;
        let key = TestKey("timer1");

        scheduler.start_timer(key, Duration::from_millis(100));
        scheduler.cancel(&key);

        assert!(!scheduler.is_timer_active(&key));
    }

    #[tokio::test]
    async fn test_cancel_all_timers() {
        let mut scheduler = spawn().await;

        scheduler.start_timer(TestKey("timer1"), Duration::from_millis(100));
        scheduler.start_timer(TestKey("timer2"), Duration::from_millis(200));

        scheduler.cancel_all();

        assert!(!scheduler.is_timer_active(&TestKey("timer1")));
        assert!(!scheduler.is_timer_active(&TestKey("timer2")));
    }

    #[tokio::test]
    async fn test_intercept_timer_msg_valid() {
        let mut scheduler = spawn().await;
        let key = TestKey("timer1");

        scheduler.start_timer(key, Duration::from_millis(100));
        sleep(Duration::from_millis(150)).await;

        let timer_msg = TimeoutElapsed { key, generation: 1 };

        let intercepted_msg = scheduler.intercept_timer_msg(timer_msg);

        assert_eq!(intercepted_msg, Some(key));
    }

    #[tokio::test]
    async fn test_intercept_timer_msg_invalid_generation() {
        let mut scheduler = spawn().await;
        let key = TestKey("timer1");

        scheduler.start_timer(key, Duration::from_millis(100));
        scheduler.start_timer(key, Duration::from_millis(200));

        let timer_msg = TimeoutElapsed { key, generation: 1 };

        let intercepted_msg = scheduler.intercept_timer_msg(timer_msg);

        assert_eq!(intercepted_msg, None);
    }

    #[tokio::test]
    async fn test_intercept_timer_msg_cancelled() {
        let mut scheduler = spawn().await;
        let key = TestKey("timer1");

        scheduler.start_timer(key, Duration::from_millis(100));
        scheduler.cancel(&key);

        let timer_msg = TimeoutElapsed { key, generation: 1 };

        let intercepted_msg = scheduler.intercept_timer_msg(timer_msg);

        assert_eq!(intercepted_msg, None);
    }
}

```
---
### `engine/src/wal/entry.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use std::io::{self, Read, Write};

use byteorder::{ReadBytesExt, WriteBytesExt, BE};

use malachitebft_codec::Codec;
use malachitebft_core_consensus::{ProposedValue, SignedConsensusMsg};
use malachitebft_core_types::{Context, Round, Timeout};

/// Codec for encoding and decoding WAL entries.
///
/// This trait is automatically implemented for any type that implements:
/// - [`Codec<SignedConsensusMsg<Ctx>>`]
pub trait WalCodec<Ctx>
where
    Ctx: Context,
    Self: Codec<SignedConsensusMsg<Ctx>>,
    Self: Codec<ProposedValue<Ctx>>,
{
}

impl<Ctx, C> WalCodec<Ctx> for C
where
    Ctx: Context,
    C: Codec<SignedConsensusMsg<Ctx>>,
    C: Codec<ProposedValue<Ctx>>,
{
}

pub use malachitebft_core_consensus::WalEntry;

const TAG_CONSENSUS: u8 = 0x01;
const TAG_TIMEOUT: u8 = 0x02;
const TAG_PROPOSED_VALUE: u8 = 0x04;

pub fn encode_entry<Ctx, C, W>(entry: &WalEntry<Ctx>, codec: &C, buf: W) -> io::Result<()>
where
    Ctx: Context,
    C: WalCodec<Ctx>,
    W: Write,
{
    match entry {
        WalEntry::ConsensusMsg(msg) => encode_consensus_msg(TAG_CONSENSUS, msg, codec, buf),
        WalEntry::Timeout(timeout) => encode_timeout(TAG_TIMEOUT, timeout, buf),
        WalEntry::ProposedValue(value) => {
            encode_proposed_value(TAG_PROPOSED_VALUE, value, codec, buf)
        }
    }
}

pub fn decode_entry<Ctx, C, R>(codec: &C, mut buf: R) -> io::Result<WalEntry<Ctx>>
where
    Ctx: Context,
    C: WalCodec<Ctx>,
    R: Read,
{
    let tag = buf.read_u8()?;

    match tag {
        TAG_CONSENSUS => decode_consensus_msg(codec, buf).map(WalEntry::ConsensusMsg),
        TAG_TIMEOUT => decode_timeout(buf).map(WalEntry::Timeout),
        TAG_PROPOSED_VALUE => decode_proposed_value(codec, buf).map(WalEntry::ProposedValue),
        _ => Err(io::Error::new(io::ErrorKind::InvalidData, "invalid tag")),
    }
}

// Consensus message helpers
fn encode_consensus_msg<Ctx, C, W>(
    tag: u8,
    msg: &SignedConsensusMsg<Ctx>,
    codec: &C,
    mut buf: W,
) -> io::Result<()>
where
    Ctx: Context,
    C: WalCodec<Ctx>,
    W: Write,
{
    let bytes = codec.encode(msg).map_err(|e| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            format!("failed to encode consensus message: {e}"),
        )
    })?;

    // Write tag
    buf.write_u8(tag)?;

    // Write encoded length
    buf.write_u64::<BE>(bytes.len() as u64)?;

    // Write encoded bytes
    buf.write_all(&bytes)?;

    Ok(())
}

fn decode_consensus_msg<Ctx, C, R>(codec: &C, mut buf: R) -> io::Result<SignedConsensusMsg<Ctx>>
where
    Ctx: Context,
    C: WalCodec<Ctx>,
    R: Read,
{
    let len = buf.read_u64::<BE>()?;
    let mut bytes = vec![0; len as usize];
    buf.read_exact(&mut bytes)?;

    codec.decode(bytes.into()).map_err(|e| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            format!("failed to decode consensus msg: {e}"),
        )
    })
}

// Timeout helpers
fn encode_timeout(tag: u8, timeout: &Timeout, mut buf: impl Write) -> io::Result<()> {
    use malachitebft_core_types::TimeoutKind;

    let step = match timeout.kind {
        TimeoutKind::Propose => 1,
        TimeoutKind::Prevote => 2,
        TimeoutKind::Precommit => 3,

        // NOTE: Commit, prevote and precommit time limit timeouts have been removed.

        // Consensus will typically not want to store these timeouts in the WAL,
        // but we still need to handle them here.
        TimeoutKind::Rebroadcast => 7,
    };

    buf.write_u8(tag)?;
    buf.write_u8(step)?;
    buf.write_i64::<BE>(timeout.round.as_i64())?;

    Ok(())
}

fn decode_timeout(mut buf: impl Read) -> io::Result<Timeout> {
    use malachitebft_core_types::TimeoutKind;

    let step = match buf.read_u8()? {
        1 => TimeoutKind::Propose,
        2 => TimeoutKind::Prevote,
        3 => TimeoutKind::Precommit,

        // Commit timeouts have been removed in PR #976,
        // but we still need to handle them here in order to decode old WAL entries.
        4 => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "commit timeouts are no longer supported, ignoring",
            ))
        }

        // Prevote/precommit rebroadcast timeouts have been removed in PR #1037,
        // but we still need to handle them here in order to decode old WAL entries.
        5 | 6 => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "prevote/precommit time limit timeouts are no longer supported, ignoring",
            ))
        }

        // Consensus will typically not want to store these timeouts in the WAL,
        // but we still need to handle them here.
        7 => TimeoutKind::Rebroadcast,

        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "invalid timeout step",
            ))
        }
    };

    let round = Round::from(buf.read_i64::<BE>()?);

    Ok(Timeout::new(round, step))
}

// Proposed value helpers
fn encode_proposed_value<Ctx, C, W>(
    tag: u8,
    value: &ProposedValue<Ctx>,
    codec: &C,
    mut buf: W,
) -> io::Result<()>
where
    Ctx: Context,
    C: WalCodec<Ctx>,
    W: Write,
{
    let bytes = codec.encode(value).map_err(|e| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            format!("failed to encode consensus message: {e}"),
        )
    })?;

    // Write tag
    buf.write_u8(tag)?;

    // Write encoded length
    buf.write_u64::<BE>(bytes.len() as u64)?;

    // Write encoded bytes
    buf.write_all(&bytes)?;

    Ok(())
}

fn decode_proposed_value<Ctx, C, R>(codec: &C, mut buf: R) -> io::Result<ProposedValue<Ctx>>
where
    Ctx: Context,
    C: WalCodec<Ctx>,
    R: Read,
{
    let len = buf.read_u64::<BE>()?;
    let mut bytes = vec![0; len as usize];
    buf.read_exact(&mut bytes)?;

    codec.decode(bytes.into()).map_err(|e| {
        io::Error::new(
            io::ErrorKind::InvalidData,
            format!("failed to decode proposed value: {e}"),
        )
    })
}

```
---
### `engine/src/wal/iter.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::io;
use std::marker::PhantomData;

use malachitebft_core_types::Context;
use malachitebft_wal as wal;

use eyre::Result;

use super::entry::decode_entry;
use super::{WalCodec, WalEntry};

pub fn log_entries<'a, Ctx, Codec>(
    log: &'a mut wal::Log,
    codec: &'a Codec,
) -> Result<WalIter<'a, Ctx, Codec>>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    Ok(WalIter {
        iter: log.iter()?,
        codec,
        _marker: PhantomData,
    })
}

pub struct WalIter<'a, Ctx, Codec> {
    iter: wal::LogIter<'a>,
    codec: &'a Codec,
    _marker: PhantomData<Ctx>,
}

impl<Ctx, Codec> Iterator for WalIter<'_, Ctx, Codec>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    type Item = Result<WalEntry<Ctx>>;

    fn next(&mut self) -> Option<Self::Item> {
        let entry = self.iter.next()?;
        match entry {
            Ok(bytes) => {
                let buf = io::Cursor::new(bytes);
                let entry = decode_entry(self.codec, buf);
                Some(entry.map_err(Into::into))
            }
            Err(e) => Some(Err(e.into())),
        }
    }
}

```
---
### `engine/src/wal/thread.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use std::ops::ControlFlow;
use std::thread::JoinHandle;
use std::{io, thread};

use eyre::Result;
use tokio::sync::{mpsc, oneshot};
use tracing::{debug, error, info};

use malachitebft_core_types::{Context, Height};
use malachitebft_wal as wal;

use super::entry::{decode_entry, encode_entry, WalCodec, WalEntry};
use super::iter::log_entries;

pub type ReplyTo<T> = oneshot::Sender<Result<T>>;

pub enum WalMsg<Ctx: Context> {
    StartedHeight(Ctx::Height, ReplyTo<Vec<WalEntry<Ctx>>>),
    Reset(Ctx::Height, ReplyTo<()>),
    Append(WalEntry<Ctx>, ReplyTo<()>),
    Flush(ReplyTo<()>),
    Shutdown,
    Dump,
}

pub fn spawn<Ctx, Codec>(
    span: tracing::Span,
    mut log: wal::Log,
    codec: Codec,
    mut rx: mpsc::Receiver<WalMsg<Ctx>>,
) -> JoinHandle<()>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    thread::spawn(move || {
        while let Some(msg) = rx.blocking_recv() {
            match process_msg(msg, &span, &mut log, &codec) {
                Ok(ControlFlow::Continue(())) => continue,
                Ok(ControlFlow::Break(())) => break,
                Err(e) => error!("WAL task failed: {e}"),
            }
        }

        // Task finished normally, stop the thread
        drop(log);
    })
}

#[tracing::instrument(
    name = "wal",
    parent = span,
    skip_all,
    fields(height = span_sequence(log.sequence(), &msg))
)]
fn process_msg<Ctx, Codec>(
    msg: WalMsg<Ctx>,
    span: &tracing::Span,
    log: &mut wal::Log,
    codec: &Codec,
) -> Result<ControlFlow<()>>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    match msg {
        WalMsg::StartedHeight(height, reply) => {
            // FIXME: Ensure this works even with fork_id
            let sequence = height.as_u64();

            if sequence == log.sequence() {
                // WAL is already at that sequence
                // Let's check if there are any entries to replay
                let entries = fetch_entries(log, codec);

                if reply.send(entries).is_err() {
                    error!("Failed to send WAL replay reply");
                }
            } else {
                // WAL is at different sequence, restart it
                // No entries to replay
                let result = log
                    .restart(sequence)
                    .map(|_| Vec::new())
                    .map_err(Into::into);

                debug!(%height, "Reset WAL");

                if reply.send(result).is_err() {
                    error!("Failed to send WAL reset reply");
                }
            }
        }

        WalMsg::Reset(height, reply) => {
            let sequence = height.as_u64();

            let result = log.restart(sequence).map_err(Into::into);

            debug!(%height, "Reset WAL");

            if reply.send(result).is_err() {
                error!("Failed to send WAL reset reply");
            }
        }

        WalMsg::Append(entry, reply) => {
            let tpe = wal_entry_type(&entry);

            let mut buf = Vec::new();
            encode_entry(&entry, codec, &mut buf)?;

            if !buf.is_empty() {
                let result = log.append(&buf).map_err(Into::into);

                if let Err(e) = &result {
                    error!("ATTENTION: Failed to append entry to WAL: {e}");
                } else {
                    debug!(
                        type = %tpe, entry.size = %buf.len(), log.entries = %log.len(),
                        "Wrote log entry"
                    );
                }

                if reply.send(result).is_err() {
                    error!("Failed to send WAL append reply");
                }
            }
        }

        WalMsg::Flush(reply) => {
            let result = log.flush().map_err(Into::into);

            if let Err(e) = &result {
                error!("ATTENTION: Failed to flush WAL to disk: {e}");
            } else {
                debug!(
                    wal.entries = %log.len(),
                    wal.size = %log.size_bytes().unwrap_or(0),
                    "Flushed WAL to disk"
                );
            }

            if reply.send(result).is_err() {
                error!("Failed to send WAL flush reply");
            }
        }

        WalMsg::Dump => {
            if let Err(e) = dump_entries(log, codec) {
                error!("Failed to dump WAL: {e}");
            }
        }

        WalMsg::Shutdown => {
            info!("Shutting down WAL thread");
            return Ok(ControlFlow::Break(()));
        }
    }

    Ok(ControlFlow::Continue(()))
}

fn fetch_entries<Ctx, Codec>(log: &mut wal::Log, codec: &Codec) -> Result<Vec<WalEntry<Ctx>>>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    if log.is_empty() {
        return Ok(Vec::new());
    }

    let entries = log
        .iter()?
        .enumerate() // Add enumeration to get the index
        .filter_map(|(idx, result)| match result {
            Ok(entry) => Some((idx, entry)),
            Err(e) => {
                error!("Failed to retrieve WAL entry {idx}: {e}");
                None
            }
        })
        .filter_map(
            |(idx, bytes)| match decode_entry(codec, io::Cursor::new(bytes.clone())) {
                Ok(entry) => Some(entry),
                Err(e) => {
                    error!("Failed to decode WAL entry {idx}: {e} {:?}", bytes);
                    None
                }
            },
        )
        .collect::<Vec<_>>();

    if log.len() != entries.len() {
        Err(eyre::eyre!(
            "Failed to fetch and decode all WAL entries: expected {}, got {}",
            log.len(),
            entries.len()
        ))
    } else {
        Ok(entries)
    }
}

fn dump_entries<'a, Ctx, Codec>(log: &'a mut wal::Log, codec: &'a Codec) -> Result<()>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    let len = log.len();
    let mut count = 0;

    info!("WAL Dump");
    info!("- Entries: {len}");
    info!("- Size:    {} bytes", log.size_bytes().unwrap_or(0));
    info!("Entries:");

    for (idx, entry) in log_entries(log, codec)?.enumerate() {
        count += 1;

        match entry {
            Ok(entry) => {
                info!("- #{idx}: {entry:?}");
            }
            Err(e) => {
                error!("- #{idx}: Error decoding WAL entry: {e}");
            }
        }
    }

    if count != len {
        error!("Expected {len} entries, but found {count} entries");
    }

    Ok(())
}

fn span_sequence(sequence: u64, msg: &WalMsg<impl Context>) -> u64 {
    if let WalMsg::StartedHeight(height, _) = msg {
        height.as_u64()
    } else {
        sequence
    }
}

fn wal_entry_type<Ctx: Context>(entry: &WalEntry<Ctx>) -> &'static str {
    use malachitebft_core_consensus::SignedConsensusMsg;

    match entry {
        WalEntry::ConsensusMsg(msg) => match msg {
            SignedConsensusMsg::Vote(_) => "Consensus(Vote)",
            SignedConsensusMsg::Proposal(_) => "Consensus(Proposal)",
        },
        WalEntry::ProposedValue(_) => "LocallyProposedValue",
        WalEntry::Timeout(_) => "Timeout",
    }
}

```
---
### `engine/src/wal.rs`
*2025-05-18 23:58:49 | 8 KB*
```rust
use std::marker::PhantomData;
use std::path::PathBuf;

use eyre::eyre;
use ractor::{async_trait, Actor, ActorProcessingErr, ActorRef, RpcReplyPort, SpawnErr};
use tokio::sync::{mpsc, oneshot};
use tracing::{debug, error, info};

use malachitebft_core_types::{Context, Height};
use malachitebft_metrics::SharedRegistry;
use malachitebft_wal as wal;

mod entry;
mod iter;
mod thread;

pub use entry::WalCodec;
pub use entry::WalEntry;
pub use iter::log_entries;

pub type WalRef<Ctx> = ActorRef<Msg<Ctx>>;

pub struct Wal<Ctx, Codec> {
    span: tracing::Span,
    _marker: PhantomData<(Ctx, Codec)>,
}

impl<Ctx, Codec> Wal<Ctx, Codec>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    pub fn new(span: tracing::Span) -> Self {
        Self {
            span,
            _marker: PhantomData,
        }
    }

    pub async fn spawn(
        _ctx: &Ctx,
        codec: Codec,
        path: PathBuf,
        _metrics: SharedRegistry,
        span: tracing::Span,
    ) -> Result<WalRef<Ctx>, SpawnErr> {
        let (actor_ref, _) = Actor::spawn(None, Self::new(span), Args { path, codec }).await?;
        Ok(actor_ref)
    }
}

pub type WalReply<T> = RpcReplyPort<eyre::Result<T>>;

pub enum Msg<Ctx: Context> {
    StartedHeight(Ctx::Height, WalReply<Option<Vec<WalEntry<Ctx>>>>),
    Reset(Ctx::Height, WalReply<()>),
    Append(Ctx::Height, WalEntry<Ctx>, WalReply<()>),
    Flush(WalReply<()>),
    Dump,
}

pub struct Args<Codec> {
    pub path: PathBuf,
    pub codec: Codec,
}

pub struct State<Ctx: Context> {
    height: Ctx::Height,
    wal_sender: mpsc::Sender<self::thread::WalMsg<Ctx>>,
    _handle: std::thread::JoinHandle<()>,
}

impl<Ctx, Codec> Wal<Ctx, Codec>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    async fn handle_msg(
        &self,
        _myself: WalRef<Ctx>,
        msg: Msg<Ctx>,
        state: &mut State<Ctx>,
    ) -> Result<(), ActorProcessingErr> {
        match msg {
            Msg::StartedHeight(height, reply_to) => {
                if state.height == height {
                    debug!(%height, "WAL already at height, ignoring");
                    return Ok(());
                }

                state.height = height;

                self.started_height(state, height, reply_to).await?;
            }

            Msg::Reset(height, reply_to) => {
                self.reset(state, height, reply_to).await?;
            }

            Msg::Append(height, entry, reply_to) => {
                if height != state.height {
                    debug!("Ignoring append at height {} != {}", height, state.height);
                    return Ok(());
                }

                self.write_log(state, entry, reply_to).await?;
            }

            Msg::Flush(reply_to) => {
                self.flush_log(state, reply_to).await?;
            }

            Msg::Dump => {
                state.wal_sender.send(self::thread::WalMsg::Dump).await?;
            }
        }

        Ok(())
    }

    async fn reset(
        &self,
        state: &mut State<Ctx>,
        height: Ctx::Height,
        reply_to: WalReply<()>,
    ) -> Result<(), ActorProcessingErr> {
        let (tx, rx) = oneshot::channel();

        state
            .wal_sender
            .send(self::thread::WalMsg::Reset(height, tx))
            .await?;

        let result = rx.await?;

        reply_to
            .send(result)
            .map_err(|e| eyre!("Failed to send reply: {e}"))?;

        Ok(())
    }

    async fn started_height(
        &self,
        state: &mut State<Ctx>,
        height: <Ctx as Context>::Height,
        reply_to: WalReply<Option<Vec<WalEntry<Ctx>>>>,
    ) -> Result<(), ActorProcessingErr> {
        let (tx, rx) = oneshot::channel();

        state
            .wal_sender
            .send(self::thread::WalMsg::StartedHeight(height, tx))
            .await?;

        let to_replay = rx
            .await?
            .map(|entries| Some(entries).filter(|entries| !entries.is_empty()));

        reply_to
            .send(to_replay)
            .map_err(|e| eyre!("Failed to send reply: {e}"))?;

        Ok(())
    }

    async fn write_log(
        &self,
        state: &mut State<Ctx>,
        msg: impl Into<WalEntry<Ctx>>,
        reply_to: WalReply<()>,
    ) -> Result<(), ActorProcessingErr> {
        let entry = msg.into();
        let (tx, rx) = oneshot::channel();

        state
            .wal_sender
            .send(self::thread::WalMsg::Append(entry, tx))
            .await?;

        let result = rx.await?;

        reply_to
            .send(result)
            .map_err(|e| eyre!("Failed to send reply: {e}"))?;

        Ok(())
    }

    async fn flush_log(
        &self,
        state: &mut State<Ctx>,
        reply_to: WalReply<()>,
    ) -> Result<(), ActorProcessingErr> {
        let (tx, rx) = oneshot::channel();

        state
            .wal_sender
            .send(self::thread::WalMsg::Flush(tx))
            .await?;

        let result = rx.await?;

        reply_to
            .send(result)
            .map_err(|e| eyre!("Failed to send reply: {e}"))?;

        Ok(())
    }
}

#[async_trait]
impl<Ctx, Codec> Actor for Wal<Ctx, Codec>
where
    Ctx: Context,
    Codec: WalCodec<Ctx>,
{
    type Msg = Msg<Ctx>;
    type Arguments = Args<Codec>;
    type State = State<Ctx>;

    #[tracing::instrument(
        name = "wal.pre_start",
        parent = &self.span,
        skip_all,
    )]
    async fn pre_start(
        &self,
        _myself: WalRef<Ctx>,
        args: Self::Arguments,
    ) -> Result<Self::State, ActorProcessingErr> {
        let log = wal::Log::open(&args.path)?;
        info!("Opened WAL at {}", args.path.display());

        let (tx, rx) = mpsc::channel(100);

        // Spawn a system thread to perform blocking WAL operations.
        let handle = self::thread::spawn(self.span.clone(), log, args.codec, rx);

        Ok(State {
            height: Ctx::Height::ZERO,
            wal_sender: tx,
            _handle: handle,
        })
    }

    #[tracing::instrument(
        name = "wal",
        parent = &self.span,
        skip_all,
        fields(height = %span_height(state.height, &msg)),
    )]
    async fn handle(
        &self,
        myself: WalRef<Ctx>,
        msg: Self::Msg,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        if let Err(e) = self.handle_msg(myself, msg, state).await {
            error!("Failed to handle WAL message: {e}");
        }

        Ok(())
    }

    #[tracing::instrument(
        name = "wal.post_stop",
        parent = &self.span,
        skip_all,
        fields(height = %state.height),
    )]
    async fn post_stop(
        &self,
        _: WalRef<Ctx>,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        info!("Shutting down WAL");

        let _ = state.wal_sender.send(self::thread::WalMsg::Shutdown).await;

        Ok(())
    }
}

/// Use the height we are about to start instead of the current height
/// for the tracing span of the WAL actor when starting a new height.
fn span_height<Ctx: Context>(height: Ctx::Height, msg: &Msg<Ctx>) -> Ctx::Height {
    if let Msg::StartedHeight(h, _) = msg {
        *h
    } else {
        height
    }
}

```
---
### `metrics/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-metrics"
description = "Metrics for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
malachitebft-core-state-machine.workspace = true
prometheus-client.workspace = true

[lints]
workspace = true

```
---
### `metrics/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
mod registry;
pub use registry::{export, Registry, SharedRegistry};

mod metrics;
pub use metrics::Metrics;

pub use prometheus_client as prometheus;

```
---
### `metrics/src/metrics.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
use std::fmt::Write;
use std::ops::Deref;
use std::sync::{Arc, Mutex};
use std::time::Instant;

use malachitebft_core_state_machine::state::Step;
use prometheus_client::encoding::{EncodeLabelSet, EncodeLabelValue};
use prometheus_client::metrics::counter::Counter;
use prometheus_client::metrics::family::Family;
use prometheus_client::metrics::gauge::Gauge;
use prometheus_client::metrics::histogram::{exponential_buckets, linear_buckets, Histogram};

#[derive(Clone, Debug)]
pub struct Metrics(Arc<Inner>);

impl Deref for Metrics {
    type Target = Inner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

/// Label set for the `time_per_step` metric.
#[derive(Clone, Debug, Hash, PartialEq, Eq, EncodeLabelSet)]
pub struct TimePerStep {
    step: AsLabelValue<Step>,
}

impl TimePerStep {
    pub fn new(step: Step) -> Self {
        Self {
            step: AsLabelValue(step),
        }
    }
}

/// This wrapper allows us to derive `AsLabelValue` for `Step` without
/// running into Rust orphan rules, cf. <https://rust-lang.github.io/chalk/book/clauses/coherence.html>
#[derive(Clone, Debug, Hash, PartialEq, Eq)]
struct AsLabelValue<T>(T);

impl EncodeLabelValue for AsLabelValue<Step> {
    fn encode(
        &self,
        encoder: &mut prometheus_client::encoding::LabelValueEncoder,
    ) -> Result<(), std::fmt::Error> {
        encoder.write_fmt(format_args!("{:?}", self.0))
    }
}

#[derive(Clone, Debug)]
pub struct Inner {
    /// Number of blocks finalized
    pub finalized_blocks: Counter,

    /// Number of transactions finalized
    pub finalized_txes: Counter,

    /// Consensus time, in seconds
    pub consensus_time: Histogram,

    /// Time taken to finalize a block, in seconds
    pub time_per_block: Histogram,

    /// Time taken for a step within a round, in secodns
    pub time_per_step: Family<TimePerStep, Histogram>,

    /// Block size in terms of # of transactions
    pub block_tx_count: Histogram,

    /// Size of each block in bytes
    pub block_size_bytes: Histogram,

    /// The consensus round in which the node was when it finalized a block
    pub consensus_round: Histogram,

    /// The round of the proposal that was decided on
    pub proposal_round: Histogram,

    /// Number of times consensus rebroadcasted Prevote or Precommit votes due to no round progress
    pub rebroadcast_timeouts: Counter,

    /// Number of connected peers, ie. for each consensus node, how many peers is it connected to)
    pub connected_peers: Gauge,

    /// Current height
    pub height: Gauge,

    /// Current round
    pub round: Gauge,

    /// Time taken to sign a message
    pub signature_signing_time: Histogram,

    /// Time taken to verify a signature
    pub signature_verification_time: Histogram,

    /// Internal state for measuring time taken for consensus
    instant_consensus_started: Arc<AtomicInstant>,

    /// Internal state for measuring time taken to finalize a block
    instant_block_started: Arc<AtomicInstant>,

    /// Internal state for measuring time taken for a step within a round
    instant_step_started: Arc<Mutex<(Step, Instant)>>,
}

impl Metrics {
    pub fn new() -> Self {
        Self(Arc::new(Inner {
            finalized_blocks: Counter::default(),
            finalized_txes: Counter::default(),
            consensus_time: Histogram::new(linear_buckets(0.0, 0.1, 20)),
            time_per_block: Histogram::new(linear_buckets(0.0, 0.1, 20)),
            time_per_step: Family::new_with_constructor(|| {
                Histogram::new(linear_buckets(0.0, 0.1, 20))
            }),
            block_tx_count: Histogram::new(linear_buckets(0.0, 32.0, 128)),
            block_size_bytes: Histogram::new(linear_buckets(0.0, 64.0 * 1024.0, 128)),
            consensus_round: Histogram::new(linear_buckets(0.0, 1.0, 20)),
            proposal_round: Histogram::new(linear_buckets(0.0, 1.0, 20)),
            rebroadcast_timeouts: Counter::default(),
            connected_peers: Gauge::default(),
            height: Gauge::default(),
            round: Gauge::default(),
            signature_signing_time: Histogram::new(exponential_buckets(0.001, 2.0, 10)),
            signature_verification_time: Histogram::new(exponential_buckets(0.001, 2.0, 10)),
            instant_consensus_started: Arc::new(AtomicInstant::empty()),
            instant_block_started: Arc::new(AtomicInstant::empty()),
            instant_step_started: Arc::new(Mutex::new((Step::Unstarted, Instant::now()))),
        }))
    }

    pub fn register(registry: &SharedRegistry) -> Self {
        let metrics = Self::new();

        registry.with_prefix("malachitebft_core_consensus", |registry| {
            registry.register(
                "finalized_blocks",
                "Number of blocks finalized",
                metrics.finalized_blocks.clone(),
            );

            registry.register(
                "finalized_txes",
                "Number of transactions finalized",
                metrics.finalized_txes.clone(),
            );

            registry.register(
                "consensus_time",
                "Consensus time, in seconds",
                metrics.consensus_time.clone(),
            );

            registry.register(
                "time_per_block",
                "Time taken to finalize a block, in seconds",
                metrics.time_per_block.clone(),
            );

            registry.register(
                "time_per_step",
                "Time taken for a step in a round, in seconds",
                metrics.time_per_step.clone(),
            );

            registry.register(
                "block_tx_count",
                "Block size in terms of # of transactions",
                metrics.block_tx_count.clone(),
            );

            registry.register(
                "block_size_bytes",
                "Size of each block in bytes",
                metrics.block_size_bytes.clone(),
            );

            registry.register(
                "consensus_round",
                "The consensus round in which the node was when it finalized a block",
                metrics.consensus_round.clone(),
            );

            registry.register(
                "proposal_round",
                "The round of the proposal that was decided on",
                metrics.proposal_round.clone(),
            );

            registry.register(
                "rebroadcast_timeouts",
                "Number of times consensus rebroadcasted its vote due to no round progress",
                metrics.rebroadcast_timeouts.clone(),
            );

            registry.register(
                "connected_peers",
                "Number of connected peers, ie. for each consensus node, how many peers is it connected to",
                metrics.connected_peers.clone(),
            );

            registry.register(
                "height",
                "Current height",
                metrics.height.clone(),
            );

            registry.register(
                "round",
                "Current round",
                metrics.round.clone(),
            );

            registry.register(
                "signature_signing_time",
                "Time taken to sign a message, in seconds",
                metrics.signature_signing_time.clone(),
            );

            registry.register(
                "signature_verification_time",
                "Time taken to verify a signature, in seconds",
                metrics.signature_verification_time.clone(),
            );
        });

        metrics
    }

    pub fn consensus_start(&self) {
        self.instant_consensus_started.set_now();
    }

    pub fn consensus_end(&self) {
        if !self.instant_consensus_started.is_empty() {
            let elapsed = self.instant_consensus_started.elapsed().as_secs_f64();
            self.consensus_time.observe(elapsed);

            self.instant_consensus_started.set_millis(0);
        }
    }

    pub fn block_start(&self) {
        self.instant_block_started.set_now();
    }

    pub fn block_end(&self) {
        if !self.instant_block_started.is_empty() {
            let elapsed = self.instant_block_started.elapsed().as_secs_f64();
            self.time_per_block.observe(elapsed);

            self.instant_block_started.set_millis(0);
        }
    }

    pub fn step_start(&self, step: Step) {
        let mut guard = self.instant_step_started.lock().expect("poisoned mutex");
        *guard = (step, Instant::now());
    }

    pub fn step_end(&self, step: Step) {
        let mut guard = self.instant_step_started.lock().expect("poisoned mutex");

        let (current_step, started) = *guard;
        debug_assert_eq!(current_step, step, "step_end called for wrong step");

        // If the step was never started, ignore
        if current_step == Step::Unstarted {
            return;
        }

        self.time_per_step
            .get_or_create(&TimePerStep::new(step))
            .observe(started.elapsed().as_secs_f64());

        *guard = (Step::Unstarted, Instant::now());
    }
}

impl Default for Metrics {
    fn default() -> Self {
        Self::new()
    }
}

use std::{
    sync::atomic::{AtomicU64, Ordering},
    time::{Duration, SystemTime},
};

use crate::SharedRegistry;

#[derive(Default, Debug)]
struct AtomicInstant(AtomicU64);

#[allow(dead_code)]
impl AtomicInstant {
    pub fn now() -> Self {
        Self(AtomicU64::new(Self::now_millis()))
    }

    pub fn empty() -> Self {
        Self(AtomicU64::new(0))
    }

    pub const fn from_millis(millis: u64) -> Self {
        Self(AtomicU64::new(millis))
    }

    pub fn elapsed(&self) -> Duration {
        Duration::from_millis(Self::now_millis().saturating_sub(self.as_millis()))
    }

    pub fn as_millis(&self) -> u64 {
        self.0.load(Ordering::SeqCst)
    }

    pub fn set_now(&self) {
        self.set_millis(Self::now_millis());
    }

    pub fn set_millis(&self, millis: u64) {
        self.0.store(millis, Ordering::SeqCst);
    }

    pub fn is_empty(&self) -> bool {
        self.as_millis() == 0
    }

    fn now_millis() -> u64 {
        SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64
    }
}

```
---
### `metrics/src/registry.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::borrow::Cow;
use std::sync::{Arc, OnceLock, RwLock};

pub use prometheus_client::registry::Registry;

#[derive(Clone)]
pub struct SharedRegistry {
    moniker: Option<String>,
    registry: Arc<RwLock<Registry>>,
}

impl SharedRegistry {
    pub fn new(registry: Registry, moniker: Option<String>) -> Self {
        Self {
            moniker,
            registry: Arc::new(RwLock::new(registry)),
        }
    }

    pub fn global() -> &'static Self {
        global_registry()
    }

    pub fn with_moniker(&self, moniker: impl Into<String>) -> Self {
        Self {
            moniker: Some(moniker.into()),
            registry: Arc::clone(&self.registry),
        }
    }

    pub fn with_prefix<A>(&self, prefix: impl AsRef<str>, f: impl FnOnce(&mut Registry) -> A) -> A {
        if let Some(moniker) = &self.moniker {
            self.write(|reg| {
                f(reg
                    .sub_registry_with_prefix(prefix)
                    .sub_registry_with_label((
                        Cow::Borrowed("moniker"),
                        Cow::Owned(moniker.to_string()),
                    )))
            })
        } else {
            self.write(|reg| f(reg.sub_registry_with_prefix(prefix)))
        }
    }

    fn read<A>(&self, f: impl FnOnce(&Registry) -> A) -> A {
        f(&self.registry.read().expect("poisoned lock"))
    }

    fn write<A>(&self, f: impl FnOnce(&mut Registry) -> A) -> A {
        f(&mut self.registry.write().expect("poisoned lock"))
    }
}

fn global_registry() -> &'static SharedRegistry {
    static REGISTRY: OnceLock<SharedRegistry> = OnceLock::new();
    REGISTRY.get_or_init(|| SharedRegistry::new(Registry::default(), None))
}

pub fn export<W: core::fmt::Write>(writer: &mut W) {
    use prometheus_client::encoding::text::encode;

    SharedRegistry::global().read(|registry| encode(writer, registry).unwrap())
}

```
---
### `network/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-network"
description = "Networking layer for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[lints]
workspace = true

[dependencies]
malachitebft-discovery = { workspace = true }
malachitebft-metrics = { workspace = true }
malachitebft-peer = { workspace = true }
malachitebft-sync = { workspace = true }

bytes = { workspace = true }
either = { workspace = true }
eyre = { workspace = true }
futures = { workspace = true }
libp2p = { workspace = true }
libp2p-broadcast = { workspace = true }
seahash = { workspace = true }
serde = { workspace = true }
tokio = { workspace = true, features = ["macros"] }
tracing = { workspace = true }

```
---
### `network/src/behaviour.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use std::time::Duration;

use libp2p::kad::{Addresses, KBucketKey, KBucketRef};
use libp2p::request_response::{OutboundRequestId, ResponseChannel};
use libp2p::swarm::behaviour::toggle::Toggle;
use libp2p::swarm::NetworkBehaviour;
use libp2p::{gossipsub, identify, ping};
use libp2p_broadcast as broadcast;

pub use libp2p::identity::Keypair;
pub use libp2p::{Multiaddr, PeerId};

use malachitebft_discovery as discovery;
use malachitebft_metrics::Registry;
use malachitebft_sync as sync;

use crate::{Config, GossipSubConfig, PROTOCOL};

#[derive(Debug)]
pub enum NetworkEvent {
    Identify(identify::Event),
    Ping(ping::Event),
    GossipSub(gossipsub::Event),
    Broadcast(broadcast::Event),
    Sync(sync::Event),
    Discovery(discovery::NetworkEvent),
}

impl From<identify::Event> for NetworkEvent {
    fn from(event: identify::Event) -> Self {
        Self::Identify(event)
    }
}

impl From<ping::Event> for NetworkEvent {
    fn from(event: ping::Event) -> Self {
        Self::Ping(event)
    }
}

impl From<gossipsub::Event> for NetworkEvent {
    fn from(event: gossipsub::Event) -> Self {
        Self::GossipSub(event)
    }
}

impl From<broadcast::Event> for NetworkEvent {
    fn from(event: broadcast::Event) -> Self {
        Self::Broadcast(event)
    }
}

impl From<sync::Event> for NetworkEvent {
    fn from(event: sync::Event) -> Self {
        Self::Sync(event)
    }
}

impl From<discovery::NetworkEvent> for NetworkEvent {
    fn from(network_event: discovery::NetworkEvent) -> Self {
        Self::Discovery(network_event)
    }
}

#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "NetworkEvent")]
pub struct Behaviour {
    pub identify: identify::Behaviour,
    pub ping: ping::Behaviour,
    pub gossipsub: Toggle<gossipsub::Behaviour>,
    pub broadcast: Toggle<broadcast::Behaviour>,
    pub sync: Toggle<sync::Behaviour>,
    pub discovery: Toggle<discovery::Behaviour>,
}

/// Dummy implementation of Debug for Behaviour.
impl std::fmt::Debug for Behaviour {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Behaviour").finish()
    }
}

impl discovery::DiscoveryClient for Behaviour {
    fn add_address(&mut self, peer: &PeerId, address: Multiaddr) -> libp2p::kad::RoutingUpdate {
        self.discovery
            .as_mut()
            .expect("Discovery behaviour should be available")
            .kademlia
            .as_mut()
            .expect("Kademlia behaviour should be available")
            .add_address(peer, address)
    }

    fn kbuckets(&mut self) -> impl Iterator<Item = KBucketRef<'_, KBucketKey<PeerId>, Addresses>> {
        self.discovery
            .as_mut()
            .expect("Discovery behaviour should be available")
            .kademlia
            .as_mut()
            .expect("Kademlia behaviour should be available")
            .kbuckets()
    }

    fn send_request(&mut self, peer_id: &PeerId, req: discovery::Request) -> OutboundRequestId {
        self.discovery
            .as_mut()
            .expect("Discovery behaviour should be available")
            .request_response
            .send_request(peer_id, req)
    }

    fn send_response(
        &mut self,
        ch: ResponseChannel<discovery::Response>,
        rs: discovery::Response,
    ) -> Result<(), discovery::Response> {
        self.discovery
            .as_mut()
            .expect("Discovery behaviour should be available")
            .request_response
            .send_response(ch, rs)
    }
}

fn message_id(message: &gossipsub::Message) -> gossipsub::MessageId {
    use seahash::SeaHasher;
    use std::hash::{Hash, Hasher};

    let mut hasher = SeaHasher::new();
    message.hash(&mut hasher);
    gossipsub::MessageId::new(hasher.finish().to_be_bytes().as_slice())
}

fn gossipsub_config(config: GossipSubConfig, max_transmit_size: usize) -> gossipsub::Config {
    gossipsub::ConfigBuilder::default()
        .max_transmit_size(max_transmit_size)
        .opportunistic_graft_ticks(3)
        .heartbeat_interval(Duration::from_secs(1))
        .validation_mode(gossipsub::ValidationMode::Strict)
        .history_gossip(3)
        .history_length(5)
        .mesh_n_high(config.mesh_n_high)
        .mesh_n_low(config.mesh_n_low)
        .mesh_outbound_min(config.mesh_outbound_min)
        .mesh_n(config.mesh_n)
        .message_id_fn(message_id)
        .build()
        .unwrap()
}

impl Behaviour {
    pub fn new_with_metrics(config: &Config, keypair: &Keypair, registry: &mut Registry) -> Self {
        let identify = identify::Behaviour::new(identify::Config::new(
            PROTOCOL.to_string(),
            keypair.public(),
        ));

        let ping = ping::Behaviour::new(ping::Config::new().with_interval(Duration::from_secs(5)));

        let gossipsub = config.pubsub_protocol.is_gossipsub().then(|| {
            gossipsub::Behaviour::new_with_metrics(
                gossipsub::MessageAuthenticity::Signed(keypair.clone()),
                gossipsub_config(config.gossipsub, config.pubsub_max_size),
                registry.sub_registry_with_prefix("gossipsub"),
                Default::default(),
            )
            .unwrap()
        });

        let enable_broadcast = config.pubsub_protocol.is_broadcast() || config.enable_sync;
        let broadcast = enable_broadcast.then(|| {
            broadcast::Behaviour::new_with_metrics(
                broadcast::Config {
                    max_buf_size: config.pubsub_max_size,
                },
                registry.sub_registry_with_prefix("broadcast"),
            )
        });

        let sync = config.enable_sync.then(|| {
            sync::Behaviour::new_with_metrics(
                sync::Config::default().with_max_response_size(config.rpc_max_size),
                registry.sub_registry_with_prefix("sync"),
            )
        });

        let discovery = config
            .discovery
            .enabled
            .then(|| discovery::Behaviour::new(keypair, config.discovery));

        Self {
            identify,
            ping,
            sync: Toggle::from(sync),
            gossipsub: Toggle::from(gossipsub),
            broadcast: Toggle::from(broadcast),
            discovery: Toggle::from(discovery),
        }
    }
}

```
---
### `network/src/channel.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use core::fmt;

use libp2p::gossipsub;
use libp2p_broadcast as broadcast;
use serde::{Deserialize, Serialize};

#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Channel {
    Consensus,
    Liveness,
    ProposalParts,
    Sync,
}

impl Channel {
    pub fn all() -> &'static [Channel] {
        &[
            Channel::Consensus,
            Channel::ProposalParts,
            Channel::Sync,
            Channel::Liveness,
        ]
    }

    pub fn consensus() -> &'static [Channel] {
        &[
            Channel::Consensus,
            Channel::ProposalParts,
            Channel::Liveness,
        ]
    }

    pub fn to_gossipsub_topic(self) -> gossipsub::IdentTopic {
        gossipsub::IdentTopic::new(self.as_str())
    }

    pub fn to_broadcast_topic(self) -> broadcast::Topic {
        broadcast::Topic::new(self.as_str().as_bytes())
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            Channel::Consensus => "/consensus",
            Channel::ProposalParts => "/proposal_parts",
            Channel::Sync => "/sync",
            Channel::Liveness => "/liveness",
        }
    }

    pub fn has_gossipsub_topic(topic_hash: &gossipsub::TopicHash) -> bool {
        Self::all()
            .iter()
            .any(|channel| &channel.to_gossipsub_topic().hash() == topic_hash)
    }

    pub fn has_broadcast_topic(topic: &broadcast::Topic) -> bool {
        Self::all()
            .iter()
            .any(|channel| &channel.to_broadcast_topic() == topic)
    }

    pub fn from_gossipsub_topic_hash(topic: &gossipsub::TopicHash) -> Option<Self> {
        match topic.as_str() {
            "/consensus" => Some(Channel::Consensus),
            "/proposal_parts" => Some(Channel::ProposalParts),
            "/sync" => Some(Channel::Sync),
            "/liveness" => Some(Channel::Liveness),
            _ => None,
        }
    }

    pub fn from_broadcast_topic(topic: &broadcast::Topic) -> Option<Self> {
        match topic.as_ref() {
            b"/consensus" => Some(Channel::Consensus),
            b"/proposal_parts" => Some(Channel::ProposalParts),
            b"/sync" => Some(Channel::Sync),
            b"/liveness" => Some(Channel::Liveness),
            _ => None,
        }
    }
}

impl fmt::Display for Channel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.as_str().fmt(f)
    }
}

```
---
### `network/src/handle.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use bytes::Bytes;
use libp2p::request_response::{InboundRequestId, OutboundRequestId};
use tokio::sync::{mpsc, oneshot};
use tokio::task;

use malachitebft_peer::PeerId;

use crate::{Channel, CtrlMsg, Event};

pub struct RecvHandle {
    peer_id: PeerId,
    rx_event: mpsc::Receiver<Event>,
}

impl RecvHandle {
    pub fn peer_id(&self) -> PeerId {
        self.peer_id
    }

    pub async fn recv(&mut self) -> Option<Event> {
        self.rx_event.recv().await
    }
}

pub struct CtrlHandle {
    peer_id: PeerId,
    tx_ctrl: mpsc::Sender<CtrlMsg>,
    task_handle: task::JoinHandle<()>,
}

impl CtrlHandle {
    pub fn peer_id(&self) -> PeerId {
        self.peer_id
    }

    pub async fn publish(&self, channel: Channel, data: Bytes) -> Result<(), eyre::Report> {
        self.tx_ctrl.send(CtrlMsg::Publish(channel, data)).await?;
        Ok(())
    }

    pub async fn broadcast(&self, channel: Channel, data: Bytes) -> Result<(), eyre::Report> {
        self.tx_ctrl.send(CtrlMsg::Broadcast(channel, data)).await?;
        Ok(())
    }

    pub async fn sync_request(
        &self,
        peer_id: PeerId,
        data: Bytes,
    ) -> Result<OutboundRequestId, eyre::Report> {
        let (tx, rx) = oneshot::channel();

        self.tx_ctrl
            .send(CtrlMsg::SyncRequest(peer_id, data, tx))
            .await?;

        Ok(rx.await?)
    }

    pub async fn sync_reply(
        &self,
        request_id: InboundRequestId,
        data: Bytes,
    ) -> Result<(), eyre::Report> {
        self.tx_ctrl
            .send(CtrlMsg::SyncReply(request_id, data))
            .await?;
        Ok(())
    }

    pub async fn wait_shutdown(self) -> Result<(), eyre::Report> {
        self.shutdown().await?;
        self.join().await?;
        Ok(())
    }

    pub async fn shutdown(&self) -> Result<(), eyre::Report> {
        self.tx_ctrl.send(CtrlMsg::Shutdown).await?;
        Ok(())
    }

    pub async fn join(self) -> Result<(), eyre::Report> {
        self.task_handle.await?;
        Ok(())
    }
}

pub struct Handle {
    peer_id: PeerId,
    recv: RecvHandle,
    ctrl: CtrlHandle,
}

impl Handle {
    pub fn new(
        peer_id: PeerId,
        tx_ctrl: mpsc::Sender<CtrlMsg>,
        rx_event: mpsc::Receiver<Event>,
        task_handle: task::JoinHandle<()>,
    ) -> Self {
        Self {
            peer_id,
            recv: RecvHandle { peer_id, rx_event },
            ctrl: CtrlHandle {
                peer_id,
                tx_ctrl,
                task_handle,
            },
        }
    }

    pub fn peer_id(&self) -> PeerId {
        self.peer_id
    }

    pub fn split(self) -> (RecvHandle, CtrlHandle) {
        (self.recv, self.ctrl)
    }

    pub async fn recv(&mut self) -> Option<Event> {
        self.recv.recv().await
    }

    pub async fn broadcast(&self, channel: Channel, data: Bytes) -> Result<(), eyre::Report> {
        self.ctrl.publish(channel, data).await
    }

    pub async fn wait_shutdown(self) -> Result<(), eyre::Report> {
        self.ctrl.wait_shutdown().await
    }

    pub async fn shutdown(&self) -> Result<(), eyre::Report> {
        self.ctrl.shutdown().await
    }

    pub async fn join(self) -> Result<(), eyre::Report> {
        self.ctrl.join().await
    }
}

```
---
### `network/src/lib.rs`
*2025-05-18 23:58:49 | 24 KB*
```rust
use std::collections::HashMap;
use std::error::Error;
use std::ops::ControlFlow;
use std::time::Duration;

use futures::StreamExt;
use libp2p::metrics::{Metrics, Recorder};
use libp2p::request_response::{InboundRequestId, OutboundRequestId};
use libp2p::swarm::{self, SwarmEvent};
use libp2p::{gossipsub, identify, quic, SwarmBuilder};
use libp2p_broadcast as broadcast;
use tokio::sync::{mpsc, oneshot};
use tracing::{debug, error, error_span, info, trace, warn, Instrument};

use malachitebft_discovery::{self as discovery};
use malachitebft_metrics::SharedRegistry;
use malachitebft_sync::{self as sync};

pub use malachitebft_peer::PeerId;

pub use bytes::Bytes;
pub use libp2p::gossipsub::MessageId;
pub use libp2p::identity::Keypair;
pub use libp2p::Multiaddr;

pub mod behaviour;
pub mod handle;
pub mod pubsub;

mod channel;
pub use channel::Channel;

use behaviour::{Behaviour, NetworkEvent};
use handle::Handle;

const PROTOCOL: &str = "/malachitebft-core-consensus/v1beta1";
const METRICS_PREFIX: &str = "malachitebft_network";
const DISCOVERY_METRICS_PREFIX: &str = "malachitebft_discovery";

#[derive(Copy, Clone, Debug, Default)]
pub enum PubSubProtocol {
    /// GossipSub: a pubsub protocol based on epidemic broadcast trees
    #[default]
    GossipSub,

    /// Broadcast: a simple broadcast protocol
    Broadcast,
}

impl PubSubProtocol {
    pub fn is_gossipsub(&self) -> bool {
        matches!(self, Self::GossipSub)
    }

    pub fn is_broadcast(&self) -> bool {
        matches!(self, Self::Broadcast)
    }
}

#[derive(Copy, Clone, Debug)]
pub struct GossipSubConfig {
    pub mesh_n: usize,
    pub mesh_n_high: usize,
    pub mesh_n_low: usize,
    pub mesh_outbound_min: usize,
}

impl Default for GossipSubConfig {
    fn default() -> Self {
        // Tests use these defaults.
        Self {
            mesh_n: 6,
            mesh_n_high: 12,
            mesh_n_low: 4,
            mesh_outbound_min: 2,
        }
    }
}

pub type BoxError = Box<dyn Error + Send + Sync + 'static>;

pub type DiscoveryConfig = discovery::Config;
pub type BootstrapProtocol = discovery::config::BootstrapProtocol;
pub type Selector = discovery::config::Selector;

#[derive(Clone, Debug)]
pub struct Config {
    pub listen_addr: Multiaddr,
    pub persistent_peers: Vec<Multiaddr>,
    pub discovery: DiscoveryConfig,
    pub idle_connection_timeout: Duration,
    pub transport: TransportProtocol,
    pub gossipsub: GossipSubConfig,
    pub pubsub_protocol: PubSubProtocol,
    pub rpc_max_size: usize,
    pub pubsub_max_size: usize,
    pub enable_sync: bool,
}

impl Config {
    fn apply_to_swarm(&self, cfg: swarm::Config) -> swarm::Config {
        cfg.with_idle_connection_timeout(self.idle_connection_timeout)
    }

    fn apply_to_quic(&self, mut cfg: quic::Config) -> quic::Config {
        // NOTE: This is set low due to quic transport not properly resetting
        // connection state when reconnecting before connection timeout.
        // See https://github.com/libp2p/rust-libp2p/issues/5097
        cfg.max_idle_timeout = 300;
        cfg.keep_alive_interval = Duration::from_millis(100);
        cfg
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum TransportProtocol {
    Tcp,
    Quic,
}

impl TransportProtocol {
    pub fn from_multiaddr(multiaddr: &Multiaddr) -> Option<TransportProtocol> {
        for protocol in multiaddr.protocol_stack() {
            match protocol {
                "tcp" => return Some(TransportProtocol::Tcp),
                "quic" | "quic-v1" => return Some(TransportProtocol::Quic),
                _ => {}
            }
        }
        None
    }
}

/// sync event details:
///
/// peer1: sync                  peer2: network                    peer2: sync              peer1: network
/// CtrlMsg::SyncRequest       --> Event::Sync      -----------> CtrlMsg::SyncReply ------> Event::Sync
/// (peer_id, height)             (RawMessage::Request           (request_id, height)       RawMessage::Response
///                           {request_id, peer_id, request}                                {request_id, response}
///
///
/// An event that can be emitted by the gossip layer
#[derive(Clone, Debug)]
pub enum Event {
    Listening(Multiaddr),
    PeerConnected(PeerId),
    PeerDisconnected(PeerId),
    ConsensusMessage(Channel, PeerId, Bytes),
    LivenessMessage(Channel, PeerId, Bytes),
    Sync(sync::RawMessage),
}

#[derive(Debug)]
pub enum CtrlMsg {
    Publish(Channel, Bytes),
    Broadcast(Channel, Bytes),
    SyncRequest(PeerId, Bytes, oneshot::Sender<OutboundRequestId>),
    SyncReply(InboundRequestId, Bytes),
    Shutdown,
}

#[derive(Debug)]
pub struct State {
    pub sync_channels: HashMap<InboundRequestId, sync::ResponseChannel>,
    pub discovery: discovery::Discovery<Behaviour>,
}

impl State {
    fn new(discovery: discovery::Discovery<Behaviour>) -> Self {
        Self {
            sync_channels: Default::default(),
            discovery,
        }
    }
}

pub async fn spawn(
    keypair: Keypair,
    config: Config,
    registry: SharedRegistry,
) -> Result<Handle, eyre::Report> {
    let swarm = registry.with_prefix(METRICS_PREFIX, |registry| -> Result<_, eyre::Report> {
        let builder = SwarmBuilder::with_existing_identity(keypair).with_tokio();
        match config.transport {
            TransportProtocol::Tcp => Ok(builder
                .with_tcp(
                    libp2p::tcp::Config::new().nodelay(true), // Disable Nagle's algorithm
                    libp2p::noise::Config::new,
                    libp2p::yamux::Config::default,
                )?
                .with_dns()?
                .with_bandwidth_metrics(registry)
                .with_behaviour(|kp| Behaviour::new_with_metrics(&config, kp, registry))?
                .with_swarm_config(|cfg| config.apply_to_swarm(cfg))
                .build()),
            TransportProtocol::Quic => Ok(builder
                .with_quic_config(|cfg| config.apply_to_quic(cfg))
                .with_dns()?
                .with_bandwidth_metrics(registry)
                .with_behaviour(|kp| Behaviour::new_with_metrics(&config, kp, registry))?
                .with_swarm_config(|cfg| config.apply_to_swarm(cfg))
                .build()),
        }
    })?;

    let metrics = registry.with_prefix(METRICS_PREFIX, Metrics::new);

    let (tx_event, rx_event) = mpsc::channel(32);
    let (tx_ctrl, rx_ctrl) = mpsc::channel(32);

    let discovery = registry.with_prefix(DISCOVERY_METRICS_PREFIX, |reg| {
        discovery::Discovery::new(config.discovery, config.persistent_peers.clone(), reg)
    });

    let state = State::new(discovery);

    let peer_id = PeerId::from_libp2p(swarm.local_peer_id());
    let span = error_span!("network");

    info!(parent: span.clone(), %peer_id, "Starting network service");

    let task_handle =
        tokio::task::spawn(run(config, metrics, state, swarm, rx_ctrl, tx_event).instrument(span));

    Ok(Handle::new(peer_id, tx_ctrl, rx_event, task_handle))
}

async fn run(
    config: Config,
    metrics: Metrics,
    mut state: State,
    mut swarm: swarm::Swarm<Behaviour>,
    mut rx_ctrl: mpsc::Receiver<CtrlMsg>,
    tx_event: mpsc::Sender<Event>,
) {
    if let Err(e) = swarm.listen_on(config.listen_addr.clone()) {
        error!("Error listening on {}: {e}", config.listen_addr);
        return;
    }

    state.discovery.dial_bootstrap_nodes(&swarm);

    if let Err(e) = pubsub::subscribe(&mut swarm, config.pubsub_protocol, Channel::consensus()) {
        error!("Error subscribing to consensus channels: {e}");
        return;
    };

    if config.enable_sync {
        if let Err(e) = pubsub::subscribe(&mut swarm, PubSubProtocol::Broadcast, &[Channel::Sync]) {
            error!("Error subscribing to Sync channel: {e}");
            return;
        };
    }

    loop {
        let result = tokio::select! {
            event = swarm.select_next_some() => {
                handle_swarm_event(event, &config, &metrics, &mut swarm, &mut state, &tx_event).await
            }

            Some(connection_data) = state.discovery.controller.dial.recv(), if state.discovery.can_dial() => {
                state.discovery.dial_peer(&mut swarm, connection_data);
                ControlFlow::Continue(())
            }

            Some(request_data) = state.discovery.controller.peers_request.recv(), if state.discovery.can_peers_request() => {
                state.discovery.peers_request_peer(&mut swarm, request_data);
                ControlFlow::Continue(())
            }

            Some(request_data) = state.discovery.controller.connect_request.recv(), if state.discovery.can_connect_request() => {
                state.discovery.connect_request_peer(&mut swarm, request_data);
                ControlFlow::Continue(())
            }

            Some((peer_id, connection_id)) = state.discovery.controller.close.recv(), if state.discovery.can_close() => {
                state.discovery.close_connection(&mut swarm, peer_id, connection_id);
                ControlFlow::Continue(())
            }

            Some(ctrl) = rx_ctrl.recv() => {
                handle_ctrl_msg(&mut swarm, &mut state, &config, ctrl).await
            }
        };

        match result {
            ControlFlow::Continue(()) => continue,
            ControlFlow::Break(()) => break,
        }
    }
}

async fn handle_ctrl_msg(
    swarm: &mut swarm::Swarm<Behaviour>,
    state: &mut State,
    config: &Config,
    msg: CtrlMsg,
) -> ControlFlow<()> {
    match msg {
        CtrlMsg::Publish(channel, data) => {
            let msg_size = data.len();
            let result = pubsub::publish(swarm, config.pubsub_protocol, channel, data);

            match result {
                Ok(()) => debug!(%channel, size = %msg_size, "Published message"),
                Err(e) => error!(%channel, "Error publishing message: {e}"),
            }

            ControlFlow::Continue(())
        }

        CtrlMsg::Broadcast(channel, data) => {
            if channel == Channel::Sync && !config.enable_sync {
                trace!("Ignoring broadcast message to Sync channel: Sync not enabled");
                return ControlFlow::Continue(());
            }

            let msg_size = data.len();
            let result = pubsub::publish(swarm, PubSubProtocol::Broadcast, channel, data);

            match result {
                Ok(()) => debug!(%channel, size = %msg_size, "Broadcasted message"),
                Err(e) => error!(%channel, "Error broadcasting message: {e}"),
            }

            ControlFlow::Continue(())
        }

        CtrlMsg::SyncRequest(peer_id, request, reply_to) => {
            let Some(sync) = swarm.behaviour_mut().sync.as_mut() else {
                error!("Cannot request Sync from peer: Sync not enabled");
                return ControlFlow::Continue(());
            };

            let request_id = sync.send_request(peer_id.to_libp2p(), request);

            if let Err(e) = reply_to.send(request_id) {
                error!(%peer_id, "Error sending Sync request: {e}");
            }

            ControlFlow::Continue(())
        }

        CtrlMsg::SyncReply(request_id, data) => {
            let Some(sync) = swarm.behaviour_mut().sync.as_mut() else {
                error!("Cannot send Sync response to peer: Sync not enabled");
                return ControlFlow::Continue(());
            };

            let Some(channel) = state.sync_channels.remove(&request_id) else {
                error!(%request_id, "Received Sync reply for unknown request ID");
                return ControlFlow::Continue(());
            };

            let result = sync.send_response(channel, data);

            match result {
                Ok(()) => debug!(%request_id, "Replied to Sync request"),
                Err(e) => error!(%request_id, "Error replying to Sync request: {e}"),
            }

            ControlFlow::Continue(())
        }

        CtrlMsg::Shutdown => ControlFlow::Break(()),
    }
}

async fn handle_swarm_event(
    event: SwarmEvent<NetworkEvent>,
    _config: &Config,
    metrics: &Metrics,
    swarm: &mut swarm::Swarm<Behaviour>,
    state: &mut State,
    tx_event: &mpsc::Sender<Event>,
) -> ControlFlow<()> {
    if let SwarmEvent::Behaviour(NetworkEvent::GossipSub(e)) = &event {
        metrics.record(e);
    } else if let SwarmEvent::Behaviour(NetworkEvent::Identify(e)) = &event {
        metrics.record(e);
    }

    match event {
        SwarmEvent::NewListenAddr { address, .. } => {
            debug!(%address, "Node is listening");

            if let Err(e) = tx_event.send(Event::Listening(address)).await {
                error!("Error sending listening event to handle: {e}");
                return ControlFlow::Break(());
            }
        }

        SwarmEvent::ConnectionEstablished {
            peer_id,
            connection_id,
            endpoint,
            ..
        } => {
            trace!("Connected to {peer_id} with connection id {connection_id}",);

            state
                .discovery
                .handle_connection(swarm, peer_id, connection_id, endpoint);
        }

        SwarmEvent::OutgoingConnectionError {
            connection_id,
            error,
            ..
        } => {
            error!("Error dialing peer: {error}");

            state
                .discovery
                .handle_failed_connection(swarm, connection_id);
        }

        SwarmEvent::ConnectionClosed {
            peer_id,
            connection_id,
            cause,
            ..
        } => {
            if let Some(cause) = cause {
                warn!("Connection closed with {peer_id}, reason: {cause}");
            } else {
                warn!("Connection closed with {peer_id}, reason: unknown");
            }

            state
                .discovery
                .handle_closed_connection(swarm, peer_id, connection_id);

            if let Err(e) = tx_event
                .send(Event::PeerDisconnected(PeerId::from_libp2p(&peer_id)))
                .await
            {
                error!("Error sending peer disconnected event to handle: {e}");
                return ControlFlow::Break(());
            }
        }

        SwarmEvent::Behaviour(NetworkEvent::Identify(identify::Event::Sent {
            peer_id, ..
        })) => {
            trace!("Sent identity to {peer_id}");
        }

        SwarmEvent::Behaviour(NetworkEvent::Identify(identify::Event::Received {
            connection_id,
            peer_id,
            info,
        })) => {
            trace!(
                "Received identity from {peer_id}: protocol={:?}",
                info.protocol_version
            );

            if info.protocol_version == PROTOCOL {
                trace!(
                    "Peer {peer_id} is using compatible protocol version: {:?}",
                    info.protocol_version
                );

                state
                    .discovery
                    .handle_new_peer(swarm, connection_id, peer_id, info);

                if let Err(e) = tx_event
                    .send(Event::PeerConnected(PeerId::from_libp2p(&peer_id)))
                    .await
                {
                    error!("Error sending peer connected event to handle: {e}");
                    return ControlFlow::Break(());
                }
            } else {
                trace!(
                    "Peer {peer_id} is using incompatible protocol version: {:?}",
                    info.protocol_version
                );
            }
        }

        SwarmEvent::Behaviour(NetworkEvent::Ping(event)) => {
            match &event.result {
                Ok(rtt) => {
                    trace!("Received pong from {} in {rtt:?}", event.peer);
                }
                Err(e) => {
                    trace!("Received pong from {} with error: {e}", event.peer);
                }
            }

            // Record metric for round-trip time sending a ping and receiving a pong
            metrics.record(&event);
        }

        SwarmEvent::Behaviour(NetworkEvent::GossipSub(event)) => {
            return handle_gossipsub_event(event, metrics, swarm, state, tx_event).await;
        }

        SwarmEvent::Behaviour(NetworkEvent::Broadcast(event)) => {
            return handle_broadcast_event(event, metrics, swarm, state, tx_event).await;
        }

        SwarmEvent::Behaviour(NetworkEvent::Sync(event)) => {
            return handle_sync_event(event, metrics, swarm, state, tx_event).await;
        }

        SwarmEvent::Behaviour(NetworkEvent::Discovery(network_event)) => {
            state.discovery.on_network_event(swarm, network_event);
        }

        swarm_event => {
            metrics.record(&swarm_event);
        }
    }

    ControlFlow::Continue(())
}

async fn handle_gossipsub_event(
    event: gossipsub::Event,
    _metrics: &Metrics,
    _swarm: &mut swarm::Swarm<Behaviour>,
    _state: &mut State,
    tx_event: &mpsc::Sender<Event>,
) -> ControlFlow<()> {
    match event {
        gossipsub::Event::Subscribed { peer_id, topic } => {
            if !Channel::has_gossipsub_topic(&topic) {
                trace!("Peer {peer_id} tried to subscribe to unknown topic: {topic}");
                return ControlFlow::Continue(());
            }

            trace!("Peer {peer_id} subscribed to {topic}");
        }

        gossipsub::Event::Unsubscribed { peer_id, topic } => {
            if !Channel::has_gossipsub_topic(&topic) {
                trace!("Peer {peer_id} tried to unsubscribe from unknown topic: {topic}");
                return ControlFlow::Continue(());
            }

            trace!("Peer {peer_id} unsubscribed from {topic}");
        }

        gossipsub::Event::Message {
            message_id,
            message,
            ..
        } => {
            let Some(peer_id) = message.source else {
                return ControlFlow::Continue(());
            };

            let Some(channel) = Channel::from_gossipsub_topic_hash(&message.topic) else {
                trace!(
                    "Received message {message_id} from {peer_id} on different channel: {}",
                    message.topic
                );

                return ControlFlow::Continue(());
            };

            trace!(
                "Received message {message_id} from {peer_id} on channel {channel} of {} bytes",
                message.data.len()
            );

            if channel == Channel::Liveness {
                let event = Event::LivenessMessage(
                    channel,
                    PeerId::from_libp2p(&peer_id),
                    Bytes::from(message.data),
                );
                if let Err(e) = tx_event.send(event).await {
                    error!("Error sending message to handle: {e}");
                    return ControlFlow::Break(());
                }
            } else {
                let event = Event::ConsensusMessage(
                    channel,
                    PeerId::from_libp2p(&peer_id),
                    Bytes::from(message.data),
                );
                if let Err(e) = tx_event.send(event).await {
                    error!("Error sending message to handle: {e}");
                    return ControlFlow::Break(());
                }
            }
        }

        gossipsub::Event::SlowPeer {
            peer_id,
            failed_messages,
        } => {
            trace!(
                "Slow peer detected: {peer_id}, total failed messages: {}",
                failed_messages.total()
            );
        }

        gossipsub::Event::GossipsubNotSupported { peer_id } => {
            trace!("Peer does not support GossipSub: {peer_id}");
        }
    }

    ControlFlow::Continue(())
}

async fn handle_broadcast_event(
    event: broadcast::Event,
    _metrics: &Metrics,
    _swarm: &mut swarm::Swarm<Behaviour>,
    _state: &mut State,
    tx_event: &mpsc::Sender<Event>,
) -> ControlFlow<()> {
    match event {
        broadcast::Event::Subscribed(peer_id, topic) => {
            if !Channel::has_broadcast_topic(&topic) {
                trace!("Peer {peer_id} tried to subscribe to unknown topic: {topic:?}");
                return ControlFlow::Continue(());
            }

            trace!("Peer {peer_id} subscribed to {topic:?}");
        }

        broadcast::Event::Unsubscribed(peer_id, topic) => {
            if !Channel::has_broadcast_topic(&topic) {
                trace!("Peer {peer_id} tried to unsubscribe from unknown topic: {topic:?}");
                return ControlFlow::Continue(());
            }

            trace!("Peer {peer_id} unsubscribed from {topic:?}");
        }

        broadcast::Event::Received(peer_id, topic, message) => {
            let Some(channel) = Channel::from_broadcast_topic(&topic) else {
                trace!("Received message from {peer_id} on different channel: {topic:?}");
                return ControlFlow::Continue(());
            };

            trace!(
                "Received message from {peer_id} on channel {channel} of {} bytes",
                message.len()
            );

            let event = Event::ConsensusMessage(
                channel,
                PeerId::from_libp2p(&peer_id),
                Bytes::copy_from_slice(message.as_ref()),
            );

            if let Err(e) = tx_event.send(event).await {
                error!("Error sending message to handle: {e}");
                return ControlFlow::Break(());
            }
        }
    }

    ControlFlow::Continue(())
}

async fn handle_sync_event(
    event: sync::Event,
    _metrics: &Metrics,
    _swarm: &mut swarm::Swarm<Behaviour>,
    state: &mut State,
    tx_event: &mpsc::Sender<Event>,
) -> ControlFlow<()> {
    match event {
        sync::Event::Message { peer, message, .. } => {
            match message {
                libp2p::request_response::Message::Request {
                    request_id,
                    request,
                    channel,
                } => {
                    state.sync_channels.insert(request_id, channel);

                    let _ = tx_event
                        .send(Event::Sync(sync::RawMessage::Request {
                            request_id,
                            peer: PeerId::from_libp2p(&peer),
                            body: request.0,
                        }))
                        .await
                        .map_err(|e| {
                            error!("Error sending Sync request to handle: {e}");
                        });
                }

                libp2p::request_response::Message::Response {
                    request_id,
                    response,
                } => {
                    let _ = tx_event
                        .send(Event::Sync(sync::RawMessage::Response {
                            request_id,
                            peer: PeerId::from_libp2p(&peer),
                            body: response.0,
                        }))
                        .await
                        .map_err(|e| {
                            error!("Error sending Sync response to handle: {e}");
                        });
                }
            }

            ControlFlow::Continue(())
        }

        sync::Event::ResponseSent { .. } => ControlFlow::Continue(()),

        sync::Event::OutboundFailure { .. } => ControlFlow::Continue(()),

        sync::Event::InboundFailure { .. } => ControlFlow::Continue(()),
    }
}

pub trait PeerIdExt {
    fn to_libp2p(&self) -> libp2p::PeerId;
    fn from_libp2p(peer_id: &libp2p::PeerId) -> Self;
}

impl PeerIdExt for PeerId {
    fn to_libp2p(&self) -> libp2p::PeerId {
        libp2p::PeerId::from_bytes(&self.to_bytes()).expect("valid PeerId")
    }

    fn from_libp2p(peer_id: &libp2p::PeerId) -> Self {
        Self::from_bytes(&peer_id.to_bytes()).expect("valid PeerId")
    }
}

```
---
### `network/src/pubsub.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use bytes::Bytes;
use libp2p::swarm;

use crate::behaviour::Behaviour;
use crate::{Channel, PubSubProtocol};

pub fn subscribe(
    swarm: &mut swarm::Swarm<Behaviour>,
    protocol: PubSubProtocol,
    channels: &[Channel],
) -> Result<(), eyre::Report> {
    match protocol {
        PubSubProtocol::GossipSub => {
            if let Some(gossipsub) = swarm.behaviour_mut().gossipsub.as_mut() {
                for channel in channels {
                    gossipsub.subscribe(&channel.to_gossipsub_topic())?;
                }
            } else {
                return Err(eyre::eyre!("GossipSub not enabled"));
            }
        }
        PubSubProtocol::Broadcast => {
            if let Some(broadcast) = swarm.behaviour_mut().broadcast.as_mut() {
                for channel in channels {
                    broadcast.subscribe(channel.to_broadcast_topic());
                }
            } else {
                return Err(eyre::eyre!("Broadcast not enabled"));
            }
        }
    }

    Ok(())
}

pub fn publish(
    swarm: &mut swarm::Swarm<Behaviour>,
    protocol: PubSubProtocol,
    channel: Channel,
    data: Bytes,
) -> Result<(), eyre::Report> {
    match protocol {
        PubSubProtocol::GossipSub => {
            if let Some(gossipsub) = swarm.behaviour_mut().gossipsub.as_mut() {
                gossipsub.publish(channel.to_gossipsub_topic(), data)?;
            } else {
                return Err(eyre::eyre!("GossipSub not enabled"));
            }
        }
        PubSubProtocol::Broadcast => {
            if let Some(broadcast) = swarm.behaviour_mut().broadcast.as_mut() {
                broadcast.broadcast(&channel.to_broadcast_topic(), data);
            } else {
                return Err(eyre::eyre!("Broadcast not enabled"));
            }
        }
    }

    Ok(())
}

```
---
### `network/test/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-discovery-test"
publish = false

version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
malachitebft-network.workspace = true
malachitebft-config.workspace = true
malachitebft-starknet-host.workspace = true
malachitebft-metrics.workspace = true

futures.workspace = true
libp2p-identity.workspace = true
rand.workspace = true
tokio.workspace = true
tracing.workspace = true
tracing-subscriber.workspace = true

[dev-dependencies]
malachitebft-discovery-test = { workspace = true }

[lints]
workspace = true

```
---
### `network/test/src/lib.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
use core::fmt;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use libp2p_identity::PeerId;
use malachitebft_config::TransportProtocol;
use malachitebft_metrics::SharedRegistry;
use malachitebft_network::{spawn, Config, DiscoveryConfig, Keypair, PeerIdExt};
use malachitebft_starknet_host::types::PrivateKey;
use rand::{rngs::StdRng, Rng, SeedableRng};
use tokio::time::sleep;
use tracing::{debug, info};

//---------------------------------------------------------------------
// Expected primitives
//---------------------------------------------------------------------

#[derive(Debug)]
pub enum Expected {
    Exactly(Vec<usize>),
    AtLeast(Vec<usize>),
    AtMost(Vec<usize>),
    LessThan(Vec<usize>),
    GreaterThan(Vec<usize>),
}

impl Expected {
    pub fn check(&self, actual: Vec<usize>) {
        match self {
            Expected::Exactly(expected) => {
                assert_eq!(
                    actual.len(),
                    expected.len(),
                    "Expected length: {}, actual length: {}",
                    expected.len(),
                    actual.len()
                );
                for node in expected {
                    assert!(actual.contains(node), "Node {} not found", node);
                }
            }
            Expected::AtLeast(expected) => {
                assert!(
                    actual.len() >= expected.len(),
                    "Expected length: at least {}, actual length: {}",
                    expected.len(),
                    actual.len()
                );
                for node in expected {
                    assert!(actual.contains(node), "Node {} not found", node);
                }
            }
            Expected::AtMost(expected) => {
                assert!(
                    actual.len() <= expected.len(),
                    "Expected length: at most {}, actual length: {}",
                    expected.len(),
                    actual.len()
                );
                for node in actual {
                    assert!(expected.contains(&node), "Node {} not expected", node);
                }
            }
            Expected::LessThan(expected) => {
                assert!(
                    actual.len() < expected.len(),
                    "Expected length: less than {}, actual length: {}",
                    expected.len(),
                    actual.len()
                );
                for node in actual {
                    assert!(expected.contains(&node), "Node {} not expected", node);
                }
            }
            Expected::GreaterThan(expected) => {
                assert!(
                    actual.len() > expected.len(),
                    "Expected length: greater than {}, actual length: {}",
                    expected.len(),
                    actual.len()
                );
                for node in expected {
                    assert!(actual.contains(node), "Node {} not found", node);
                }
            }
        }
    }
}

impl fmt::Display for Expected {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Expected::Exactly(v) => write!(f, "exactly {:?}", v),
            Expected::AtLeast(v) => write!(f, "at least {:?}", v),
            Expected::AtMost(v) => write!(f, "at most {:?}", v),
            Expected::LessThan(v) => write!(f, "less than {:?}", v),
            Expected::GreaterThan(v) => write!(f, "greater than {:?}", v),
        }
    }
}

//---------------------------------------------------------------------
// Test
//---------------------------------------------------------------------

pub struct Test<const N: usize> {
    nodes: [TestNode; N],
    expected_peers_sets: [Expected; N],
    keypairs: [Keypair; N],
    consensus_base_port: usize,
    spawn_delay: Duration,
    timeout: Duration,
    discovery_config: DiscoveryConfig,
}

impl<const N: usize> Test<N> {
    pub fn new(
        nodes: [TestNode; N],
        expected_peers_sets: [Expected; N],
        spawn_delay: Duration,
        timeout: Duration,
        discovery_config: DiscoveryConfig,
    ) -> Self {
        Self {
            nodes,
            expected_peers_sets,
            keypairs: Self::create_keypairs(),
            consensus_base_port: rand::thread_rng().gen_range(21000..50000),
            spawn_delay,
            timeout,
            discovery_config,
        }
    }

    fn create_keypairs() -> [Keypair; N] {
        let mut rng = StdRng::seed_from_u64(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        );
        std::array::from_fn(|_| {
            let privkey = PrivateKey::generate(&mut rng);
            Keypair::ed25519_from_bytes(privkey.inner().to_bytes()).unwrap()
        })
    }

    fn generate_default_configs(&self, discovery_config: DiscoveryConfig) -> [Config; N] {
        std::array::from_fn(|i| Config {
            listen_addr: TransportProtocol::Quic
                .multiaddr("127.0.0.1", self.consensus_base_port + i),
            persistent_peers: self.nodes[i]
                .bootstrap_nodes
                .iter()
                .map(|j| {
                    TransportProtocol::Quic.multiaddr("127.0.0.1", self.consensus_base_port + *j)
                })
                .collect(),
            discovery: discovery_config,
            idle_connection_timeout: Duration::from_secs(60),
            transport: malachitebft_network::TransportProtocol::Quic,
            gossipsub: malachitebft_network::GossipSubConfig::default(),
            pubsub_protocol: malachitebft_network::PubSubProtocol::default(),
            rpc_max_size: 10 * 1024 * 1024,   // 10 MiB
            pubsub_max_size: 4 * 1024 * 1024, // 4 MiB
            enable_sync: false,
        })
    }

    pub async fn run(self) {
        init_logging();
        info!("Starting test with {} nodes", N);

        let configs = self.generate_default_configs(self.discovery_config);
        debug!("Generated configs");

        let mut handles = Vec::with_capacity(N);

        for (i, config) in configs.iter().enumerate().take(N) {
            if self.nodes[i].start_node() {
                let moniker = format!("node-{i}");
                let handle = spawn(
                    self.keypairs[i].clone(),
                    config.clone(),
                    SharedRegistry::global().with_moniker(moniker),
                )
                .await
                .unwrap();

                handles.push(handle);
                debug!(id = %i, "Spawned node");
                sleep(self.spawn_delay).await;
            }
        }

        sleep(self.timeout).await;

        let mut tasks = Vec::with_capacity(N);

        for mut handle in handles {
            let task = tokio::spawn(async move {
                let mut peers = Vec::new();

                loop {
                    tokio::select! {
                        event = handle.recv() => {
                            match event {
                                Some(malachitebft_network::Event::PeerConnected(peer_id)) => {
                                    if !peers.contains(&peer_id.to_libp2p()) {
                                        peers.push(peer_id.to_libp2p());
                                    }
                                }
                                Some(malachitebft_network::Event::PeerDisconnected(peer_id)) => {
                                    if let Some(pos) = peers.iter().position(|p| p == &peer_id.to_libp2p()) {
                                        peers.remove(pos);
                                    }
                                }
                                Some(_) => {}
                                None => break,
                            }
                        }
                        _ = sleep(Duration::from_secs(1)) => {
                            handle.shutdown().await.unwrap();
                            break;
                        }
                    }
                }

                peers
            });

            tasks.push(task);
        }

        let actuals: Vec<Vec<PeerId>> = futures::future::join_all(tasks)
            .await
            .into_iter()
            .map(|res| res.unwrap())
            .collect();

        let peer_id_to_index = |peer_id: &PeerId| -> usize {
            self.keypairs
                .iter()
                .enumerate()
                .find_map(|(i, keypair)| {
                    if PeerId::from_public_key(&keypair.public()) == *peer_id {
                        Some(i)
                    } else {
                        None
                    }
                })
                .expect("Peer not found")
        };

        for (i, expected) in self.expected_peers_sets.iter().enumerate() {
            let actual = actuals[i].iter().map(peer_id_to_index).collect::<Vec<_>>();
            expected.check(actual);
        }
    }
}

//---------------------------------------------------------------------
// Test node
//---------------------------------------------------------------------

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Fault {
    NoStart,
}

#[derive(Clone, Debug)]
pub struct TestNode {
    _id: usize,
    bootstrap_nodes: Vec<usize>,
    faults: Vec<Fault>,
}

impl TestNode {
    pub fn correct(id: usize, bootstrap_nodes: Vec<usize>) -> Self {
        Self {
            _id: id,
            bootstrap_nodes,
            faults: Vec::new(),
        }
    }

    pub fn faulty(id: usize, bootstrap_nodes: Vec<usize>, faults: Vec<Fault>) -> Self {
        Self {
            _id: id,
            bootstrap_nodes,
            faults,
        }
    }

    pub fn bootstrap_nodes(&self) -> &[usize] {
        &self.bootstrap_nodes
    }

    pub fn start_node(&self) -> bool {
        !self.faults.contains(&Fault::NoStart)
    }
}

//---------------------------------------------------------------------
// Helpers
//---------------------------------------------------------------------

fn init_logging() {
    use tracing_subscriber::util::SubscriberInitExt;
    use tracing_subscriber::{EnvFilter, FmtSubscriber};

    let filter = EnvFilter::builder()
        .parse("info,informalsystems_malachitebft=debug,ractor=error")
        .unwrap();

    pub fn enable_ansi() -> bool {
        use std::io::IsTerminal;
        std::io::stdout().is_terminal() && std::io::stderr().is_terminal()
    }

    // Construct a tracing subscriber with the supplied filter and enable reloading.
    let builder = FmtSubscriber::builder()
        .with_target(false)
        .with_env_filter(filter)
        .with_writer(std::io::stdout)
        .with_ansi(enable_ansi())
        .with_thread_ids(false);

    let subscriber = builder.finish();

    if let Err(e) = subscriber.try_init() {
        eprintln!("Failed to initialize logging: {e}");
    }
}

```
---
### `network/test/tests/discovery.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::{time::Duration, vec};

use informalsystems_malachitebft_discovery_test::{Expected, Test, TestNode};
use malachitebft_network::{BootstrapProtocol, DiscoveryConfig, Selector};

// Testing the following circular bootstrap sets graph:
//     0 <--- 1 <--- 2 <--- 3 <--- 4
//     |                           ^
//     +---------------------------+
#[tokio::test]
pub async fn circular_graph() {
    let test = Test::new(
        [
            TestNode::correct(0, vec![4]),
            TestNode::correct(1, vec![0]),
            TestNode::correct(2, vec![1]),
            TestNode::correct(3, vec![2]),
            TestNode::correct(4, vec![3]),
        ],
        [
            Expected::Exactly(vec![1, 2, 3, 4]),
            Expected::Exactly(vec![0, 2, 3, 4]),
            Expected::Exactly(vec![0, 1, 3, 4]),
            Expected::Exactly(vec![0, 1, 2, 4]),
            Expected::Exactly(vec![0, 1, 2, 3]),
        ],
        Duration::from_secs(0),
        Duration::from_secs(10),
        DiscoveryConfig {
            enabled: true,
            bootstrap_protocol: BootstrapProtocol::Full,
            selector: Selector::Random,
            ..Default::default()
        },
    );

    test.run().await
}

// Testing a circular bootstrap sets graph with N nodes.
#[tokio::test]
pub async fn circular_graph_n() {
    const N: usize = 10;

    let mut nodes = Vec::with_capacity(N);
    let mut expected = Vec::with_capacity(N);
    for i in 0..N {
        let bootstrap = if i == 0 { vec![N - 1] } else { vec![i - 1] };
        nodes.push(TestNode::correct(i, bootstrap));
        expected.push(Expected::Exactly(
            (0..N).filter(|&j| j != i).collect::<Vec<_>>(),
        ));
    }

    let test: Test<N> = Test::new(
        nodes.try_into().expect("Expected a Vec of length 100"),
        expected.try_into().expect("Expected a Vec of length 100"),
        Duration::from_secs(0),
        Duration::from_secs(10),
        DiscoveryConfig {
            enabled: true,
            bootstrap_protocol: BootstrapProtocol::Full,
            selector: Selector::Random,
            ..Default::default()
        },
    );

    test.run().await
}

// Testing correctness when discovery is disabled. Especially, the nodes should
// not accept more connections than the defined number of inbound peers in the
// configuration.
#[tokio::test]
pub async fn discovery_disabled() {
    let test = Test::new(
        [
            TestNode::correct(0, vec![]),
            TestNode::correct(1, vec![0]),
            TestNode::correct(2, vec![0, 1]),
            TestNode::correct(3, vec![1, 2]),
            TestNode::correct(4, vec![2, 3]),
            TestNode::correct(5, vec![3, 4]),
            TestNode::correct(6, vec![4, 5]),
            TestNode::correct(7, vec![5, 6]),
            TestNode::correct(8, vec![6, 7]),
            TestNode::correct(9, vec![7, 8]),
            TestNode::correct(10, vec![8, 9]),
        ],
        [
            Expected::Exactly(vec![1, 2]),
            Expected::Exactly(vec![0, 2]),
            Expected::Exactly(vec![0, 1]),
            Expected::Exactly(vec![4, 5]),
            Expected::Exactly(vec![3, 5]),
            Expected::Exactly(vec![3, 4]),
            Expected::Exactly(vec![7, 8]),
            Expected::Exactly(vec![6, 8]),
            Expected::Exactly(vec![6, 7]),
            Expected::Exactly(vec![10]),
            Expected::Exactly(vec![9]),
        ],
        Duration::from_secs(1),
        Duration::from_secs(10),
        DiscoveryConfig {
            enabled: false,
            num_inbound_peers: 2,
            ..Default::default()
        },
    );

    test.run().await
}

```
---
### `peer/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-peer"
description = "Peer definition for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[features]
rand = ["dep:rand"]
serde = ["dep:serde"]

[dependencies]
multihash = { workspace = true, default-features = false, features = ["alloc"] }
bs58 = { workspace = true, default-features = false, features = ["alloc"] }
thiserror = { workspace = true }
rand = { workspace = true, optional = true }
serde = { workspace = true, optional = true }

[lints]
workspace = true

```
---
### `peer/src/lib.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
// Copyright 2018 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
#![no_std]
extern crate alloc;

use alloc::{
    string::{String, ToString},
    vec::Vec,
};
use core::{fmt, str::FromStr};

use thiserror::Error;

#[cfg(feature = "rand")]
use rand::Rng;

/// Local type-alias for multihash.
///
/// Must be big enough to accommodate for `MAX_INLINE_KEY_LENGTH`.
/// 64 satisfies that and can hold 512 bit hashes which is what the ecosystem typically uses.
/// Given that this appears in our type-signature, using a "common" number here makes us more compatible.
type Multihash = multihash::Multihash<64>;

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Public keys with byte-lengths smaller than `MAX_INLINE_KEY_LENGTH` will be
/// automatically used as the peer id using an identity multihash.
const MAX_INLINE_KEY_LENGTH: usize = 42;

const MULTIHASH_IDENTITY_CODE: u64 = 0;
const MULTIHASH_SHA256_CODE: u64 = 0x12;

/// Identifier of a peer of the network.
///
/// The data is a CIDv0 compatible multihash of the protobuf encoded public key of the peer
/// as specified in [specs/peer-ids](https://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md).
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PeerId {
    multihash: Multihash,
}

impl fmt::Debug for PeerId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("PeerId").field(&self.to_base58()).finish()
    }
}

impl fmt::Display for PeerId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.to_base58().fmt(f)
    }
}

impl PeerId {
    /// Parses a `PeerId` from bytes.
    pub fn from_bytes(data: &[u8]) -> Result<PeerId, ParseError> {
        PeerId::from_multihash(
            Multihash::from_bytes(data).map_err(|e| ParseError::InvalidMultihash(e.to_string()))?,
        )
        .map_err(|mh| ParseError::UnsupportedCode(mh.code()))
    }

    /// Tries to turn a `Multihash` into a `PeerId`.
    ///
    /// If the multihash does not use a valid hashing algorithm for peer IDs,
    /// or the hash value does not satisfy the constraints for a hashed
    /// peer ID, it is returned as an `Err`.
    pub fn from_multihash(multihash: Multihash) -> Result<PeerId, Multihash> {
        match multihash.code() {
            MULTIHASH_SHA256_CODE => Ok(PeerId { multihash }),
            MULTIHASH_IDENTITY_CODE if multihash.digest().len() <= MAX_INLINE_KEY_LENGTH => {
                Ok(PeerId { multihash })
            }
            _ => Err(multihash),
        }
    }

    /// Generates a random peer ID from a cryptographically secure PRNG.
    ///
    /// This is useful for randomly walking on a DHT, or for testing purposes.
    #[cfg(feature = "rand")]
    pub fn random() -> PeerId {
        let peer_id = rand::thread_rng().gen::<[u8; 32]>();
        PeerId {
            multihash: Multihash::wrap(0x0, &peer_id).expect("The digest size is never too large"),
        }
    }

    /// Returns a raw bytes representation of this `PeerId`.
    pub fn to_bytes(self) -> Vec<u8> {
        self.multihash.to_bytes()
    }

    /// Returns a base-58 encoded string of this `PeerId`.
    pub fn to_base58(self) -> String {
        bs58::encode(self.to_bytes()).into_string()
    }
}

impl TryFrom<Vec<u8>> for PeerId {
    type Error = Vec<u8>;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        PeerId::from_bytes(&value).map_err(|_| value)
    }
}

impl TryFrom<Multihash> for PeerId {
    type Error = Multihash;

    fn try_from(value: Multihash) -> Result<Self, Self::Error> {
        PeerId::from_multihash(value)
    }
}

impl AsRef<Multihash> for PeerId {
    fn as_ref(&self) -> &Multihash {
        &self.multihash
    }
}

impl From<PeerId> for Multihash {
    fn from(peer_id: PeerId) -> Self {
        peer_id.multihash
    }
}

impl From<PeerId> for Vec<u8> {
    fn from(peer_id: PeerId) -> Self {
        peer_id.to_bytes()
    }
}

#[cfg(feature = "serde")]
impl Serialize for PeerId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        if serializer.is_human_readable() {
            serializer.serialize_str(&self.to_base58())
        } else {
            serializer.serialize_bytes(&self.to_bytes()[..])
        }
    }
}

#[cfg(feature = "serde")]
impl<'de> Deserialize<'de> for PeerId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::de::*;

        struct PeerIdVisitor;

        impl Visitor<'_> for PeerIdVisitor {
            type Value = PeerId;

            fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
                write!(f, "valid peer id")
            }

            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
            where
                E: Error,
            {
                PeerId::from_bytes(v).map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))
            }

            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: Error,
            {
                PeerId::from_str(v).map_err(|_| Error::invalid_value(Unexpected::Str(v), &self))
            }
        }

        if deserializer.is_human_readable() {
            deserializer.deserialize_str(PeerIdVisitor)
        } else {
            deserializer.deserialize_bytes(PeerIdVisitor)
        }
    }
}

/// Error when parsing a [`PeerId`] from string or bytes.
#[derive(Debug, Error)]
pub enum ParseError {
    #[error("base-58 decode error: {0}")]
    B58(String),
    #[error("unsupported multihash code '{0}'")]
    UnsupportedCode(u64),
    #[error("invalid multihash: {0}")]
    InvalidMultihash(String),
}

impl FromStr for PeerId {
    type Err = ParseError;

    #[inline]
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = bs58::decode(s)
            .into_vec()
            .map_err(|e| ParseError::B58(e.to_string()))?;
        let peer_id = PeerId::from_bytes(&bytes)?;

        Ok(peer_id)
    }
}

```
---
### `proto/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-proto"
description = "Protobuf abstraction for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
prost.workspace = true
prost-types.workspace = true
thiserror.workspace = true

```
---
### `proto/src/lib.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::convert::Infallible;

use prost::bytes::Bytes;
use prost_types::Any;
use thiserror::Error;

use prost::{DecodeError, EncodeError, Message, Name};

#[derive(Debug, Error)]
pub enum Error {
    #[error("Failed to decode Protobuf message")]
    Decode(#[from] DecodeError),

    #[error("Failed to encode Protobuf message")]
    Encode(#[from] EncodeError),

    #[error("Unable to decode Protobuf message `{type_url}`: missing field `{field}`")]
    MissingField {
        type_url: String,
        field: &'static str,
    },

    #[error("Unable to decode Protobuf message `{type_url}`: invalid data in field `{field}`")]
    InvalidData {
        type_url: String,
        field: &'static str,
    },

    #[error("Unknown message type: `{type_url}`")]
    UnknownMessageType { type_url: String },

    #[error("{0}")]
    Other(String),
}

impl Error {
    pub fn missing_field<N: prost::Name>(field: &'static str) -> Self {
        let type_url = N::full_name();
        Self::MissingField { type_url, field }
    }

    pub fn invalid_data<N: prost::Name>(field: &'static str) -> Self {
        let type_url = N::full_name();
        Self::InvalidData { type_url, field }
    }
}

impl From<String> for Error {
    fn from(s: String) -> Self {
        Self::Other(s)
    }
}

impl From<Infallible> for Error {
    fn from(_: Infallible) -> Self {
        unreachable!()
    }
}

pub trait Protobuf: Sized {
    type Proto: Name + Message + Default;

    fn from_proto(proto: Self::Proto) -> Result<Self, Error>;

    fn to_proto(&self) -> Result<Self::Proto, Error>;

    fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        let proto = Self::Proto::decode(bytes)?;
        let result = Self::from_proto(proto)?;
        Ok(result)
    }

    fn to_bytes(&self) -> Result<Bytes, Error> {
        let proto = self.to_proto()?;
        Ok(Bytes::from(proto.encode_to_vec()))
    }

    fn from_any(any: &Any) -> Result<Self, Error> {
        Self::from_proto(any.to_msg::<Self::Proto>()?)
    }

    fn to_any(&self) -> Result<Any, Error> {
        Ok(Any::from_msg(&self.to_proto()?)?)
    }
}

```
---
### `signing-ed25519/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-signing-ed25519"
description = "Ed25519 signing scheme for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[features]
std = []
serde = ["dep:serde", "dep:base64"]
rand = ["dep:rand"]

[dependencies]
malachitebft-core-types = { workspace = true }

signature = { workspace = true }
ed25519-consensus = { workspace = true }

# Optional dependencies
rand = { workspace = true, optional = true }   # rand
serde = { workspace = true, optional = true }  # serde
base64 = { workspace = true, optional = true } # serde

[lints]
workspace = true

```
---
### `signing-ed25519/src/lib.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

extern crate alloc;

use alloc::vec::Vec;

use malachitebft_core_types::SigningScheme;
use signature::{Keypair, Signer, Verifier};

#[cfg(feature = "rand")]
use rand::{CryptoRng, RngCore};

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

#[cfg(feature = "serde")]
#[cfg_attr(coverage_nightly, coverage(off))]
mod serializers;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct Ed25519;

impl Ed25519 {
    #[cfg(feature = "rand")]
    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn generate_keypair<R>(rng: R) -> PrivateKey
    where
        R: RngCore + CryptoRng,
    {
        PrivateKey::generate(rng)
    }
}

impl SigningScheme for Ed25519 {
    type DecodingError = ed25519_consensus::Error;

    type Signature = Signature;
    type PublicKey = PublicKey;
    type PrivateKey = PrivateKey;

    fn encode_signature(signature: &Signature) -> Vec<u8> {
        signature.to_bytes().to_vec()
    }

    fn decode_signature(bytes: &[u8]) -> Result<Self::Signature, Self::DecodingError> {
        Signature::try_from(bytes)
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(transparent))]
pub struct Signature(ed25519_consensus::Signature);

impl Signature {
    pub fn inner(&self) -> &ed25519_consensus::Signature {
        &self.0
    }

    pub fn to_bytes(&self) -> [u8; 64] {
        self.0.to_bytes()
    }

    pub fn from_bytes(bytes: [u8; 64]) -> Self {
        Self(ed25519_consensus::Signature::from(bytes))
    }

    pub fn test() -> Signature {
        Signature(ed25519_consensus::Signature::from([0; 64]))
    }
}

impl From<ed25519_consensus::Signature> for Signature {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from(signature: ed25519_consensus::Signature) -> Self {
        Self(signature)
    }
}

impl TryFrom<&[u8]> for Signature {
    type Error = ed25519_consensus::Error;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        Ok(Self(ed25519_consensus::Signature::try_from(bytes)?))
    }
}

impl PartialOrd for Signature {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Signature {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        self.0.to_bytes().cmp(&other.0.to_bytes())
    }
}

#[derive(Clone, Debug)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(transparent))]
pub struct PrivateKey(
    #[cfg_attr(feature = "serde", serde(with = "self::serializers::signing_key"))]
    ed25519_consensus::SigningKey,
);

impl PrivateKey {
    #[cfg(feature = "rand")]
    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn generate<R>(rng: R) -> Self
    where
        R: RngCore + CryptoRng,
    {
        let signing_key = ed25519_consensus::SigningKey::new(rng);

        Self(signing_key)
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn public_key(&self) -> PublicKey {
        PublicKey::new(self.0.verification_key())
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn sign(&self, msg: &[u8]) -> Signature {
        Signature(self.0.sign(msg))
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn inner(&self) -> &ed25519_consensus::SigningKey {
        &self.0
    }
}

impl From<[u8; 32]> for PrivateKey {
    fn from(bytes: [u8; 32]) -> Self {
        Self(ed25519_consensus::SigningKey::from(bytes))
    }
}

impl Signer<Signature> for PrivateKey {
    fn try_sign(&self, msg: &[u8]) -> Result<Signature, signature::Error> {
        Ok(Signature(self.0.sign(msg)))
    }
}

impl Keypair for PrivateKey {
    type VerifyingKey = PublicKey;

    fn verifying_key(&self) -> Self::VerifyingKey {
        self.public_key()
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "serde", serde(transparent))]
pub struct PublicKey(
    #[cfg_attr(feature = "serde", serde(with = "self::serializers::verification_key"))]
    ed25519_consensus::VerificationKey,
);

impl PublicKey {
    pub fn new(key: impl Into<ed25519_consensus::VerificationKey>) -> Self {
        Self(key.into())
    }

    pub fn as_bytes(&self) -> &[u8; 32] {
        self.0.as_bytes()
    }

    pub fn from_bytes(bytes: [u8; 32]) -> Self {
        Self(ed25519_consensus::VerificationKey::try_from(bytes).unwrap())
    }

    pub fn verify(&self, msg: &[u8], signature: &Signature) -> Result<(), signature::Error> {
        self.0
            .verify(signature.inner(), msg)
            .map_err(|_| signature::Error::new())
    }

    pub fn inner(&self) -> &ed25519_consensus::VerificationKey {
        &self.0
    }
}

impl Verifier<Signature> for PublicKey {
    fn verify(&self, msg: &[u8], signature: &Signature) -> Result<(), signature::Error> {
        PublicKey::verify(self, msg, signature)
    }
}

```
---
### `signing-ed25519/src/serializers/base64string.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Serialize/deserialize base64-encoded strings

use alloc::string::{String, ToString};
use alloc::vec::Vec;

use base64::prelude::BASE64_STANDARD;
use base64::Engine;
use serde::{Deserialize, Serializer};

pub fn serialize<S>(s: &[u8], ser: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    ser.serialize_str(BASE64_STANDARD.encode(s).as_str())
}

pub fn deserialize<'de, D>(de: D) -> Result<Vec<u8>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let s = String::deserialize(de)?;
    BASE64_STANDARD
        .decode(s)
        .map_err(|e| serde::de::Error::custom(e.to_string()))
}

```
---
### `signing-ed25519/src/serializers/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod base64string;
pub mod signing_key;
pub mod verification_key;

```
---
### `signing-ed25519/src/serializers/signing_key.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Serde Ed25519 SigningKey CometBFT serializer/deserializer.

use alloc::string::{String, ToString};
use alloc::vec::Vec;

use ed25519_consensus::SigningKey;
use serde::{Deserialize, Serialize, Serializer};

#[derive(Serialize, Deserialize)]
struct PrivKey {
    #[serde(rename = "type")]
    key_type: String,
    #[serde(with = "super::base64string")]
    value: Vec<u8>,
}

pub fn serialize<S>(s: &SigningKey, ser: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    PrivKey {
        key_type: "tendermint/PrivKeyEd25519".to_string(),
        value: s.as_bytes().to_vec(),
    }
    .serialize(ser)
}

pub fn deserialize<'de, D>(de: D) -> Result<SigningKey, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let pk = PrivKey::deserialize(de)?;
    SigningKey::try_from(pk.value.as_slice()).map_err(serde::de::Error::custom)
}

```
---
### `signing-ed25519/src/serializers/verification_key.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Serde Ed25519 VerificationKey CometBFT serializer/deserializer.

use alloc::string::{String, ToString};
use alloc::vec::Vec;

use ed25519_consensus::VerificationKey;
use serde::{Deserialize, Serialize, Serializer};

#[derive(Serialize, Deserialize)]
struct PubKey {
    #[serde(rename = "type")]
    key_type: String,
    #[serde(with = "super::base64string")]
    value: Vec<u8>,
}

pub fn serialize<S>(s: &VerificationKey, ser: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    PubKey {
        key_type: "tendermint/PubKeyEd25519".to_string(),
        value: s.as_bytes().to_vec(),
    }
    .serialize(ser)
}

pub fn deserialize<'de, D>(de: D) -> Result<VerificationKey, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let pk = PubKey::deserialize(de)?;
    VerificationKey::try_from(pk.value.as_slice()).map_err(serde::de::Error::custom)
}

```
---
### `starknet/app/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-starknet-app"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[lints]
workspace = true

[dependencies]
malachitebft-app = { workspace = true }
malachitebft-test-cli = { workspace = true }
malachitebft-config = { workspace = true }
malachitebft-starknet-host = { workspace = true }

color-eyre = { workspace = true }
tracing = { workspace = true }

[target.'cfg(target_os = "linux")'.dependencies]
tikv-jemallocator = { workspace = true, features = ["background_threads"] }

[dev-dependencies]
clap = { workspace = true }
tempfile = { workspace = true }

```
---
### `starknet/app/src/main.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use color_eyre::eyre::Context;

use malachitebft_app::node::Node;
use malachitebft_config::{LogFormat, LogLevel};
use malachitebft_starknet_host::codec::ProtobufCodec;
use malachitebft_starknet_host::node::{ConfigSource, StarknetNode};
use malachitebft_test_cli::args::{Args, Commands};
use malachitebft_test_cli::{logging, runtime};

// Use jemalloc on Linux
#[cfg(target_os = "linux")]
#[global_allocator]
static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;

pub fn main() -> color_eyre::Result<()> {
    color_eyre::install().expect("Failed to install global error handler");

    // Load command-line arguments and possible configuration file.
    let args = Args::new();

    let home_dir = args.get_home_dir()?;
    let config_file = args.get_config_file_path()?;

    match &args.command {
        Commands::Start(cmd) => {
            // Redefine the node with the valid configuration.
            let node =
                StarknetNode::new(home_dir, ConfigSource::File(config_file), cmd.start_height);

            let config = node.load_config()?;

            // This is a drop guard responsible for flushing any remaining logs when the program terminates.
            // It must be assigned to a binding that is not _, as _ will result in the guard being dropped immediately.
            let _guard = logging::init(config.logging.log_level, config.logging.log_format);

            let metrics = config.metrics.enabled.then(|| config.metrics.clone());

            let rt = runtime::build_runtime(config.runtime)?;

            rt.block_on(cmd.run(node, metrics))
                .wrap_err("Failed to run `start` command")
        }

        Commands::Init(cmd) => {
            let _guard = logging::init(LogLevel::Info, LogFormat::Plaintext);

            let node = &StarknetNode::new(home_dir.clone(), ConfigSource::Default, None);

            cmd.run(
                node,
                &config_file,
                &args.get_genesis_file_path().unwrap(),
                &args.get_priv_validator_key_file_path().unwrap(),
            )
            .wrap_err("Failed to run `init` command")
        }

        Commands::Testnet(cmd) => {
            let _guard = logging::init(LogLevel::Info, LogFormat::Plaintext);

            let node = &StarknetNode {
                home_dir: home_dir.clone(),
                config_source: ConfigSource::Default,
                start_height: None,
            };

            cmd.run(node, &home_dir)
                .wrap_err("Failed to run `testnet` command")
        }

        Commands::DistributedTestnet(cmd) => {
            let _guard = logging::init(LogLevel::Info, LogFormat::Plaintext);

            let node = &StarknetNode {
                home_dir: home_dir.clone(),
                config_source: ConfigSource::Default,
                start_height: None,
            };

            cmd.run(node, &home_dir)
                .wrap_err("Failed to run `distributed-testnet` command")
        }

        Commands::DumpWal(cmd) => {
            let _guard = logging::init(LogLevel::Info, LogFormat::Plaintext);

            cmd.run(ProtobufCodec)
                .wrap_err("Failed to run `dump-wal` command")
        }
    }
}

#[cfg(test)]
mod tests {
    use std::fs;
    use std::path::PathBuf;

    use clap::Parser;
    use color_eyre::eyre;
    use color_eyre::eyre::eyre;

    use malachitebft_starknet_host::node::{ConfigSource, StarknetNode};
    use malachitebft_test_cli::args::{Args, Commands};
    use malachitebft_test_cli::cmd::init::*;

    #[test]
    fn running_init_creates_config_files() -> eyre::Result<()> {
        let tmp = tempfile::tempdir()?;
        let config_dir = tmp.path().join("config");

        let args = Args::parse_from(["test", "--home", tmp.path().to_str().unwrap(), "init"]);
        let cmd = InitCmd::default();

        let node = &StarknetNode {
            home_dir: tmp.path().to_owned(),
            config_source: ConfigSource::Default,
            start_height: None,
        };

        cmd.run(
            node,
            &args.get_config_file_path().unwrap(),
            &args.get_genesis_file_path().unwrap(),
            &args.get_priv_validator_key_file_path().unwrap(),
        )
        .expect("Failed to run init command");

        let files = fs::read_dir(&config_dir)?.flatten().collect::<Vec<_>>();

        assert!(has_file(&files, &config_dir.join("config.toml")));
        assert!(has_file(&files, &config_dir.join("genesis.json")));
        assert!(has_file(
            &files,
            &config_dir.join("priv_validator_key.json")
        ));

        Ok(())
    }

    #[test]
    fn running_testnet_creates_all_configs() -> eyre::Result<()> {
        let tmp = tempfile::tempdir()?;

        let args = Args::parse_from([
            "test",
            "--home",
            tmp.path().to_str().unwrap(),
            "testnet",
            "--nodes",
            "3",
        ]);

        let Commands::Testnet(ref cmd) = args.command else {
            return Err(eyre!("not testnet command"));
        };

        let node = &StarknetNode {
            home_dir: tmp.path().to_owned(),
            config_source: ConfigSource::Default,
            start_height: None,
        };

        cmd.run(node, &args.get_home_dir().unwrap())
            .expect("Failed to run init command");

        let files = fs::read_dir(&tmp)?.flatten().collect::<Vec<_>>();

        assert_eq!(files.len(), 3);

        assert!(has_file(&files, &tmp.path().join("0")));
        assert!(has_file(&files, &tmp.path().join("1")));
        assert!(has_file(&files, &tmp.path().join("2")));

        for node in 0..3 {
            let node_dir = tmp.path().join(node.to_string()).join("config");
            let files = fs::read_dir(&node_dir)?.flatten().collect::<Vec<_>>();

            assert!(has_file(&files, &node_dir.join("config.toml")));
            assert!(has_file(&files, &node_dir.join("genesis.json")));
            assert!(has_file(&files, &node_dir.join("priv_validator_key.json")));
        }

        Ok(())
    }

    fn has_file(files: &[fs::DirEntry], path: &PathBuf) -> bool {
        files.iter().any(|f| &f.path() == path)
    }
}

```
---
### `starknet/host/Cargo.toml`
*2025-05-18 23:58:49 | 2 KB*
```toml
[package]
name = "informalsystems-malachitebft-starknet-host"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[dependencies]
malachitebft-engine = { workspace = true }
malachitebft-app = { workspace = true }
malachitebft-codec = { workspace = true }
malachitebft-config = { workspace = true }
malachitebft-core-consensus = { workspace = true, features = ["debug"] }
malachitebft-core-types = { workspace = true }
malachitebft-network = { workspace = true }
malachitebft-metrics = { workspace = true }
malachitebft-proto = { workspace = true }
malachitebft-starknet-p2p-proto = { workspace = true }
malachitebft-starknet-p2p-types = { workspace = true }
malachitebft-sync = { workspace = true }
malachitebft-test-mempool = { workspace = true }

async-trait = { workspace = true }
bytes = { workspace = true, features = ["serde"] }
bytesize = { workspace = true }
config = { workspace = true }
derive-where = { workspace = true }
eyre = { workspace = true }
itertools = { workspace = true }
libp2p-identity = { workspace = true }
prost = { workspace = true }
ractor = { workspace = true }
rand = { workspace = true }
redb = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
sha3 = { workspace = true }
toml = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
tracing = { workspace = true }

[lints]
workspace = true

[dev-dependencies]
tempfile.workspace = true
malachitebft-test-cli.workspace = true

```
---
### `starknet/host/src/actor.rs`
*2025-05-18 23:58:49 | 21 KB*
```rust
use std::path::PathBuf;
use std::time::Duration;

use bytes::Bytes;
use eyre::eyre;
use itertools::Itertools;
use ractor::{async_trait, Actor, ActorProcessingErr, RpcReplyPort, SpawnErr};
use rand::rngs::StdRng;
use rand::SeedableRng;
use tokio::time::Instant;
use tracing::{debug, error, info, trace, warn};

use malachitebft_core_consensus::{PeerId, VoteExtensionError};
use malachitebft_core_types::{CommitCertificate, Round, Validity, ValueId, ValueOrigin};
use malachitebft_engine::consensus::{ConsensusMsg, ConsensusRef};
use malachitebft_engine::host::{LocallyProposedValue, ProposedValue};
use malachitebft_engine::network::{NetworkMsg, NetworkRef};
use malachitebft_engine::util::streaming::{StreamContent, StreamMessage};
use malachitebft_metrics::Metrics;
use malachitebft_sync::RawDecidedValue;

use crate::host::state::HostState;
use crate::host::{Host as _, StarknetHost};
use crate::mempool::{MempoolMsg, MempoolRef};
use crate::mempool_load::MempoolLoadRef;
use crate::proto::Protobuf;
use crate::types::*;

pub struct Host {
    mempool: MempoolRef,
    mempool_load: MempoolLoadRef,
    network: NetworkRef<MockContext>,
    metrics: Metrics,
    span: tracing::Span,
}

pub type HostRef = malachitebft_engine::host::HostRef<MockContext>;
pub type HostMsg = malachitebft_engine::host::HostMsg<MockContext>;

impl Host {
    pub async fn spawn(
        home_dir: PathBuf,
        host: StarknetHost,
        mempool: MempoolRef,
        mempool_load: MempoolLoadRef,
        network: NetworkRef<MockContext>,
        metrics: Metrics,
        span: tracing::Span,
    ) -> Result<HostRef, SpawnErr> {
        let db_dir = home_dir.join("db");
        std::fs::create_dir_all(&db_dir).map_err(|e| SpawnErr::StartupFailed(e.into()))?;
        let db_path = db_dir.join("blocks.db");

        let ctx = MockContext::new();

        let (actor_ref, _) = Actor::spawn(
            None,
            Self::new(mempool, mempool_load, network, metrics, span),
            HostState::new(ctx, host, db_path, &mut StdRng::from_entropy()).await,
        )
        .await?;

        Ok(actor_ref)
    }

    pub fn new(
        mempool: MempoolRef,
        mempool_load: MempoolLoadRef,
        network: NetworkRef<MockContext>,
        metrics: Metrics,
        span: tracing::Span,
    ) -> Self {
        Self {
            mempool,
            mempool_load,
            network,
            metrics,
            span,
        }
    }
}

#[async_trait]
impl Actor for Host {
    type Arguments = HostState;
    type State = HostState;
    type Msg = HostMsg;

    async fn pre_start(
        &self,
        myself: HostRef,
        initial_state: Self::State,
    ) -> Result<Self::State, ActorProcessingErr> {
        self.mempool.link(myself.get_cell());
        self.mempool_load.link(myself.get_cell());

        Ok(initial_state)
    }

    async fn handle(
        &self,
        _myself: HostRef,
        msg: Self::Msg,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        if let Err(e) = self.handle_msg(_myself, msg, state).await {
            error!(%e, "Failed to handle message");
        }

        Ok(())
    }
}

impl Host {
    #[tracing::instrument(
        name = "host",
        parent = &self.span,
        skip_all,
        fields(height = %state.height, round = %state.round),
    )]
    async fn handle_msg(
        &self,
        _myself: HostRef,
        msg: HostMsg,
        state: &mut HostState,
    ) -> Result<(), ActorProcessingErr> {
        match msg {
            HostMsg::ConsensusReady(consensus) => on_consensus_ready(state, consensus).await,

            HostMsg::StartedRound {
                height,
                round,
                proposer,
            } => on_started_round(state, height, round, proposer).await,

            HostMsg::GetHistoryMinHeight { reply_to } => {
                on_get_history_min_height(state, reply_to).await
            }

            HostMsg::GetValue {
                height,
                round,
                timeout,
                reply_to,
            } => on_get_value(state, &self.network, height, round, timeout, reply_to).await,

            HostMsg::ExtendVote {
                height,
                round,
                value_id,
                reply_to,
            } => on_extend_vote(state, height, round, value_id, reply_to).await,

            HostMsg::VerifyVoteExtension {
                height,
                round,
                value_id,
                extension,
                reply_to,
            } => {
                on_verify_vote_extension(state, height, round, value_id, extension, reply_to).await
            }

            HostMsg::RestreamValue {
                height,
                round,
                valid_round,
                address,
                value_id,
            } => {
                on_restream_proposal(
                    state,
                    &self.network,
                    height,
                    round,
                    value_id,
                    valid_round,
                    address,
                )
                .await
            }

            HostMsg::ReceivedProposalPart {
                from,
                part,
                reply_to,
            } => on_received_proposal_part(state, part, from, reply_to).await,

            HostMsg::GetValidatorSet { height, reply_to } => {
                on_get_validator_set(state, height, reply_to).await
            }

            HostMsg::Decided {
                certificate,
                consensus,
                ..
            } => on_decided(state, &consensus, &self.mempool, certificate, &self.metrics).await,

            HostMsg::GetDecidedValue { height, reply_to } => {
                on_get_decided_block(height, state, reply_to).await
            }

            HostMsg::ProcessSyncedValue {
                height,
                round,
                validator_address,
                value_bytes,
                reply_to,
            } => on_process_synced_value(value_bytes, height, round, validator_address, reply_to),
        }
    }
}

async fn on_consensus_ready(
    state: &mut HostState,
    consensus: ConsensusRef<MockContext>,
) -> Result<(), ActorProcessingErr> {
    let latest_block_height = state.block_store.last_height().await.unwrap_or_default();
    let start_height = latest_block_height.increment();

    state.consensus = Some(consensus.clone());

    tokio::time::sleep(Duration::from_millis(200)).await;

    consensus.cast(ConsensusMsg::StartHeight(
        start_height,
        state.host.validator_set.clone(),
    ))?;

    Ok(())
}

async fn replay_undecided_values(
    state: &mut HostState,
    height: Height,
    round: Round,
) -> Result<(), ActorProcessingErr> {
    let undecided_values = state
        .block_store
        .get_undecided_values(height, round)
        .await?;

    let consensus = state.consensus.as_ref().unwrap();

    for value in undecided_values {
        info!(%height, %round, hash = %value.value, "Replaying already known proposed value");

        consensus.cast(ConsensusMsg::ReceivedProposedValue(
            value,
            ValueOrigin::Consensus,
        ))?;
    }

    Ok(())
}

async fn on_started_round(
    state: &mut HostState,
    height: Height,
    round: Round,
    proposer: Address,
) -> Result<(), ActorProcessingErr> {
    state.height = height;
    state.round = round;
    state.proposer = Some(proposer);

    // If we have already built or seen one or more values for this height and round,
    // feed them back to consensus. This may happen when we are restarting after a crash.
    replay_undecided_values(state, height, round).await?;

    Ok(())
}

async fn on_get_history_min_height(
    state: &mut HostState,
    reply_to: RpcReplyPort<Height>,
) -> Result<(), ActorProcessingErr> {
    let history_min_height = state.block_store.first_height().await.unwrap_or_default();
    reply_to.send(history_min_height)?;

    Ok(())
}

async fn on_get_validator_set(
    state: &mut HostState,
    height: Height,
    reply_to: RpcReplyPort<Option<ValidatorSet>>,
) -> Result<(), ActorProcessingErr> {
    let Some(validators) = state.host.validators(height).await else {
        return Err(eyre!("No validator set found for the given height {height}").into());
    };

    reply_to.send(Some(ValidatorSet::new(validators)))?;
    Ok(())
}

async fn on_get_value(
    state: &mut HostState,
    network: &NetworkRef<MockContext>,
    height: Height,
    round: Round,
    timeout: Duration,
    reply_to: RpcReplyPort<LocallyProposedValue<MockContext>>,
) -> Result<(), ActorProcessingErr> {
    if let Some(value) = find_previously_built_value(state, height, round).await? {
        info!(%height, %round, hash = %value.value, "Returning previously built value");

        reply_to.send(LocallyProposedValue::new(
            value.height,
            value.round,
            value.value,
        ))?;

        return Ok(());
    }

    let deadline = Instant::now() + timeout;

    debug!(%height, %round, "Building new proposal...");

    let (mut rx_part, rx_hash) = state.host.build_new_proposal(height, round, deadline).await;

    let stream_id = state.stream_id();

    let mut sequence = 0;

    while let Some(part) = rx_part.recv().await {
        state
            .host
            .part_store
            .store(&stream_id, height, round, part.clone());

        debug!(%stream_id, %sequence, "Broadcasting proposal part");

        let msg = StreamMessage::new(
            stream_id.clone(),
            sequence,
            StreamContent::Data(part.clone()),
        );
        network.cast(NetworkMsg::PublishProposalPart(msg))?;

        sequence += 1;
    }

    let msg = StreamMessage::new(stream_id.clone(), sequence, StreamContent::Fin);
    network.cast(NetworkMsg::PublishProposalPart(msg))?;

    let block_hash = rx_hash.await?;
    debug!(%block_hash, "Assembled block");

    state
        .host
        .part_store
        .store_value_id(&stream_id, height, round, block_hash);

    let parts = state
        .host
        .part_store
        .all_parts_by_stream_id(stream_id, height, round);

    let value = state.build_proposal_from_parts(height, round, &parts).await;

    debug!(%height, %round, %block_hash, "Storing proposed value from assembled block");
    if let Err(e) = state.block_store.store_undecided_value(value.clone()).await {
        error!(%e, %height, %round, "Failed to store the proposed value");
    }

    reply_to.send(LocallyProposedValue::new(
        value.height,
        value.round,
        value.value,
    ))?;

    Ok(())
}

async fn on_extend_vote(
    _state: &mut HostState,
    _height: Height,
    _round: Round,
    _value_id: ValueId<MockContext>,
    reply_to: RpcReplyPort<Option<Bytes>>,
) -> Result<(), ActorProcessingErr> {
    // let extension = state.host.generate_vote_extension(height, round);
    reply_to.send(None)?;
    Ok(())
}

async fn on_verify_vote_extension(
    _state: &mut HostState,
    _height: Height,
    _round: Round,
    _value_id: ValueId<MockContext>,
    _extension: Bytes,
    reply_to: RpcReplyPort<Result<(), VoteExtensionError>>,
) -> Result<(), ActorProcessingErr> {
    // TODO
    reply_to.send(Ok(()))?;
    Ok(())
}

/// If we have already built a block for this height and round, return it to consensus
/// This may happen when we are restarting after a crash and replaying the WAL.
async fn find_previously_built_value(
    state: &mut HostState,
    height: Height,
    round: Round,
) -> Result<Option<ProposedValue<MockContext>>, ActorProcessingErr> {
    let values = state
        .block_store
        .get_undecided_values(height, round)
        .await?;

    let proposed_value = values
        .into_iter()
        .find(|v| v.proposer == state.host.address);

    Ok(proposed_value)
}

async fn on_restream_proposal(
    state: &mut HostState,
    network: &NetworkRef<MockContext>,
    height: Height,
    round: Round,
    proposal_commitment_hash: Hash,
    valid_round: Round,
    proposer: Address,
) -> Result<(), ActorProcessingErr> {
    debug!(%height, %round, "Restreaming existing proposal...");

    let mut rx_part = state
        .host
        .send_known_proposal(proposal_commitment_hash)
        .await;

    let stream_id = state.stream_id();

    let init = ProposalInit {
        height,
        round,
        valid_round,
        proposer,
    };

    let init_part = ProposalPart::Init(init);
    let fin_part = ProposalPart::Fin(ProposalFin {
        proposal_commitment_hash,
    });

    debug!(%height, %round, "Created new Init part: {init_part:?}");

    let mut sequence = 0;

    while let Some(part) = rx_part.recv().await {
        let new_part = match part.part_type() {
            PartType::Init => init_part.clone(),
            PartType::BlockInfo => part,
            PartType::Transactions => part,
            PartType::ProposalCommitment => part,
            PartType::Fin => fin_part.clone(),
        };

        state
            .host
            .part_store
            .store(&stream_id, height, round, new_part.clone());

        debug!(%stream_id, %sequence, "Broadcasting proposal part");

        let msg = StreamMessage::new(stream_id.clone(), sequence, StreamContent::Data(new_part));

        network.cast(NetworkMsg::PublishProposalPart(msg))?;

        sequence += 1;
    }

    Ok(())
}

fn on_process_synced_value(
    value_bytes: Bytes,
    height: Height,
    round: Round,
    proposer: Address,
    reply_to: RpcReplyPort<ProposedValue<MockContext>>,
) -> Result<(), ActorProcessingErr> {
    let maybe_block = Block::from_bytes(value_bytes.as_ref());
    if let Ok(block) = maybe_block {
        let proposed_value = ProposedValue {
            height,
            round,
            valid_round: Round::Nil,
            proposer,
            value: block.block_hash,
            validity: Validity::Valid,
        };

        reply_to.send(proposed_value)?;
    }

    Ok(())
}

async fn on_get_decided_block(
    height: Height,
    state: &mut HostState,
    reply_to: RpcReplyPort<Option<RawDecidedValue<MockContext>>>,
) -> Result<(), ActorProcessingErr> {
    debug!(%height, "Received request for block");

    match state.block_store.get(height).await {
        Ok(None) => {
            let min = state.block_store.first_height().await.unwrap_or_default();
            let max = state.block_store.last_height().await.unwrap_or_default();

            warn!(%height, "No block for this height, available blocks: {min}..={max}");

            reply_to.send(None)?;
        }

        Ok(Some(block)) => {
            let block = RawDecidedValue {
                value_bytes: block.block.to_bytes().unwrap(),
                certificate: block.certificate,
            };

            debug!(%height, "Found decided block in store");
            reply_to.send(Some(block))?;
        }
        Err(e) => {
            error!(%e, %height, "Failed to get decided block");
            reply_to.send(None)?;
        }
    }

    Ok(())
}

/// This function handles receiving parts of proposals
/// And assembling proposal in right sequence when all parts are collected
///
/// For each proposal from distinct peer separate stream is opened
/// Bookkeeping of streams is done inside HostState.part_streams_map ((peerId + streamId) -> streamState)
async fn on_received_proposal_part(
    state: &mut HostState,
    part: StreamMessage<ProposalPart>,
    from: PeerId,
    reply_to: RpcReplyPort<ProposedValue<MockContext>>,
) -> Result<(), ActorProcessingErr> {
    // When inserting part in a map, stream tries to connect all received parts in the right order,
    // starting from beginning and emits parts sequence chunks  when it succeeds
    // If it can't connect part, it buffers it
    // E.g. buffered: 1 3 7
    // part 0 (first) arrives -> 0 and 1 are emitted
    // 4 arrives -> gets buffered
    // 2 arrives -> 2, 3 and 4 are emitted

    // `insert` returns connected sequence of parts if any is emitted
    // If all parts have been received the stream is removed from the map streams
    let Some(parts) = state.part_streams_map.insert(from, part.clone()) else {
        return Ok(());
    };

    // The `part` sequence number must be for the first `ProposalPart` in `parts`.
    // So we start with this sequence and we increment for the debug log.
    let mut sequence = part.sequence;
    let stream_id = part.stream_id;

    if parts.height < state.height {
        trace!(
            height = %state.height,
            round = %state.round,
            part.height = %parts.height,
            part.round = %parts.round,
            part.sequence = %sequence,
            "Received outdated proposal part, ignoring"
        );

        return Ok(());
    }

    // Emitted parts are stored and simulated (if it is tx)
    // When finish part is stored, proposal value is built from all of them
    for part in parts.parts {
        debug!(
            part.sequence = %sequence,
            part.height = %parts.height,
            part.round = %parts.round,
            part.message = ?part.part_type(),
            "Processing proposal part"
        );

        if let Some(value) = state
            .build_value_from_part(&stream_id, parts.height, parts.round, part)
            .await
        {
            debug!(
                height = %value.height,
                round = %value.round,
                block_hash = %value.value,
                validity = ?value.validity,
                "Storing proposed value assembled from proposal parts"
            );

            if let Err(e) = state.block_store.store_undecided_value(value.clone()).await {
                error!(
                    %e, height = %value.height, round = %value.round, block_hash = %value.value,
                    "Failed to store the proposed value"
                );
            }

            reply_to.send(value)?;
            break;
        }

        sequence += 1;
    }

    Ok(())
}

//TODO
async fn on_decided(
    state: &mut HostState,
    consensus: &ConsensusRef<MockContext>,
    mempool: &MempoolRef,
    certificate: CommitCertificate<MockContext>,
    metrics: &Metrics,
) -> Result<(), ActorProcessingErr> {
    let (height, round) = (certificate.height, certificate.round);

    let mut all_parts = state
        .host
        .part_store
        .all_parts_by_value_id(&certificate.value_id);

    let mut all_txes = vec![];
    for part in all_parts.iter_mut() {
        if let ProposalPart::Transactions(transactions) = part.as_ref() {
            let mut txes = transactions.to_vec();
            all_txes.append(&mut txes);
        }
    }

    // Build the block from transaction parts and certificate, and store it
    if let Err(e) = state
        .block_store
        .store_decided_block(&certificate, &all_txes)
        .await
    {
        error!(%e, %height, %round, "Failed to store the block");
    }

    // Update metrics
    let tx_count: usize = all_parts.iter().map(|p| p.tx_count()).sum();
    let block_size: usize = all_parts.iter().map(|p| p.size_bytes()).sum();

    metrics.block_tx_count.observe(tx_count as f64);
    metrics.block_size_bytes.observe(block_size as f64);
    metrics.finalized_txes.inc_by(tx_count as u64);

    // Gather hashes of all the tx-es included in the block,
    // so that we can notify the mempool to remove them.
    let mut tx_hashes = vec![];
    for part in all_parts {
        if let ProposalPart::Transactions(txes) = &part.as_ref() {
            tx_hashes.extend(txes.as_slice().iter().map(|tx| tx.hash()));
        }
    }

    // Prune the PartStore of all parts for heights lower than `state.height`
    state.host.part_store.prune(state.height);

    // Prune the block store, keeping only the last `max_retain_blocks` blocks
    prune_block_store(state).await;

    // Notify the mempool to remove corresponding txs
    mempool.cast(MempoolMsg::Update { tx_hashes })?;

    // Notify Starknet Host of the decision
    state.host.decision(certificate).await;

    // Start the next height
    consensus.cast(ConsensusMsg::StartHeight(
        state.height.increment(),
        state.host.validator_set.clone(),
    ))?;

    Ok(())
}

async fn prune_block_store(state: &mut HostState) {
    let max_height = state.block_store.last_height().await.unwrap_or_default();
    let max_retain_blocks = state.host.params.max_retain_blocks as u64;

    // Compute the height to retain blocks higher than
    let retain_height = max_height.as_u64().saturating_sub(max_retain_blocks);
    if retain_height <= 1 {
        // No need to prune anything, since we would retain every blocks
        return;
    }

    let retain_height = Height::new(retain_height, max_height.fork_id);
    match state.block_store.prune(retain_height).await {
        Ok(pruned) => {
            debug!(
                %retain_height, pruned_heights = pruned.iter().join(", "),
                "Pruned the block store"
            );
        }
        Err(e) => {
            error!(%e, %retain_height, "Failed to prune the block store");
        }
    }
}

```
---
### `starknet/host/src/block_store/keys.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use core::mem::size_of;

use malachitebft_core_types::Round;
use malachitebft_starknet_p2p_types::{BlockHash, Height};

pub type UndecidedValueKey = (HeightKey, RoundKey, BlockHashKey);

#[derive(Copy, Clone, Debug)]
pub struct HeightKey;

impl redb::Value for HeightKey {
    type SelfType<'a> = Height;
    type AsBytes<'a> = Vec<u8>;

    fn fixed_width() -> Option<usize> {
        Some(size_of::<u64>() * 2)
    }

    fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
    where
        Self: 'a,
    {
        let (fork_id, block_number) = <(u64, u64) as redb::Value>::from_bytes(data);

        Height {
            fork_id,
            block_number,
        }
    }

    fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
    where
        Self: 'a,
        Self: 'b,
    {
        <(u64, u64) as redb::Value>::as_bytes(&(value.fork_id, value.block_number))
    }

    fn type_name() -> redb::TypeName {
        redb::TypeName::new("starknet::Height")
    }
}

impl redb::Key for HeightKey {
    fn compare(data1: &[u8], data2: &[u8]) -> std::cmp::Ordering {
        <(u64, u64) as redb::Key>::compare(data1, data2)
    }
}

#[derive(Copy, Clone, Debug)]
pub struct RoundKey;

impl redb::Value for RoundKey {
    type SelfType<'a> = Round;
    type AsBytes<'a> = [u8; size_of::<i64>()];

    fn fixed_width() -> Option<usize> {
        Some(size_of::<i64>())
    }

    fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
    where
        Self: 'a,
    {
        let round = <i64 as redb::Value>::from_bytes(data);
        Round::from(round)
    }

    fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
    where
        Self: 'a,
        Self: 'b,
    {
        <i64 as redb::Value>::as_bytes(&value.as_i64())
    }

    fn type_name() -> redb::TypeName {
        redb::TypeName::new("Round")
    }
}

impl redb::Key for RoundKey {
    fn compare(data1: &[u8], data2: &[u8]) -> std::cmp::Ordering {
        <i64 as redb::Key>::compare(data1, data2)
    }
}

#[derive(Copy, Clone, Debug)]
pub struct BlockHashKey;

impl redb::Value for BlockHashKey {
    type SelfType<'a> = BlockHash;
    type AsBytes<'a> = &'a [u8; 32];

    fn fixed_width() -> Option<usize> {
        Some(32)
    }

    fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
    where
        Self: 'a,
    {
        let bytes = <[u8; 32] as redb::Value>::from_bytes(data);
        BlockHash::new(bytes)
    }

    fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
    where
        Self: 'a,
        Self: 'b,
    {
        value.as_bytes()
    }

    fn type_name() -> redb::TypeName {
        redb::TypeName::new("Round")
    }
}

impl redb::Key for BlockHashKey {
    fn compare(data1: &[u8], data2: &[u8]) -> std::cmp::Ordering {
        <[u8; 32] as redb::Key>::compare(data1, data2)
    }
}

```
---
### `starknet/host/src/block_store.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
use std::ops::RangeBounds;
use std::path::Path;
use std::sync::Arc;

use bytes::Bytes;
use prost::Message;
use redb::ReadableTable;
use thiserror::Error;
use tracing::error;

use malachitebft_codec::Codec;
use malachitebft_core_consensus::ProposedValue;
use malachitebft_core_types::{CommitCertificate, Round};
use malachitebft_proto::Protobuf;

use crate::codec::{self, ProtobufCodec};
use crate::proto::{self as proto, Error as ProtoError};
use crate::types::MockContext;
use crate::types::{Block, BlockHash, Height, Transaction, TransactionBatch};

mod keys;
use keys::{HeightKey, UndecidedValueKey};

#[derive(Clone, Debug)]
pub struct DecidedBlock {
    pub block: Block,
    pub certificate: CommitCertificate<MockContext>,
}

fn decode_certificate(bytes: &[u8]) -> Result<CommitCertificate<MockContext>, ProtoError> {
    let proto = proto::sync::CommitCertificate::decode(bytes)?;
    codec::decode_commit_certificate(proto)
}

fn encode_certificate(certificate: &CommitCertificate<MockContext>) -> Result<Vec<u8>, ProtoError> {
    let proto = codec::encode_commit_certificate(certificate)?;
    Ok(proto.encode_to_vec())
}

#[derive(Debug, Error)]
pub enum StoreError {
    #[error("Database error: {0}")]
    Database(#[from] redb::DatabaseError),

    #[error("Storage error: {0}")]
    Storage(#[from] redb::StorageError),

    #[error("Table error: {0}")]
    Table(#[from] redb::TableError),

    #[error("Commit error: {0}")]
    Commit(#[from] redb::CommitError),

    #[error("Transaction error: {0}")]
    Transaction(#[from] redb::TransactionError),

    #[error("Failed to encode/decode Protobuf: {0}")]
    Protobuf(#[from] ProtoError),

    #[error("Failed to join on task: {0}")]
    TaskJoin(#[from] tokio::task::JoinError),
}

const CERTIFICATES_TABLE: redb::TableDefinition<HeightKey, Vec<u8>> =
    redb::TableDefinition::new("certificates");

const DECIDED_BLOCKS_TABLE: redb::TableDefinition<HeightKey, Vec<u8>> =
    redb::TableDefinition::new("decided_blocks");

const UNDECIDED_VALUES_TABLE: redb::TableDefinition<UndecidedValueKey, Vec<u8>> =
    redb::TableDefinition::new("undecided_blocks");

struct Db {
    db: redb::Database,
}

impl Db {
    fn new(path: impl AsRef<Path>) -> Result<Self, StoreError> {
        Ok(Self {
            db: redb::Database::create(path).map_err(StoreError::Database)?,
        })
    }

    fn get_decided_block(&self, height: Height) -> Result<Option<DecidedBlock>, StoreError> {
        let tx = self.db.begin_read()?;
        let block = {
            let table = tx.open_table(DECIDED_BLOCKS_TABLE)?;
            let value = table.get(&height)?;
            value.and_then(|value| Block::from_bytes(&value.value()).ok())
        };
        let certificate = {
            let table = tx.open_table(CERTIFICATES_TABLE)?;
            let value = table.get(&height)?;
            value.and_then(|value| decode_certificate(&value.value()).ok())
        };

        let decided_block = block
            .zip(certificate)
            .map(|(block, certificate)| DecidedBlock { block, certificate });

        Ok(decided_block)
    }

    fn insert_decided_block(&self, decided_block: DecidedBlock) -> Result<(), StoreError> {
        let height = decided_block.block.height;

        let tx = self.db.begin_write()?;
        {
            let mut blocks = tx.open_table(DECIDED_BLOCKS_TABLE)?;
            blocks.insert(height, decided_block.block.to_bytes()?.to_vec())?;
        }
        {
            let mut certificates = tx.open_table(CERTIFICATES_TABLE)?;
            certificates.insert(height, encode_certificate(&decided_block.certificate)?)?;
        }
        tx.commit()?;

        Ok(())
    }

    #[tracing::instrument(skip(self))]
    pub fn get_undecided_values(
        &self,
        height: Height,
        round: Round,
    ) -> Result<Vec<ProposedValue<MockContext>>, StoreError> {
        let tx = self.db.begin_read()?;
        let mut values = Vec::new();

        let from = (height, round, BlockHash::new([0; 32]));
        let to = (height, round, BlockHash::new([255; 32]));

        let table = tx.open_table(UNDECIDED_VALUES_TABLE)?;
        let keys = self.undecided_values_range(&table, from..to)?;

        for key in keys {
            if let Ok(Some(value)) = table.get(&key) {
                let Ok(value) = ProtobufCodec.decode(Bytes::from(value.value())) else {
                    error!(hash = %key.2, "Failed to decode ProposedValue");
                    continue;
                };

                values.push(value);
            }
        }

        Ok(values)
    }

    fn insert_undecided_value(&self, value: ProposedValue<MockContext>) -> Result<(), StoreError> {
        let key = (value.height, value.round, value.value);
        let value = ProtobufCodec.encode(&value)?;
        let tx = self.db.begin_write()?;
        {
            let mut table = tx.open_table(UNDECIDED_VALUES_TABLE)?;
            table.insert(key, value.to_vec())?;
        }
        tx.commit()?;
        Ok(())
    }

    fn height_range<Table>(
        &self,
        table: &Table,
        range: impl RangeBounds<Height>,
    ) -> Result<Vec<Height>, StoreError>
    where
        Table: redb::ReadableTable<HeightKey, Vec<u8>>,
    {
        Ok(table
            .range(range)?
            .flatten()
            .map(|(key, _)| key.value())
            .collect::<Vec<_>>())
    }

    fn undecided_values_range<Table>(
        &self,
        table: &Table,
        range: impl RangeBounds<(Height, Round, BlockHash)>,
    ) -> Result<Vec<(Height, Round, BlockHash)>, StoreError>
    where
        Table: redb::ReadableTable<UndecidedValueKey, Vec<u8>>,
    {
        Ok(table
            .range(range)?
            .flatten()
            .map(|(key, _)| key.value())
            .collect::<Vec<_>>())
    }

    fn prune(&self, retain_height: Height) -> Result<Vec<Height>, StoreError> {
        let tx = self.db.begin_write().unwrap();
        let pruned = {
            let mut undecided = tx.open_table(UNDECIDED_VALUES_TABLE)?;
            let keys = self.undecided_values_range(
                &undecided,
                ..(retain_height, Round::Nil, BlockHash::new([0; 32])),
            )?;
            for key in keys {
                undecided.remove(key)?;
            }

            let mut decided = tx.open_table(DECIDED_BLOCKS_TABLE)?;
            let mut certificates = tx.open_table(CERTIFICATES_TABLE)?;

            let keys = self.height_range(&decided, ..retain_height)?;
            for key in &keys {
                decided.remove(key)?;
                certificates.remove(key)?;
            }
            keys
        };
        tx.commit()?;

        Ok(pruned)
    }

    fn first_key(&self) -> Option<Height> {
        let tx = self.db.begin_read().unwrap();
        let table = tx.open_table(DECIDED_BLOCKS_TABLE).unwrap();
        let (key, _) = table.first().ok()??;
        Some(key.value())
    }

    fn last_key(&self) -> Option<Height> {
        let tx = self.db.begin_read().unwrap();
        let table = tx.open_table(DECIDED_BLOCKS_TABLE).unwrap();
        let (key, _) = table.last().ok()??;
        Some(key.value())
    }

    fn create_tables(&self) -> Result<(), StoreError> {
        let tx = self.db.begin_write()?;
        // Implicitly creates the tables if they do not exist yet
        let _ = tx.open_table(DECIDED_BLOCKS_TABLE)?;
        let _ = tx.open_table(CERTIFICATES_TABLE)?;
        let _ = tx.open_table(UNDECIDED_VALUES_TABLE)?;
        tx.commit()?;
        Ok(())
    }
}

#[derive(Clone)]
pub struct BlockStore {
    db: Arc<Db>,
}

impl BlockStore {
    pub async fn new(path: impl AsRef<Path>) -> Result<Self, StoreError> {
        let path = path.as_ref().to_owned();
        tokio::task::spawn_blocking(move || {
            let db = Db::new(path)?;
            db.create_tables()?;

            Ok(Self { db: Arc::new(db) })
        })
        .await?
    }

    pub async fn first_height(&self) -> Option<Height> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.first_key())
            .await
            .ok()
            .flatten()
    }

    pub async fn last_height(&self) -> Option<Height> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.last_key())
            .await
            .ok()
            .flatten()
    }

    pub async fn get(&self, height: Height) -> Result<Option<DecidedBlock>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.get_decided_block(height)).await?
    }

    pub async fn store_decided_block(
        &self,
        certificate: &CommitCertificate<MockContext>,
        txes: &[Transaction],
    ) -> Result<(), StoreError> {
        let decided_block = DecidedBlock {
            block: Block {
                height: certificate.height,
                block_hash: certificate.value_id,
                transactions: TransactionBatch::new(txes.to_vec()),
            },
            certificate: certificate.clone(),
        };

        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.insert_decided_block(decided_block)).await?
    }

    pub async fn store_undecided_value(
        &self,
        value: ProposedValue<MockContext>,
    ) -> Result<(), StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.insert_undecided_value(value)).await?
    }

    pub async fn get_undecided_values(
        &self,
        height: Height,
        round: Round,
    ) -> Result<Vec<ProposedValue<MockContext>>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.get_undecided_values(height, round)).await?
    }

    pub async fn prune(&self, retain_height: Height) -> Result<Vec<Height>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.prune(retain_height)).await?
    }
}

```
---
### `starknet/host/src/codec.rs`
*2025-05-18 23:58:49 | 24 KB*
```rust
use bytes::Bytes;
use prost::Message;

use malachitebft_codec::Codec;
use malachitebft_core_consensus::{LivenessMsg, PeerId, ProposedValue, SignedConsensusMsg};
use malachitebft_core_types::{
    CommitCertificate, CommitSignature, NilOrVal, PolkaCertificate, PolkaSignature, Round,
    RoundCertificate, RoundSignature, SignedVote, Validity, VoteType,
};
use malachitebft_engine::util::streaming::{StreamContent, StreamId, StreamMessage};
use malachitebft_starknet_p2p_types::{Felt, FeltExt, Signature};
use malachitebft_sync::{self as sync, ValueRequest, ValueResponse};

use crate::proto::{self as proto, Error as ProtoError, Protobuf};
use crate::types::{self as p2p, Address, BlockHash, Height, MockContext, ProposalPart, Vote};

trait MessageExt {
    fn encode_to_bytes(&self) -> Bytes;
}

impl<T> MessageExt for T
where
    T: Message,
{
    fn encode_to_bytes(&self) -> Bytes {
        Bytes::from(self.encode_to_vec())
    }
}

pub struct ProtobufCodec;

impl Codec<Address> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<Address, Self::Error> {
        Protobuf::from_bytes(&bytes)
    }

    fn encode(&self, address: &Address) -> Result<Bytes, Self::Error> {
        Protobuf::to_bytes(address)
    }
}

impl Codec<BlockHash> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<BlockHash, Self::Error> {
        Protobuf::from_bytes(&bytes)
    }

    fn encode(&self, block_hash: &BlockHash) -> Result<Bytes, Self::Error> {
        Protobuf::to_bytes(block_hash)
    }
}

impl Codec<ProposalPart> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<ProposalPart, Self::Error> {
        Protobuf::from_bytes(bytes.as_ref())
    }

    fn encode(&self, msg: &ProposalPart) -> Result<Bytes, Self::Error> {
        Protobuf::to_bytes(msg)
    }
}

pub fn decode_proposed_value(
    proto: proto::sync::ProposedValue,
) -> Result<ProposedValue<MockContext>, ProtoError> {
    let proposer = proto
        .proposer
        .ok_or_else(|| ProtoError::missing_field::<proto::sync::ProposedValue>("proposer"))?;

    Ok(ProposedValue {
        height: Height::new(proto.block_number, proto.fork_id),
        round: Round::from(proto.round),
        value: BlockHash::from_bytes(&proto.value)?,
        valid_round: Round::from(proto.valid_round),
        proposer: Address::from_proto(proposer)?,
        validity: Validity::from_bool(proto.validity),
    })
}

pub fn encode_proposed_value(
    msg: &ProposedValue<MockContext>,
) -> Result<proto::sync::ProposedValue, ProtoError> {
    let proto = proto::sync::ProposedValue {
        fork_id: msg.height.fork_id,
        block_number: msg.height.block_number,
        round: msg.round.as_u32().expect("round should not be nil"),
        valid_round: msg.valid_round.as_u32(),
        value: msg.value.to_bytes()?,
        proposer: Some(msg.proposer.to_proto()?),
        validity: msg.validity.to_bool(),
    };

    Ok(proto)
}

impl Codec<ProposedValue<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<ProposedValue<MockContext>, Self::Error> {
        decode_proposed_value(proto::sync::ProposedValue::decode(bytes)?)
    }

    fn encode(&self, msg: &ProposedValue<MockContext>) -> Result<Bytes, Self::Error> {
        encode_proposed_value(msg).map(|proto| proto.encode_to_bytes())
    }
}

pub fn decode_peer_id(proto: proto::PeerId) -> Result<PeerId, ProtoError> {
    PeerId::from_bytes(&proto.id).map_err(|e| ProtoError::Other(e.to_string()))
}

pub fn encode_peer_id(peer_id: &PeerId) -> Result<proto::PeerId, ProtoError> {
    Ok(proto::PeerId {
        id: Bytes::from(peer_id.to_bytes()),
    })
}

impl Codec<PeerId> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<PeerId, Self::Error> {
        decode_peer_id(proto::PeerId::decode(bytes)?)
    }

    fn encode(&self, peer_id: &PeerId) -> Result<Bytes, Self::Error> {
        encode_peer_id(peer_id).map(|proto| proto.encode_to_bytes())
    }
}

pub fn decode_sync_status(
    status: proto::sync::Status,
) -> Result<sync::Status<MockContext>, ProtoError> {
    let peer_id = status
        .peer_id
        .ok_or_else(|| ProtoError::missing_field::<proto::sync::Status>("peer_id"))?;

    Ok(sync::Status {
        peer_id: decode_peer_id(peer_id)?,
        tip_height: Height::new(status.block_number, status.fork_id),
        history_min_height: Height::new(status.earliest_block_number, status.earliest_fork_id),
    })
}

pub fn encode_sync_status(
    status: &sync::Status<MockContext>,
) -> Result<proto::sync::Status, ProtoError> {
    Ok(proto::sync::Status {
        peer_id: Some(encode_peer_id(&status.peer_id)?),
        block_number: status.tip_height.block_number,
        fork_id: status.tip_height.fork_id,
        earliest_block_number: status.history_min_height.block_number,
        earliest_fork_id: status.history_min_height.fork_id,
    })
}

impl Codec<sync::Status<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::Status<MockContext>, Self::Error> {
        decode_sync_status(proto::sync::Status::decode(bytes)?)
    }

    fn encode(&self, status: &sync::Status<MockContext>) -> Result<Bytes, Self::Error> {
        encode_sync_status(status).map(|proto| proto.encode_to_bytes())
    }
}

pub fn decode_sync_request(
    proto_request: proto::sync::SyncRequest,
) -> Result<sync::Request<MockContext>, ProtoError> {
    let messages = proto_request
        .messages
        .ok_or_else(|| ProtoError::missing_field::<proto::sync::SyncRequest>("messages"))?;
    let request = match messages {
        proto::sync::sync_request::Messages::ValueRequest(value_request) => {
            sync::Request::ValueRequest(ValueRequest::new(Height::new(
                value_request.block_number,
                value_request.fork_id,
            )))
        }
    };

    Ok(request)
}

pub fn encode_sync_request(
    request: &sync::Request<MockContext>,
) -> Result<proto::sync::SyncRequest, ProtoError> {
    let proto = match request {
        sync::Request::ValueRequest(value_request) => proto::sync::SyncRequest {
            messages: Some(proto::sync::sync_request::Messages::ValueRequest(
                proto::sync::ValueRequest {
                    fork_id: value_request.height.fork_id,
                    block_number: value_request.height.block_number,
                },
            )),
        },
    };

    Ok(proto)
}

impl Codec<sync::Request<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::Request<MockContext>, Self::Error> {
        decode_sync_request(proto::sync::SyncRequest::decode(bytes)?)
    }

    fn encode(&self, request: &sync::Request<MockContext>) -> Result<Bytes, Self::Error> {
        encode_sync_request(request).map(|proto| proto.encode_to_bytes())
    }
}

pub fn decode_sync_response(
    proto_response: proto::sync::SyncResponse,
) -> Result<sync::Response<MockContext>, ProtoError> {
    let messages = proto_response
        .messages
        .ok_or_else(|| ProtoError::missing_field::<proto::sync::SyncResponse>("messages"))?;

    let response = match messages {
        proto::sync::sync_response::Messages::ValueResponse(value_response) => {
            sync::Response::ValueResponse(ValueResponse::new(
                Height::new(value_response.block_number, value_response.fork_id),
                value_response.value.map(decode_synced_value).transpose()?,
            ))
        }
    };

    Ok(response)
}

pub fn encode_sync_response(
    response: &sync::Response<MockContext>,
) -> Result<proto::sync::SyncResponse, ProtoError> {
    let proto = match response {
        sync::Response::ValueResponse(value_response) => proto::sync::SyncResponse {
            messages: Some(proto::sync::sync_response::Messages::ValueResponse(
                proto::sync::ValueResponse {
                    fork_id: value_response.height.fork_id,
                    block_number: value_response.height.block_number,
                    value: value_response
                        .value
                        .as_ref()
                        .map(encode_synced_value)
                        .transpose()?,
                },
            )),
        },
    };

    Ok(proto)
}

impl Codec<sync::Response<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::Response<MockContext>, Self::Error> {
        decode_sync_response(proto::sync::SyncResponse::decode(bytes)?)
    }

    fn encode(&self, response: &sync::Response<MockContext>) -> Result<Bytes, Self::Error> {
        encode_sync_response(response).map(|proto| proto.encode_to_bytes())
    }
}

pub fn decode_consensus_message(
    proto: proto::Vote,
) -> Result<SignedConsensusMsg<MockContext>, ProtoError> {
    let vote = Vote::from_proto(proto)?;
    let signature = p2p::Signature::test();

    Ok(SignedConsensusMsg::Vote(SignedVote::new(vote, signature)))
}

pub fn encode_consensus_message(
    msg: &SignedConsensusMsg<MockContext>,
) -> Result<proto::Vote, ProtoError> {
    let message = match msg {
        SignedConsensusMsg::Vote(v) => v.to_proto()?,
        SignedConsensusMsg::Proposal(_) => {
            panic!("explicit proposal not supported by starknet test application")
        } // SignedConsensusMsg::Proposal(p) => proto::ConsensusMessage {
          //     messages: Some(Messages::Proposal(p.to_proto()?)),
          //     signature: Some(p.signature.to_proto()?),
          // },
    };

    Ok(message)
}

impl Codec<SignedConsensusMsg<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<SignedConsensusMsg<MockContext>, Self::Error> {
        decode_consensus_message(proto::Vote::decode(bytes)?)
    }

    fn encode(&self, msg: &SignedConsensusMsg<MockContext>) -> Result<Bytes, Self::Error> {
        encode_consensus_message(msg).map(|proto| proto.encode_to_bytes())
    }
}

pub(crate) fn encode_round_certificate(
    certificate: &RoundCertificate<MockContext>,
) -> Result<proto::RoundCertificate, ProtoError> {
    Ok(proto::RoundCertificate {
        fork_id: certificate.height.fork_id,
        block_number: certificate.height.block_number,
        round: certificate.round.as_u32().expect("round should not be nil"),
        signatures: certificate
            .round_signatures
            .iter()
            .map(|sig| -> Result<proto::RoundSignature, ProtoError> {
                let address = sig.address.to_proto()?;
                let signature = encode_signature(&sig.signature)?;
                let block_hash = match sig.value_id {
                    NilOrVal::Nil => None,
                    NilOrVal::Val(value_id) => Some(value_id.to_proto()?),
                };
                Ok(proto::RoundSignature {
                    vote_type: match sig.vote_type {
                        VoteType::Prevote => proto::VoteType::Prevote as i32,
                        VoteType::Precommit => proto::VoteType::Precommit as i32,
                    },
                    validator_address: Some(address),
                    signature: Some(signature),
                    block_hash,
                })
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

pub(crate) fn decode_round_certificate(
    certificate: proto::RoundCertificate,
) -> Result<RoundCertificate<MockContext>, ProtoError> {
    Ok(RoundCertificate {
        height: Height::new(certificate.block_number, certificate.fork_id),
        round: Round::new(certificate.round),
        round_signatures: certificate
            .signatures
            .into_iter()
            .map(|sig| -> Result<RoundSignature<MockContext>, ProtoError> {
                let address = sig.validator_address.ok_or_else(|| {
                    ProtoError::missing_field::<proto::RoundCertificate>("validator_address")
                })?;
                let signature = sig.signature.ok_or_else(|| {
                    ProtoError::missing_field::<proto::RoundCertificate>("signature")
                })?;
                let signature = decode_signature(signature)?;
                let address = Address::from_proto(address)?;
                let value_id = match sig.block_hash {
                    None => NilOrVal::Nil,
                    Some(block_hash) => NilOrVal::Val(BlockHash::from_proto(block_hash)?),
                };
                let vote_type = match sig.vote_type {
                    0 => VoteType::Prevote,
                    1 => VoteType::Precommit,
                    _ => return Err(ProtoError::Other("Invalid vote type".to_string())),
                };
                Ok(RoundSignature::new(vote_type, value_id, address, signature))
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

impl Codec<LivenessMsg<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<LivenessMsg<MockContext>, Self::Error> {
        let msg = proto::LivenessMessage::decode(bytes.as_ref())?;
        match msg.message {
            Some(proto::liveness_message::Message::Vote(vote)) => {
                Ok(LivenessMsg::Vote(decode_vote(vote)?))
            }
            Some(proto::liveness_message::Message::PolkaCertificate(cert)) => Ok(
                LivenessMsg::PolkaCertificate(decode_polka_certificate(cert)?),
            ),
            Some(proto::liveness_message::Message::RoundCertificate(cert)) => Ok(
                LivenessMsg::SkipRoundCertificate(decode_round_certificate(cert)?),
            ),
            None => Err(ProtoError::missing_field::<proto::LivenessMessage>(
                "message",
            )),
        }
    }

    fn encode(&self, msg: &LivenessMsg<MockContext>) -> Result<Bytes, Self::Error> {
        match msg {
            LivenessMsg::Vote(vote) => {
                let message = encode_vote(vote)?;
                Ok(Bytes::from(
                    proto::LivenessMessage {
                        message: Some(proto::liveness_message::Message::Vote(message)),
                    }
                    .encode_to_vec(),
                ))
            }
            LivenessMsg::PolkaCertificate(cert) => {
                let message = encode_polka_certificate(cert)?;
                Ok(Bytes::from(
                    proto::LivenessMessage {
                        message: Some(proto::liveness_message::Message::PolkaCertificate(message)),
                    }
                    .encode_to_vec(),
                ))
            }
            LivenessMsg::SkipRoundCertificate(cert) => {
                let message = encode_round_certificate(cert)?;
                Ok(Bytes::from(
                    proto::LivenessMessage {
                        message: Some(proto::liveness_message::Message::RoundCertificate(message)),
                    }
                    .encode_to_vec(),
                ))
            }
        }
    }
}

impl<T> Codec<StreamMessage<T>> for ProtobufCodec
where
    T: Protobuf,
{
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<StreamMessage<T>, Self::Error> {
        let p2p_msg = p2p::StreamMessage::from_bytes(&bytes)?;

        Ok(StreamMessage {
            stream_id: StreamId::new(p2p_msg.id),
            sequence: p2p_msg.sequence,
            content: match p2p_msg.content {
                p2p::StreamContent::Data(data) => {
                    StreamContent::Data(T::from_bytes(data.as_ref())?)
                }
                p2p::StreamContent::Fin => StreamContent::Fin,
            },
        })
    }

    fn encode(&self, msg: &StreamMessage<T>) -> Result<Bytes, Self::Error> {
        let p2p_msg = p2p::StreamMessage {
            id: msg.stream_id.to_bytes(),
            sequence: msg.sequence,
            content: match &msg.content {
                StreamContent::Data(data) => p2p::StreamContent::Data(data.to_bytes()?),
                StreamContent::Fin => p2p::StreamContent::Fin,
            },
        };

        p2p_msg.to_bytes()
    }
}

pub fn encode_signature(_signature: &Signature) -> Result<proto::ConsensusSignature, ProtoError> {
    Ok(proto::ConsensusSignature {
        r: Some(Felt::ONE.to_proto()?),
        s: Some(Felt::ONE.to_proto()?),
    })
}

pub fn decode_signature(_signature: proto::ConsensusSignature) -> Result<Signature, ProtoError> {
    Ok(Signature::test())
}

pub fn decode_commit_certificate(
    certificate: proto::sync::CommitCertificate,
) -> Result<CommitCertificate<MockContext>, ProtoError> {
    let value_id = if let Some(block_hash) = certificate.block_hash {
        BlockHash::from_proto(block_hash)?
    } else {
        return Err(ProtoError::missing_field::<proto::sync::CommitCertificate>(
            "block_hash",
        ));
    };

    let commit_signatures = certificate
        .signatures
        .into_iter()
        .map(|sig| -> Result<CommitSignature<MockContext>, ProtoError> {
            let address = sig.validator_address.ok_or_else(|| {
                ProtoError::missing_field::<proto::sync::CommitCertificate>("validator_address")
            })?;
            let signature = sig.signature.ok_or_else(|| {
                ProtoError::missing_field::<proto::sync::CommitCertificate>("signature")
            })?;
            let signature = decode_signature(signature)?;
            let address = Address::from_proto(address)?;
            Ok(CommitSignature::new(address, signature))
        })
        .collect::<Result<Vec<_>, _>>()?;

    let certificate = CommitCertificate {
        height: Height::new(certificate.block_number, certificate.fork_id),
        round: Round::new(certificate.round),
        value_id,
        commit_signatures,
    };

    Ok(certificate)
}

pub fn encode_commit_certificate(
    certificate: &CommitCertificate<MockContext>,
) -> Result<proto::sync::CommitCertificate, ProtoError> {
    Ok(proto::sync::CommitCertificate {
        fork_id: certificate.height.fork_id,
        block_number: certificate.height.block_number,
        round: certificate.round.as_u32().expect("round should not be nil"),
        block_hash: Some(certificate.value_id.to_proto()?),
        signatures: certificate
            .commit_signatures
            .iter()
            .map(|sig| -> Result<proto::sync::CommitSignature, ProtoError> {
                let address = sig.address.to_proto()?;
                let signature = encode_signature(&sig.signature)?;
                Ok(proto::sync::CommitSignature {
                    validator_address: Some(address),
                    signature: Some(signature),
                })
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

impl Codec<CommitCertificate<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<CommitCertificate<MockContext>, Self::Error> {
        decode_commit_certificate(
            proto::sync::CommitCertificate::decode(bytes).map_err(ProtoError::Decode)?,
        )
    }

    fn encode(&self, msg: &CommitCertificate<MockContext>) -> Result<Bytes, Self::Error> {
        encode_commit_certificate(msg).map(|proto| proto.encode_to_bytes())
    }
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub(crate) fn encode_polka_certificate(
    certificate: &PolkaCertificate<MockContext>,
) -> Result<proto::PolkaCertificate, ProtoError> {
    Ok(proto::PolkaCertificate {
        fork_id: certificate.height.fork_id,
        block_number: certificate.height.block_number,
        block_hash: Some(certificate.value_id.to_proto()?),
        round: certificate.round.as_u32().unwrap(),
        signatures: certificate
            .polka_signatures
            .iter()
            .map(|sig| -> Result<proto::PolkaSignature, ProtoError> {
                let address = sig.address.to_proto()?;
                let signature = encode_signature(&sig.signature)?;
                Ok(proto::PolkaSignature {
                    validator_address: Some(address),
                    signature: Some(signature),
                })
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub(crate) fn decode_polka_certificate(
    certificate: proto::PolkaCertificate,
) -> Result<PolkaCertificate<MockContext>, ProtoError> {
    let block_hash = certificate
        .block_hash
        .ok_or_else(|| ProtoError::missing_field::<proto::PolkaCertificate>("block_hash"))?;

    Ok(PolkaCertificate {
        height: Height::new(certificate.block_number, certificate.fork_id),
        round: Round::new(certificate.round),
        value_id: BlockHash::from_proto(block_hash)?,
        polka_signatures: certificate
            .signatures
            .into_iter()
            .map(|sig| -> Result<PolkaSignature<MockContext>, ProtoError> {
                let address = sig.validator_address.ok_or_else(|| {
                    ProtoError::missing_field::<proto::PolkaCertificate>("validator_address")
                })?;
                let signature = sig.signature.ok_or_else(|| {
                    ProtoError::missing_field::<proto::PolkaCertificate>("signature")
                })?;
                let signature = decode_signature(signature)?;
                let address = Address::from_proto(address)?;
                Ok(PolkaSignature::new(address, signature))
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

impl Codec<PolkaCertificate<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<PolkaCertificate<MockContext>, Self::Error> {
        decode_polka_certificate(proto::PolkaCertificate::decode(bytes)?)
    }

    fn encode(&self, msg: &PolkaCertificate<MockContext>) -> Result<Bytes, Self::Error> {
        encode_polka_certificate(msg).map(|proto| proto.encode_to_bytes())
    }
}

pub fn encode_synced_value(
    synced_value: &sync::RawDecidedValue<MockContext>,
) -> Result<proto::sync::SyncedValue, ProtoError> {
    Ok(proto::sync::SyncedValue {
        value_bytes: synced_value.value_bytes.clone(),
        certificate: Some(encode_commit_certificate(&synced_value.certificate)?),
    })
}

pub fn decode_synced_value(
    proto: proto::sync::SyncedValue,
) -> Result<sync::RawDecidedValue<MockContext>, ProtoError> {
    let Some(certificate) = proto.certificate else {
        return Err(ProtoError::missing_field::<proto::sync::SyncedValue>(
            "certificate",
        ));
    };

    Ok(sync::RawDecidedValue {
        value_bytes: proto.value_bytes,
        certificate: decode_commit_certificate(certificate)?,
    })
}

impl Codec<sync::RawDecidedValue<MockContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::RawDecidedValue<MockContext>, Self::Error> {
        let proto = proto::sync::SyncedValue::decode(bytes).map_err(ProtoError::Decode)?;
        decode_synced_value(proto)
    }

    fn encode(&self, msg: &sync::RawDecidedValue<MockContext>) -> Result<Bytes, Self::Error> {
        Ok(Bytes::from(encode_synced_value(msg)?.encode_to_vec()))
    }
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub(crate) fn encode_vote(vote: &SignedVote<MockContext>) -> Result<proto::Vote, ProtoError> {
    vote.message.to_proto()
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub(crate) fn decode_vote(msg: proto::Vote) -> Result<SignedVote<MockContext>, ProtoError> {
    let signature = Signature::test();
    let vote = Vote::from_proto(msg)?;
    Ok(SignedVote::new(vote, signature))
}

```
---
### `starknet/host/src/config.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::path::Path;

use serde::{Deserialize, Serialize};

use malachitebft_app::node::NodeConfig;

pub use malachitebft_app::config::{
    ConsensusConfig, LogFormat, LogLevel, LoggingConfig, MempoolConfig, MetricsConfig,
    RuntimeConfig, TestConfig, TimeoutConfig, ValueSyncConfig,
};

/// Malachite configuration options
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct Config {
    /// A custom human-readable name for this node
    pub moniker: String,

    /// Log configuration options
    pub logging: LoggingConfig,

    /// Consensus configuration options
    pub consensus: ConsensusConfig,

    /// Mempool configuration options
    pub mempool: MempoolConfig,

    /// Sync configuration options
    pub value_sync: ValueSyncConfig,

    /// Metrics configuration options
    pub metrics: MetricsConfig,

    /// Runtime configuration options
    pub runtime: RuntimeConfig,

    /// Test configuration
    #[serde(default)]
    pub test: TestConfig,
}

impl NodeConfig for Config {
    fn moniker(&self) -> &str {
        &self.moniker
    }

    fn consensus(&self) -> &ConsensusConfig {
        &self.consensus
    }

    fn value_sync(&self) -> &ValueSyncConfig {
        &self.value_sync
    }
}

/// load_config parses the environment variables and loads the provided config file path
/// to create a Config struct.
pub fn load_config(path: impl AsRef<Path>, prefix: Option<&str>) -> eyre::Result<Config> {
    ::config::Config::builder()
        .add_source(::config::File::from(path.as_ref()))
        .add_source(
            ::config::Environment::with_prefix(prefix.unwrap_or("MALACHITE")).separator("__"),
        )
        .build()?
        .try_deserialize()
        .map_err(Into::into)
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//
//     #[test]
//     fn parse_default_config_file() {
//         let file = include_str!("../config.toml");
//         let config = toml::from_str::<Config>(file).unwrap();
//         assert_eq!(config.consensus.timeouts, TimeoutConfig::default());
//
//         let tmp_file = std::env::temp_dir().join("config-test.toml");
//         std::fs::write(&tmp_file, file).unwrap();
//
//         let config = load_config(&tmp_file, None).unwrap();
//         assert_eq!(config.consensus.timeouts, TimeoutConfig::default());
//
//         std::fs::remove_file(tmp_file).unwrap();
//     }
// }

```
---
### `starknet/host/src/host/proposal.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
#![allow(clippy::too_many_arguments)]
use sha3::Digest;
use std::sync::Arc;
use std::time::SystemTime;

use bytesize::ByteSize;
use eyre::eyre;
use tokio::sync::{mpsc, oneshot};
use tokio::time::Instant;
use tracing::{debug, error, trace};

use malachitebft_core_types::Round;

use crate::host::starknet::StarknetParams;
use crate::mempool::{MempoolMsg, MempoolRef};
use crate::types::*;

const PROTOCOL_VERSION: &str = "0.13.0";

pub async fn build_proposal_task(
    height: Height,
    round: Round,
    proposer: Address,
    private_key: PrivateKey,
    params: StarknetParams,
    deadline: Instant,
    mempool: MempoolRef,
    tx_part: mpsc::Sender<ProposalPart>,
    tx_block_hash: oneshot::Sender<BlockHash>,
) {
    if let Err(e) = run_build_proposal_task(
        height,
        round,
        proposer,
        private_key,
        params,
        deadline,
        mempool,
        tx_part,
        tx_block_hash,
    )
    .await
    {
        error!("Failed to build proposal: {e:?}");
    }
}

async fn run_build_proposal_task(
    height: Height,
    round: Round,
    proposer: Address,
    _private_key: PrivateKey,
    params: StarknetParams,
    deadline: Instant,
    mempool: MempoolRef,
    tx_part: mpsc::Sender<ProposalPart>,
    tx_value_id: oneshot::Sender<Hash>,
) -> Result<(), Box<dyn core::error::Error>> {
    let start = Instant::now();
    let build_duration = (deadline - start).mul_f32(params.time_allowance_factor);
    let build_deadline = start + build_duration;

    let mut sequence = 0;
    let mut block_tx_count = 0;
    let mut block_size = 0;

    trace!(%height, %round, "Building local value");

    // Init
    {
        let part = ProposalPart::Init(ProposalInit {
            height,
            round,
            proposer,
            valid_round: Round::Nil,
        });

        tx_part.send(part).await?;
        sequence += 1;
    }

    let now = SystemTime::UNIX_EPOCH.elapsed().unwrap().as_secs();

    // Block Info
    {
        let part = ProposalPart::BlockInfo(BlockInfo {
            height,
            builder: proposer,
            timestamp: now,
            l1_gas_price_wei: 0,
            l1_data_gas_price_wei: 0,
            l2_gas_price_fri: 0,
            eth_to_strk_rate: 0,
            l1_da_mode: L1DataAvailabilityMode::Blob,
        });

        tx_part.send(part).await?;
        sequence += 1;
    }

    let max_block_size = params.max_block_size.as_u64() as usize;
    let mut hasher = sha3::Keccak256::new();

    'reap: loop {
        let reaped_txes = mempool
            .call(
                |reply| MempoolMsg::Reap {
                    height: height.as_u64(),
                    num_txes: params.txs_per_part,
                    reply,
                },
                Some(build_duration),
            )
            .await?
            .success_or(eyre!("Failed to reap transactions from the mempool"))?;

        debug!("Reaped {} transactions from the mempool", reaped_txes.len());

        if reaped_txes.is_empty() {
            debug!("No more transactions to reap");
            break 'reap;
        }

        let mut txes = Vec::new();
        let mut full_block = false;

        'txes: for tx in reaped_txes {
            if block_size + tx.size_bytes() > max_block_size {
                full_block = true;
                break 'txes;
            }

            block_size += tx.size_bytes();
            block_tx_count += 1;

            txes.push(tx.clone());
            hasher.update(tx.clone().hash().as_bytes());
        }

        let exec_time = params.exec_time_per_tx * txes.len() as u32;
        tokio::time::sleep(exec_time).await;

        trace!(
            %sequence,
            "Created a tx batch with {} tx-es of size {} in {:?}",
            txes.len(),
            ByteSize::b(block_size as u64),
            start.elapsed()
        );

        // Transactions
        {
            let part = ProposalPart::Transactions(TransactionBatch::new(txes));
            tx_part.send(part).await?;
            sequence += 1;
        }

        if full_block {
            debug!("Max block size reached, stopping tx generation");
            break 'reap;
        } else if start.elapsed() >= build_duration {
            debug!("Time allowance exceeded, stopping tx generation");
            break 'reap;
        }
    }

    if params.stable_block_times {
        // Sleep for the remaining time, in order to not break tests
        // by producing blocks too quickly
        tokio::time::sleep(build_deadline - Instant::now()).await;
    }

    let transaction_commitment = Hash::new(hasher.finalize().into());

    // Proposal Commitment
    {
        let part = ProposalPart::Commitment(Box::new(ProposalCommitment {
            height,
            parent_commitment: Hash::new([0; 32]),
            builder: proposer,
            timestamp: now,
            protocol_version: PROTOCOL_VERSION.to_string(),
            old_state_root: Hash::new([0; 32]),
            state_diff_commitment: Hash::new([0; 32]),
            transaction_commitment,
            event_commitment: Hash::new([0; 32]),
            receipt_commitment: Hash::new([0; 32]),
            concatenated_counts: Felt::ONE,
            l1_gas_price_fri: 0,
            l1_data_gas_price_fri: 0,
            l2_gas_price_fri: 0,
            l2_gas_used: 0,
            l1_da_mode: L1DataAvailabilityMode::Blob,
        }));

        tx_part.send(part).await?;
        sequence += 1;
    }

    // Fin
    {
        let part = ProposalPart::Fin(ProposalFin {
            // TODO: Compute the actual propoosal commitment hash, for now
            // we use the transaction commitment
            proposal_commitment_hash: transaction_commitment,
        });
        tx_part.send(part).await?;
        sequence += 1;
    }

    // Close the channel to signal no more parts to come
    drop(tx_part);

    let block_size = ByteSize::b(block_size as u64);

    debug!(
        tx_count = %block_tx_count, size = %block_size, %transaction_commitment, parts = %sequence,
        "Built block in {:?}", start.elapsed()
    );

    tx_value_id
        .send(transaction_commitment)
        .map_err(|_| "Failed to send proposal commitment hash")?;

    Ok(())
}

pub async fn repropose_task(
    block_hash: Hash,
    tx_part: mpsc::Sender<ProposalPart>,
    parts: Vec<Arc<ProposalPart>>,
) {
    if let Err(e) = run_repropose_task(block_hash, tx_part, parts).await {
        error!("Failed to restream proposal: {e:?}");
    }
}

async fn run_repropose_task(
    _block_hash: Hash,
    tx_part: mpsc::Sender<ProposalPart>,
    parts: Vec<Arc<ProposalPart>>,
) -> Result<(), Box<dyn core::error::Error>> {
    for part in parts {
        let part = Arc::unwrap_or_clone(part);
        tx_part.send(part).await?;
    }
    Ok(())
}

```
---
### `starknet/host/src/host/starknet.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use std::collections::BTreeSet;
use std::time::Duration;

use async_trait::async_trait;
use bytesize::ByteSize;
use tokio::sync::{mpsc, oneshot};
use tokio::time::Instant;
use tracing::Instrument;

use malachitebft_core_types::{CommitCertificate, Round, SignedVote};

use crate::host::Host;
use crate::mempool::MempoolRef;
use crate::mempool_load::MempoolLoadRef;
use crate::part_store::PartStore;
use crate::types::*;

use super::proposal::{build_proposal_task, repropose_task};

#[derive(Copy, Clone, Debug)]
pub struct StarknetParams {
    pub max_block_size: ByteSize,
    pub txs_per_part: usize,
    pub time_allowance_factor: f32,
    pub exec_time_per_tx: Duration,
    pub max_retain_blocks: usize,
    pub stable_block_times: bool,
}

pub struct StarknetHost {
    pub params: StarknetParams,
    pub mempool: MempoolRef,
    pub mempool_load: MempoolLoadRef,
    pub address: Address,
    pub private_key: PrivateKey,
    pub validator_set: ValidatorSet,
    pub part_store: PartStore<MockContext>,
}

impl StarknetHost {
    pub fn new(
        params: StarknetParams,
        mempool: MempoolRef,
        mempool_load: MempoolLoadRef,
        address: Address,
        private_key: PrivateKey,
        validator_set: ValidatorSet,
    ) -> Self {
        Self {
            params,
            mempool,
            mempool_load,
            address,
            private_key,
            validator_set,
            part_store: Default::default(),
        }
    }
}

#[async_trait]
impl Host for StarknetHost {
    type Height = Height;
    type BlockHash = BlockHash;
    type MessageHash = MessageHash;
    type ProposalPart = ProposalPart;
    type Signature = Signature;
    type PublicKey = PublicKey;
    type Precommit = SignedVote<MockContext>;
    type Validator = Validator;

    #[tracing::instrument(skip_all, fields(%height, %round))]
    async fn build_new_proposal(
        &mut self,
        height: Self::Height,
        round: Round,
        deadline: Instant,
    ) -> (
        mpsc::Receiver<Self::ProposalPart>,
        oneshot::Receiver<Self::BlockHash>,
    ) {
        let (tx_part, rx_content) = mpsc::channel(self.params.txs_per_part);
        let (tx_block_hash, rx_block_hash) = oneshot::channel();

        tokio::spawn(
            build_proposal_task(
                height,
                round,
                self.address,
                self.private_key.clone(),
                self.params,
                deadline,
                self.mempool.clone(),
                tx_part,
                tx_block_hash,
            )
            .instrument(tracing::Span::current()),
        );

        (rx_content, rx_block_hash)
    }

    /// Receive a proposal from a peer.
    ///
    /// Context must support receiving multiple valid proposals on the same (height, round). This
    /// can happen due to a malicious validator, and any one of them can be decided.
    ///
    /// Params:
    /// - height  - The height of the block being proposed.
    /// - content - A channel for receiving the content of the proposal.
    ///             Each element is basically opaque from the perspective of Consensus.
    ///             Examples of what could be sent includes: transaction batch, proof.
    ///             Closing the channel indicates that the proposal is complete.
    ///
    /// Return
    /// - block_hash - ID of the content in the block.
    #[tracing::instrument(skip_all, fields(height = %_height))]
    async fn receive_proposal(
        &self,
        _content: mpsc::Receiver<Self::ProposalPart>,
        _height: Self::Height,
    ) -> oneshot::Receiver<Self::BlockHash> {
        todo!()
    }

    /// Send a proposal whose content is already known. LOC 16
    ///
    /// Params:
    /// - block_hash - Identifies the content to send.
    ///
    /// Returns:
    /// - content - A channel for sending the content of the proposal.
    #[tracing::instrument(skip_all, fields(%block_hash))]
    async fn send_known_proposal(
        &self,
        block_hash: Self::BlockHash,
    ) -> mpsc::Receiver<Self::ProposalPart> {
        let parts = self.part_store.all_parts_by_value_id(&block_hash);
        let (tx_part, rx_content) = mpsc::channel(self.params.txs_per_part);

        tokio::spawn(
            repropose_task(block_hash, tx_part, parts).instrument(tracing::Span::current()),
        );

        rx_content
    }

    /// The set of validators for a given block height. What do we need?
    /// - address      - tells the networking layer where to send messages.
    /// - public_key   - used for signature verification and identification.
    /// - voting_power - used for quorum calculations.
    async fn validators(&self, _height: Self::Height) -> Option<BTreeSet<Self::Validator>> {
        Some(self.validator_set.validators.iter().cloned().collect())
    }

    /// Sign a message hash
    async fn sign(&self, message: Self::MessageHash) -> Self::Signature {
        self.private_key.sign(message.as_bytes().as_slice())
    }

    /// Validates the signature field of a message. If None returns false.
    async fn validate_signature(
        &self,
        hash: &Self::MessageHash,
        signature: &Self::Signature,
        public_key: &Self::PublicKey,
    ) -> bool {
        public_key
            .verify(hash.as_bytes().as_slice(), signature)
            .is_ok()
    }

    /// Update the Context about which decision has been made. It is responsible for pinging any
    /// relevant components in the node to update their states accordingly.
    ///
    /// Params:
    /// - brock_hash - The ID of the content which has been decided.
    /// - precommits - The list of precommits from the round the decision was made (both for and against).
    /// - height     - The height of the decision.
    #[tracing::instrument(skip_all, fields(height = %_certificate.height, block_hash = %_certificate.value_id))]
    async fn decision(&self, _certificate: CommitCertificate<MockContext>) {}
}

```
---
### `starknet/host/src/host/state.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use sha3::Digest;
use std::path::Path;
use std::sync::Arc;
use std::time::Duration;

use rand::RngCore;
use tracing::{debug, error, trace};

use malachitebft_core_types::{Round, Validity};
use malachitebft_engine::consensus::ConsensusRef;
use malachitebft_engine::host::ProposedValue;
use malachitebft_engine::util::streaming::StreamId;
use malachitebft_starknet_p2p_proto as p2p_proto;

use crate::block_store::BlockStore;
use crate::host::StarknetHost;
use crate::streaming::PartStreamsMap;
use crate::types::*;

pub struct HostState {
    pub ctx: MockContext,
    pub height: Height,
    pub round: Round,
    pub proposer: Option<Address>,
    pub host: StarknetHost,
    pub consensus: Option<ConsensusRef<MockContext>>,
    pub block_store: BlockStore,
    pub part_streams_map: PartStreamsMap,
    pub nonce: u64,
}

impl HostState {
    pub async fn new<R>(
        ctx: MockContext,
        host: StarknetHost,
        db_path: impl AsRef<Path>,
        rng: &mut R,
    ) -> Self
    where
        R: RngCore,
    {
        Self {
            ctx,
            height: Height::new(0, 0),
            round: Round::Nil,
            proposer: None,
            host,
            consensus: None,
            block_store: BlockStore::new(db_path).await.unwrap(),
            part_streams_map: PartStreamsMap::default(),
            nonce: rng.next_u64(),
        }
    }

    pub fn stream_id(&mut self) -> StreamId {
        let stream_id = p2p_proto::ConsensusStreamId {
            height: self.height.as_u64(),
            round: self.round.as_u32().expect("round is non-nil"),
            nonce: self.nonce,
        };

        self.nonce += 1;

        let bytes = prost::Message::encode_to_vec(&stream_id);
        StreamId::new(bytes.into())
    }

    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, fields(%height, %round))]
    pub async fn build_proposal_from_parts(
        &self,
        height: Height,
        round: Round,
        parts: &[Arc<ProposalPart>],
    ) -> ProposedValue<MockContext> {
        // We must be here with non-empty `parts`, must have init, fin, commitment and maybe transactions
        assert!(!parts.is_empty(), "Parts must not be empty");

        let init = parts
            .iter()
            .find_map(|part| part.as_init())
            .expect("Init part not found");

        let fin = parts
            .iter()
            .find_map(|part| part.as_fin())
            .expect("Fin part not found");

        let _block_info = parts
            .iter()
            .find_map(|part| part.as_block_info())
            .expect("BlockInfo part not found");

        let commitment = parts
            .iter()
            .find_map(|part| part.as_commitment())
            .expect("ProposalCommitment part not found");

        // Collect all transactions from the transaction parts
        // We expect that the transaction parts are ordered by sequence number but we don't have a way to check
        // this here, so we just collect them in the order.
        let transactions: Vec<Transaction> = parts
            .iter()
            .filter_map(|part| part.as_transactions())
            .flat_map(|batch| batch.as_slice().iter().cloned())
            .collect();

        // Determine the validity of the proposal
        let validity = self
            .verify_proposal_validity(fin, commitment, transactions)
            .await;

        let valid_round = init.valid_round;
        if valid_round.is_defined() {
            debug!("Reassembling a proposal we might have seen before: {init:?}");
        }

        trace!(parts.len = %parts.len(), "Building proposal content from parts");

        ProposedValue {
            proposer: init.proposer,
            height,
            round,
            valid_round,
            value: fin.proposal_commitment_hash,
            validity,
        }
    }

    async fn verify_proposal_validity(
        &self,
        fin: &ProposalFin,
        commitment: &ProposalCommitment,
        transactions: Vec<Transaction>,
    ) -> Validity {
        let mut hasher = sha3::Keccak256::new();

        for tx in transactions.iter() {
            hasher.update(tx.hash().as_bytes());
        }

        let transaction_commitment = Hash::new(hasher.finalize().into());

        // TODO: Check that computed transaction_commitment and state_diff_commitment match the ones in the `commitment` and
        // the propposal commitment hash matches `fin.proposal_commitment_hash`
        // For now we just check that the hash of transactions matches the transaction commitment in `commitment`
        // and that the proposal commitment hash matches `fin.proposal_commitment_hash`
        let valid_proposal = transaction_commitment == commitment.transaction_commitment
            && transaction_commitment == fin.proposal_commitment_hash;

        if valid_proposal {
            Validity::Valid
        } else {
            error!(
                "ProposalCommitment hash mismatch: {} != {}",
                transaction_commitment, fin.proposal_commitment_hash
            );
            Validity::Invalid
        }
    }

    #[tracing::instrument(skip_all, fields(
        part.height = %height,
        part.round = %round,
        part.message = ?part.part_type(),
    ))]
    pub async fn build_value_from_part(
        &mut self,
        stream_id: &StreamId,
        height: Height,
        round: Round,
        part: ProposalPart,
    ) -> Option<ProposedValue<MockContext>> {
        self.host
            .part_store
            .store(stream_id, height, round, part.clone());

        if let ProposalPart::Transactions(txes) = &part {
            if self.host.params.exec_time_per_tx > Duration::from_secs(0) {
                debug!("Simulating tx execution and proof verification");

                // Simulate Tx execution. In the real implementation the results of the execution would be
                // accumulated in some intermediate state structure based on which the proposal commitment
                // will be computed once all parts are received and checked against the received
                // `ProposalCommitment` part (e.g. `state_diff_commitment`) and the `proposal_commitment_hash`
                // in the `Fin` part.
                let num_txes = txes.len() as u32;
                let exec_time = self.host.params.exec_time_per_tx * num_txes;
                tokio::time::sleep(exec_time).await;

                trace!("Simulation took {exec_time:?} to execute {num_txes} txes");
            }
        }

        let parts = self
            .host
            .part_store
            .all_parts_by_stream_id(stream_id.clone(), height, round);

        trace!(
            count = self.host.part_store.blocks_count(),
            "Blocks for which we have parts"
        );

        // TODO: Do more validations, e.g. there is no higher tx proposal part,
        // check that we have received the proof, etc.
        let Some(_fin) = parts.iter().find_map(|part| part.as_fin()) else {
            debug!("Proposal part has not been received yet: Fin");
            return None;
        };

        let Some(_block_info) = parts.iter().find_map(|part| part.as_block_info()) else {
            debug!("Proposal part has not been received yet: BlockInfo");
            return None;
        };

        let Some(_proposal_commitment) = parts.iter().find_map(|part| part.as_commitment()) else {
            debug!("Proposal part has not been received yet: ProposalCommitment");
            return None;
        };

        let block_size: usize = parts.iter().map(|p| p.size_bytes()).sum();
        let tx_count: usize = parts.iter().map(|p| p.tx_count()).sum();

        debug!(
            tx.count = %tx_count, block.size = %block_size, parts.count = %parts.len(),
            "All parts have been received already, building value"
        );

        // TODO: Add config knob for invalid blocks
        let proposed_value = self.build_proposal_from_parts(height, round, &parts).await;

        self.host
            .part_store
            .store_value_id(stream_id, height, round, proposed_value.value);

        Some(proposed_value)
    }
}

```
---
### `starknet/host/src/host.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::collections::BTreeSet;

use async_trait::async_trait;
use tokio::sync::{mpsc, oneshot};
use tokio::time::Instant;

use malachitebft_core_types::{CommitCertificate, Round};

use crate::types::MockContext;

pub mod proposal;
pub mod starknet;
pub mod state;

pub use starknet::{StarknetHost, StarknetParams};

#[async_trait]
pub trait Host {
    type Height;
    type BlockHash;
    type ProposalPart;
    type MessageHash;
    type Signature;
    type PublicKey;
    type Precommit;
    type Validator;

    /// Initiate building a proposal.
    ///
    /// Params:
    /// - deadline - When the Context must stop adding new TXs to the block.
    /// - height   - The height of the block being proposed.
    ///
    /// Return
    /// - content    - A channel for sending the content of the proposal.
    ///                Each element is basically opaque from the perspective of Consensus.
    ///                Examples of what could be sent includes: transaction batch, proof.
    ///                Closing the channel indicates that the proposal is complete.
    /// - block_hash - ID of the content in the block.
    async fn build_new_proposal(
        &mut self,
        height: Self::Height,
        round: Round,
        deadline: Instant,
    ) -> (
        mpsc::Receiver<Self::ProposalPart>,
        oneshot::Receiver<Self::BlockHash>,
    );

    /// Receive a proposal from a peer.
    ///
    /// Context must support receiving multiple valid proposals on the same (height, round). This
    /// can happen due to a malicious validator, and any one of them can be decided.
    ///
    /// Params:
    /// - height  - The height of the block being proposed.
    /// - content - A channel for receiving the content of the proposal.
    ///             Each element is basically opaque from the perspective of Consensus.
    ///             Examples of what could be sent includes: transaction batch, proof.
    ///             Closing the channel indicates that the proposal is complete.
    ///
    /// Return
    /// - block_hash - ID of the content in the block.
    async fn receive_proposal(
        &self,
        content: mpsc::Receiver<Self::ProposalPart>,
        height: Self::Height,
    ) -> oneshot::Receiver<Self::BlockHash>;

    /// Send a proposal whose content is already known. LOC 16
    ///
    /// Params:
    /// - block_hash - Identifies the content to send.
    ///
    /// Returns:
    /// - content - A channel for sending the content of the proposal.
    async fn send_known_proposal(
        &self,
        block_hash: Self::BlockHash,
    ) -> mpsc::Receiver<Self::ProposalPart>;

    /// The set of validators for a given block height. What do we need?
    /// - address      - tells the networking layer where to send messages.
    /// - public_key   - used for signature verification and identification.
    /// - voting_power - used for quorum calculations.
    async fn validators(&self, height: Self::Height) -> Option<BTreeSet<Self::Validator>>;

    /// Sign the given message hash
    async fn sign(&self, message: Self::MessageHash) -> Self::Signature;

    /// Validates the signature of a message hash.
    async fn validate_signature(
        &self,
        hash: &Self::MessageHash,
        signature: &Self::Signature,
        public_key: &Self::PublicKey,
    ) -> bool;

    /// Update the Context about which decision has been made. It is responsible for pinging any
    /// relevant components in the node to update their states accordingly.
    ///
    /// Params:
    /// - brock_hash - The ID of the content which has been decided.
    /// - precommits - The list of precommits from the round the decision was made (both for and against).
    /// - height     - The height of the decision.
    async fn decision(&self, certificate: CommitCertificate<MockContext>);
}

```
---
### `starknet/host/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod actor;
pub mod block_store;
pub mod codec;
pub mod config;
pub mod host;
pub mod mempool;
pub mod mempool_load;
pub mod node;
pub mod spawn;
pub mod streaming;
pub use malachitebft_app::part_store;
pub mod proto {
    pub use malachitebft_proto::*;
    pub use malachitebft_starknet_p2p_proto::*;
}

pub mod types {
    pub use malachitebft_starknet_p2p_types::*;
}

```
---
### `starknet/host/src/mempool/network.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use std::collections::BTreeSet;
use std::sync::Arc;

use async_trait::async_trait;
use libp2p_identity::Keypair;
use ractor::ActorProcessingErr;
use ractor::ActorRef;
use ractor::{Actor, RpcReplyPort};
use tokio::task::JoinHandle;
use tracing::error;

use malachitebft_engine::util::output_port::{OutputPort, OutputPortSubscriber};
use malachitebft_metrics::SharedRegistry;
use malachitebft_test_mempool::handle::CtrlHandle;
use malachitebft_test_mempool::types::MempoolTransactionBatch;
use malachitebft_test_mempool::Channel::Mempool;
use malachitebft_test_mempool::{Config, Event, NetworkMsg, PeerId};

pub type MempoolNetworkMsg = Msg;
pub type MempoolNetworkRef = ActorRef<Msg>;

pub struct MempoolNetwork {
    span: tracing::Span,
}

impl MempoolNetwork {
    pub async fn spawn(
        keypair: Keypair,
        config: Config,
        metrics: SharedRegistry,
        span: tracing::Span,
    ) -> Result<ActorRef<Msg>, ractor::SpawnErr> {
        let args = Args {
            keypair,
            config,
            metrics,
        };

        let (actor_ref, _) = Actor::spawn(None, Self { span }, args).await?;
        Ok(actor_ref)
    }
}

pub struct Args {
    pub keypair: Keypair,
    pub config: Config,
    pub metrics: SharedRegistry,
}

pub enum State {
    Stopped,
    Running {
        peers: BTreeSet<PeerId>,
        output_port: OutputPort<Arc<Event>>,
        ctrl_handle: CtrlHandle,
        recv_task: JoinHandle<()>,
    },
}

pub enum Msg {
    /// Subscribe to gossip events
    Subscribe(OutputPortSubscriber<Arc<Event>>),

    /// Broadcast a message to all peers
    BroadcastMsg(MempoolTransactionBatch),

    /// Request the number of connected peers
    GetState { reply: RpcReplyPort<usize> },

    // Internal message
    #[doc(hidden)]
    NewEvent(Event),
}

#[async_trait]
impl Actor for MempoolNetwork {
    type Msg = Msg;
    type State = State;
    type Arguments = Args;

    async fn pre_start(
        &self,
        myself: ActorRef<Msg>,
        args: Args,
    ) -> Result<State, ActorProcessingErr> {
        let handle =
            malachitebft_test_mempool::spawn(args.keypair, args.config, args.metrics).await?;
        let (mut recv_handle, ctrl_handle) = handle.split();

        let recv_task = tokio::spawn(async move {
            while let Some(event) = recv_handle.recv().await {
                if let Err(e) = myself.cast(Msg::NewEvent(event)) {
                    error!("Actor has died, stopping gossip mempool: {e:?}");
                    break;
                }
            }
        });

        Ok(State::Running {
            peers: BTreeSet::new(),
            output_port: OutputPort::default(),
            ctrl_handle,
            recv_task,
        })
    }

    async fn post_start(
        &self,
        _myself: ActorRef<Msg>,
        _state: &mut State,
    ) -> Result<(), ActorProcessingErr> {
        Ok(())
    }

    #[tracing::instrument(name = "gossip.mempool", parent = &self.span, skip_all)]
    async fn handle(
        &self,
        _myself: ActorRef<Msg>,
        msg: Msg,
        state: &mut State,
    ) -> Result<(), ActorProcessingErr> {
        let State::Running {
            peers,
            output_port,
            ctrl_handle,
            ..
        } = state
        else {
            return Ok(());
        };

        match msg {
            Msg::Subscribe(subscriber) => subscriber.subscribe_to_port(output_port),

            Msg::BroadcastMsg(batch) => {
                match NetworkMsg::TransactionBatch(batch).to_network_bytes() {
                    Ok(bytes) => {
                        ctrl_handle.broadcast(Mempool, bytes).await?;
                    }
                    Err(e) => {
                        error!("Failed to serialize transaction batch: {e}");
                    }
                }
            }

            Msg::NewEvent(event) => {
                match event {
                    Event::PeerConnected(peer_id) => {
                        peers.insert(peer_id);
                    }
                    Event::PeerDisconnected(peer_id) => {
                        peers.remove(&peer_id);
                    }
                    _ => {}
                }

                let event = Arc::new(event);
                output_port.send(event);
            }

            Msg::GetState { reply } => {
                let number_peers = match state {
                    State::Stopped => 0,
                    State::Running { peers, .. } => peers.len(),
                };

                reply.send(number_peers)?;
            }
        }

        Ok(())
    }

    async fn post_stop(
        &self,
        _myself: ActorRef<Msg>,
        state: &mut State,
    ) -> Result<(), ActorProcessingErr> {
        let state = std::mem::replace(state, State::Stopped);

        if let State::Running {
            ctrl_handle,
            recv_task,
            ..
        } = state
        {
            ctrl_handle.wait_shutdown().await?;
            recv_task.await?;
        }

        Ok(())
    }
}

```
---
### `starknet/host/src/mempool.rs`
*2025-05-18 23:58:49 | 8 KB*
```rust
use std::collections::BTreeMap;
use std::sync::Arc;

use async_trait::async_trait;
use ractor::{Actor, ActorProcessingErr, ActorRef, RpcReplyPort};
use tracing::{debug, error, info, trace};

use malachitebft_test_mempool::types::MempoolTransactionBatch;
use malachitebft_test_mempool::{Event as NetworkEvent, NetworkMsg, PeerId};

use crate::proto::Protobuf;
use crate::types::{Hash, Transaction, TransactionBatch};

pub mod network;
use network::{MempoolNetworkMsg, MempoolNetworkRef};

pub type MempoolMsg = Msg;
pub type MempoolRef = ActorRef<Msg>;

pub struct Mempool {
    network: MempoolNetworkRef,
    gossip_batch_size: usize,
    max_tx_count: usize,
    span: tracing::Span,
}

pub enum Msg {
    NetworkEvent(Arc<NetworkEvent>),
    AddBatch(TransactionBatch),
    Reap {
        height: u64,
        num_txes: usize,
        reply: RpcReplyPort<Vec<Transaction>>,
    },
    Update {
        tx_hashes: Vec<Hash>,
    },
}

impl From<Arc<NetworkEvent>> for Msg {
    fn from(event: Arc<NetworkEvent>) -> Self {
        Self::NetworkEvent(event)
    }
}

#[derive(Default)]
pub struct State {
    transactions: BTreeMap<Hash, Transaction>,
}

impl State {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add_tx(&mut self, tx: Transaction) {
        self.transactions.entry(tx.hash()).or_insert(tx);
    }

    pub fn remove_tx(&mut self, hash: &Hash) {
        self.transactions.remove(hash);
    }
}

impl Mempool {
    pub fn new(
        mempool_network: MempoolNetworkRef,
        gossip_batch_size: usize,
        max_tx_count: usize,
        span: tracing::Span,
    ) -> Self {
        Self {
            network: mempool_network,
            gossip_batch_size,
            max_tx_count,
            span,
        }
    }

    pub async fn spawn(
        mempool_network: MempoolNetworkRef,
        gossip_batch_size: usize,
        max_tx_count: usize,
        span: tracing::Span,
    ) -> Result<MempoolRef, ractor::SpawnErr> {
        let node = Self::new(mempool_network, gossip_batch_size, max_tx_count, span);
        let (actor_ref, _) = Actor::spawn(None, node, ()).await?;
        Ok(actor_ref)
    }

    pub async fn handle_network_event(
        &self,
        event: &NetworkEvent,
        myself: MempoolRef,
        state: &mut State,
    ) -> Result<(), ractor::ActorProcessingErr> {
        match event {
            NetworkEvent::Listening(address) => {
                info!(%address, "Listening");
            }
            NetworkEvent::PeerConnected(peer_id) => {
                info!(%peer_id, "Connected to peer");
            }
            NetworkEvent::PeerDisconnected(peer_id) => {
                info!(%peer_id, "Disconnected from peer");
            }
            NetworkEvent::Message(_channel, from, _msg_id, msg) => {
                trace!(%from, size = msg.size_bytes(), "Received message");

                self.handle_network_msg(from, msg, myself, state).await?;
            }
        }

        Ok(())
    }

    pub async fn handle_network_msg(
        &self,
        from: &PeerId,
        msg: &NetworkMsg,
        _myself: MempoolRef,
        state: &mut State,
    ) -> Result<(), ractor::ActorProcessingErr> {
        match msg {
            NetworkMsg::TransactionBatch(batch) => {
                let batch = match TransactionBatch::from_any(&batch.transaction_batch) {
                    Ok(batch) => batch,
                    Err(e) => {
                        error!("Failed to decode transaction batch: {e}");
                        return Ok(());
                    }
                };

                trace!(%from, "Received batch from network with {} transactions", batch.len());

                self.add_batch(batch, state);
            }
        }

        Ok(())
    }

    fn add_batch(&self, batch: TransactionBatch, state: &mut State) {
        for tx in batch.into_vec() {
            if state.transactions.len() < self.max_tx_count {
                state.add_tx(tx);
            } else {
                trace!("Mempool is full, dropping transaction batch");
                break;
            }
        }
    }

    fn gossip_batch(&self, batch: &TransactionBatch) -> Result<(), ActorProcessingErr> {
        assert!(self.gossip_batch_size > 0, "Gossip must be enabled");

        trace!("Broadcasting transaction batch to network");

        for batch in batch.as_slice().chunks(self.gossip_batch_size) {
            let tx_batch = TransactionBatch::new(batch.to_vec()).to_any().unwrap();
            let mempool_batch = MempoolTransactionBatch::new(tx_batch);
            self.network
                .cast(MempoolNetworkMsg::BroadcastMsg(mempool_batch))?;
        }

        Ok(())
    }

    fn gossip_enabled(&self) -> bool {
        self.gossip_batch_size > 0
    }

    async fn handle_msg(
        &self,
        myself: MempoolRef,
        msg: Msg,
        state: &mut State,
    ) -> Result<(), ractor::ActorProcessingErr> {
        match msg {
            Msg::NetworkEvent(event) => {
                self.handle_network_event(&event, myself, state).await?;
            }

            Msg::AddBatch(batch) => {
                trace!("Received batch of {} transactions", batch.len());

                // If mempool gossip is enabled, broadcast the transactions to the network
                if self.gossip_enabled() {
                    self.gossip_batch(&batch)?;
                }

                self.add_batch(batch, state);
            }

            Msg::Reap {
                height,
                num_txes: count,
                reply,
            } => {
                debug!(%height, %count, "Reaping transactions");

                let mut txes = Vec::with_capacity(count);

                for _ in 0..count {
                    if let Some((_, tx)) = state.transactions.pop_first() {
                        txes.push(tx);
                    } else {
                        // No more transactions to reap
                        break;
                    }
                }

                reply.send(txes)?;
            }

            Msg::Update { tx_hashes } => {
                tx_hashes.iter().for_each(|hash| state.remove_tx(hash));
            }
        }

        Ok(())
    }
}

#[async_trait]
impl Actor for Mempool {
    type Msg = Msg;
    type State = State;
    type Arguments = ();

    #[tracing::instrument("host.mempool", parent = &self.span, skip_all)]
    async fn pre_start(
        &self,
        myself: MempoolRef,
        _args: (),
    ) -> Result<State, ractor::ActorProcessingErr> {
        self.network.link(myself.get_cell());

        self.network
            .cast(MempoolNetworkMsg::Subscribe(Box::new(myself.clone())))?;

        Ok(State::new())
    }

    #[tracing::instrument("host.mempool", parent = &self.span, skip_all)]
    async fn handle(
        &self,
        myself: MempoolRef,
        msg: MempoolMsg,
        state: &mut State,
    ) -> Result<(), ractor::ActorProcessingErr> {
        if let Err(e) = self.handle_msg(myself, msg, state).await {
            error!("Error processing message: {e:?}");
        }

        Ok(())
    }

    #[tracing::instrument("host.mempool", parent = &self.span, skip_all)]
    async fn post_stop(
        &self,
        _myself: MempoolRef,
        _state: &mut State,
    ) -> Result<(), ActorProcessingErr> {
        info!("Stopping...");

        Ok(())
    }
}

```
---
### `starknet/host/src/mempool_load.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use std::time::Duration;

use async_trait::async_trait;
use bytesize::ByteSize;
use ractor::{concurrency::JoinHandle, Actor, ActorProcessingErr, ActorRef};
use rand::rngs::SmallRng;
use rand::seq::IteratorRandom;
use rand::{Rng, RngCore, SeedableRng};
use tracing::info;

use malachitebft_config::mempool_load::{NonUniformLoadConfig, UniformLoadConfig};
use malachitebft_config::MempoolLoadType;
use malachitebft_starknet_p2p_types::{Transaction, TransactionBatch};

use crate::mempool::{MempoolMsg, MempoolRef};

pub type MempoolLoadMsg = Msg;
pub type MempoolLoadRef = ActorRef<Msg>;

pub enum Msg {
    GenerateTransactions { count: usize, size: ByteSize },
}

#[derive(Debug)]
pub struct State {
    ticker: JoinHandle<()>,
}

#[derive(Debug, Default)]
pub struct Params {
    pub load_type: MempoolLoadType,
}

pub struct MempoolLoad {
    params: Params,
    mempool: MempoolRef,
    span: tracing::Span,
}

impl MempoolLoad {
    pub fn new(params: Params, mempool: MempoolRef, span: tracing::Span) -> Self {
        Self {
            params,
            mempool,
            span,
        }
    }

    pub async fn spawn(
        params: Params,
        mempool: MempoolRef,
        span: tracing::Span,
    ) -> Result<MempoolLoadRef, ractor::SpawnErr> {
        let actor = Self::new(params, mempool, span);
        let (actor_ref, _) = Actor::spawn(None, actor, ()).await?;
        Ok(actor_ref)
    }

    pub fn generate_transactions(count: usize, size: ByteSize) -> Vec<Transaction> {
        let mut transactions: Vec<Transaction> = Vec::with_capacity(count);
        let mut rng = SmallRng::from_entropy();

        for _ in 0..count {
            let mut tx_bytes = vec![0; size.as_u64() as usize];
            rng.fill_bytes(&mut tx_bytes);
            let tx = Transaction::new(tx_bytes);
            transactions.push(tx);
        }
        transactions
    }

    fn generate_non_uniform_load_params(
        params: &NonUniformLoadConfig,
    ) -> (usize, ByteSize, Duration) {
        let mut rng = SmallRng::from_entropy();

        // Determine if this iteration should generate a spike
        let is_spike = rng.gen_bool(params.spike_probability);

        // Vary transaction count and size
        let count_variation = rng.gen_range(params.count_variation.clone());
        let size_variation = rng.gen_range(params.size_variation.clone());

        let count = if is_spike {
            (params.base_count + count_variation) as usize * params.spike_multiplier
        } else {
            (params.base_count + count_variation) as usize
        };
        let size = (params.base_size + size_variation) as u64;

        // Get sleep duration
        let sleep_duration =
            Duration::from_millis(params.sleep_interval.clone().choose(&mut rng).unwrap());

        (count.max(1), ByteSize::b(size.max(1)), sleep_duration)
    }

    async fn run_uniform_load(params: UniformLoadConfig, myself: MempoolLoadRef) {
        loop {
            // Create and send the message
            let msg = Msg::GenerateTransactions {
                count: params.count,
                size: params.size,
            };

            if let Err(er) = myself.cast(msg) {
                tracing::error!(?er, ?myself, "Channel closed, stopping load generator");
                break;
            }

            tokio::time::sleep(params.interval).await;
        }
    }

    async fn run_non_uniform_load(params: NonUniformLoadConfig, myself: MempoolLoadRef) {
        loop {
            let (count, size, sleep_duration) = Self::generate_non_uniform_load_params(&params);

            // Create and send the message
            let msg = Msg::GenerateTransactions { count, size };

            if let Err(er) = myself.cast(msg) {
                tracing::error!(?er, ?myself, "Channel closed, stopping load generator");
                break;
            }

            tokio::time::sleep(sleep_duration).await;
        }
    }
}

#[async_trait]
impl Actor for MempoolLoad {
    type Msg = Msg;
    type State = State;
    type Arguments = ();

    async fn pre_start(
        &self,
        myself: MempoolLoadRef,
        _args: (),
    ) -> Result<State, ActorProcessingErr> {
        let ticker = match self.params.load_type.clone() {
            MempoolLoadType::NoLoad => tokio::spawn(async {}),
            MempoolLoadType::UniformLoad(uniform_load_config) => {
                tokio::spawn(Self::run_uniform_load(uniform_load_config, myself.clone()))
            }
            MempoolLoadType::NonUniformLoad(non_uniform_load_config) => tokio::spawn(
                Self::run_non_uniform_load(non_uniform_load_config, myself.clone()),
            ),
        };
        Ok(State { ticker })
    }

    async fn post_stop(
        &self,
        _myself: ActorRef<Self::Msg>,
        state: &mut Self::State,
    ) -> Result<(), ActorProcessingErr> {
        info!("Stopping...");
        state.ticker.abort();
        Ok(())
    }

    #[tracing::instrument("host.mempool_load", parent = &self.span, skip_all)]
    async fn handle(
        &self,
        _myself: MempoolLoadRef,
        msg: Msg,
        _state: &mut State,
    ) -> Result<(), ActorProcessingErr> {
        match msg {
            Msg::GenerateTransactions { count, size } => {
                let transactions = Self::generate_transactions(count, size);
                let tx_batch = TransactionBatch::new(transactions);

                self.mempool.cast(MempoolMsg::AddBatch(tx_batch))?;

                Ok(())
            }
        }
    }
}

```
---
### `starknet/host/src/node.rs`
*2025-05-18 23:58:49 | 16 KB*
```rust
#![allow(clippy::too_many_arguments)]

use std::path::PathBuf;

use ractor::async_trait;
use rand::{CryptoRng, RngCore};
use serde::{Deserialize, Serialize};
use tokio::task::JoinHandle;

use malachitebft_app::events::{RxEvent, TxEvent};
use malachitebft_app::node::{
    CanGeneratePrivateKey, CanMakeConfig, CanMakeDistributedConfig, CanMakeGenesis,
    CanMakePrivateKeyFile, MakeConfigSettings, Node, NodeHandle,
};
use malachitebft_app::types::Keypair;
use malachitebft_config::mempool_load::UniformLoadConfig;
use malachitebft_core_types::VotingPower;
use malachitebft_engine::node::NodeRef;
use malachitebft_starknet_p2p_types::Ed25519Provider;

use crate::config::{load_config, Config};
use crate::spawn::spawn_node_actor;
use crate::types::{Address, Height, MockContext, PrivateKey, PublicKey, Validator, ValidatorSet};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Genesis {
    pub validator_set: ValidatorSet,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct PrivateKeyFile {
    pub private_key: PrivateKey,
    pub public_key: PublicKey,
    pub address: Address,
}

impl From<PrivateKey> for PrivateKeyFile {
    fn from(private_key: PrivateKey) -> Self {
        let public_key = private_key.public_key();
        let address = Address::from_public_key(public_key);

        Self {
            private_key,
            public_key,
            address,
        }
    }
}

pub struct Handle {
    pub actor: NodeRef,
    pub handle: JoinHandle<()>,
    pub tx_event: TxEvent<MockContext>,
}

#[async_trait]
impl NodeHandle<MockContext> for Handle {
    fn subscribe(&self) -> RxEvent<MockContext> {
        self.tx_event.subscribe()
    }

    async fn kill(&self, _reason: Option<String>) -> eyre::Result<()> {
        self.actor.kill_and_wait(None).await?;
        self.handle.abort();
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub enum ConfigSource {
    File(PathBuf),
    Value(Box<Config>),
    Default,
}

#[derive(Clone, Debug)]
pub struct StarknetNode {
    pub home_dir: PathBuf,
    pub config_source: ConfigSource,
    pub start_height: Option<u64>,
}

impl StarknetNode {
    pub fn new(home_dir: PathBuf, config_source: ConfigSource, start_height: Option<u64>) -> Self {
        Self {
            home_dir,
            config_source,
            start_height,
        }
    }

    pub fn genesis_file(&self) -> PathBuf {
        self.home_dir.join("config").join("genesis.json")
    }

    pub fn private_key_file(&self) -> PathBuf {
        self.home_dir.join("config").join("priv_validator_key.json")
    }
}

#[async_trait]
impl Node for StarknetNode {
    type Context = MockContext;
    type Config = Config;
    type Genesis = Genesis;
    type PrivateKeyFile = PrivateKeyFile;
    type SigningProvider = Ed25519Provider;
    type NodeHandle = Handle;

    fn get_home_dir(&self) -> PathBuf {
        self.home_dir.to_owned()
    }

    fn load_config(&self) -> eyre::Result<Self::Config> {
        match self.config_source {
            ConfigSource::File(ref path) => load_config(path, Some("MALACHITE")),
            ConfigSource::Value(ref config) => Ok(*config.clone()),
            ConfigSource::Default => Ok(default_config()),
        }
    }

    fn get_address(&self, pk: &PublicKey) -> Address {
        Address::from_public_key(*pk)
    }

    fn get_public_key(&self, pk: &PrivateKey) -> PublicKey {
        pk.public_key()
    }

    fn get_keypair(&self, pk: PrivateKey) -> Keypair {
        Keypair::ed25519_from_bytes(pk.inner().to_bytes()).unwrap()
    }

    fn load_private_key(&self, file: Self::PrivateKeyFile) -> PrivateKey {
        file.private_key
    }

    fn load_private_key_file(&self) -> eyre::Result<Self::PrivateKeyFile> {
        let private_key = std::fs::read_to_string(self.private_key_file())?;
        serde_json::from_str(&private_key).map_err(|e| e.into())
    }

    fn get_signing_provider(&self, private_key: PrivateKey) -> Self::SigningProvider {
        Self::SigningProvider::new(private_key)
    }

    fn load_genesis(&self) -> eyre::Result<Self::Genesis> {
        let genesis = std::fs::read_to_string(self.genesis_file())?;
        serde_json::from_str(&genesis).map_err(|e| e.into())
    }

    async fn start(&self) -> eyre::Result<Handle> {
        let config = self.load_config()?;

        let span = tracing::error_span!("node", moniker = %config.moniker);
        let _enter = span.enter();

        let priv_key_file = self.load_private_key_file()?;
        let private_key = self.load_private_key(priv_key_file);
        let genesis = self.load_genesis()?;
        let tx_event = TxEvent::new();

        let start_height = self.start_height.map(|height| Height::new(height, 1));

        let (actor, handle) = spawn_node_actor(
            config.clone(),
            self.home_dir.clone(),
            genesis.validator_set,
            private_key,
            start_height,
            tx_event.clone(),
            span.clone(),
        )
        .await;

        Ok(Handle {
            actor,
            handle,
            tx_event,
        })
    }

    async fn run(self) -> eyre::Result<()> {
        let handle = self.start().await?;
        handle.actor.wait(None).await.map_err(Into::into)
    }
}

impl CanGeneratePrivateKey for StarknetNode {
    fn generate_private_key<R>(&self, rng: R) -> PrivateKey
    where
        R: RngCore + CryptoRng,
    {
        PrivateKey::generate(rng)
    }
}

impl CanMakePrivateKeyFile for StarknetNode {
    fn make_private_key_file(&self, private_key: PrivateKey) -> Self::PrivateKeyFile {
        PrivateKeyFile::from(private_key)
    }
}

impl CanMakeGenesis for StarknetNode {
    fn make_genesis(&self, validators: Vec<(PublicKey, VotingPower)>) -> Self::Genesis {
        let validators = validators
            .into_iter()
            .map(|(pk, vp)| Validator::new(pk, vp));

        let validator_set = ValidatorSet::new(validators);

        Genesis { validator_set }
    }
}

impl CanMakeConfig for StarknetNode {
    fn make_config(index: usize, total: usize, settings: MakeConfigSettings) -> Self::Config {
        make_config(index, total, settings)
    }
}

impl CanMakeDistributedConfig for StarknetNode {
    fn make_distributed_config(
        index: usize,
        total: usize,
        machines: Vec<String>,
        bootstrap_set_size: usize,
        settings: MakeConfigSettings,
    ) -> Self::Config {
        make_distributed_config(index, total, machines, bootstrap_set_size, settings)
    }
}

/// Generate configuration for node "index" out of "total" number of nodes.
fn make_config(index: usize, total: usize, settings: MakeConfigSettings) -> Config {
    use itertools::Itertools;
    use rand::seq::IteratorRandom;
    use rand::Rng;

    use malachitebft_config::*;

    const CONSENSUS_BASE_PORT: usize = 27000;
    const MEMPOOL_BASE_PORT: usize = 28000;
    const METRICS_BASE_PORT: usize = 29000;

    let consensus_port = CONSENSUS_BASE_PORT + index;
    let mempool_port = MEMPOOL_BASE_PORT + index;
    let metrics_port = METRICS_BASE_PORT + index;

    Config {
        moniker: format!("starknet-{}", index),
        consensus: ConsensusConfig {
            value_payload: ValuePayload::PartsOnly,
            timeouts: TimeoutConfig::default(),
            p2p: P2pConfig {
                protocol: PubSubProtocol::default(),
                listen_addr: settings.transport.multiaddr("127.0.0.1", consensus_port),
                persistent_peers: if settings.discovery.enabled {
                    let mut rng = rand::thread_rng();
                    let count = if total > 1 {
                        rng.gen_range(1..=(total / 2))
                    } else {
                        0
                    };
                    let peers = (0..total)
                        .filter(|j| *j != index)
                        .choose_multiple(&mut rng, count);

                    peers
                        .iter()
                        .unique()
                        .map(|index| {
                            settings
                                .transport
                                .multiaddr("127.0.0.1", CONSENSUS_BASE_PORT + index)
                        })
                        .collect()
                } else {
                    (0..total)
                        .filter(|j| *j != index)
                        .map(|j| {
                            settings
                                .transport
                                .multiaddr("127.0.0.1", CONSENSUS_BASE_PORT + j)
                        })
                        .collect()
                },
                discovery: settings.discovery,
                ..Default::default()
            },
        },
        mempool: MempoolConfig {
            p2p: P2pConfig {
                protocol: PubSubProtocol::default(),
                listen_addr: settings.transport.multiaddr("127.0.0.1", mempool_port),
                persistent_peers: (0..total)
                    .filter(|j| *j != index)
                    .map(|j| {
                        settings
                            .transport
                            .multiaddr("127.0.0.1", MEMPOOL_BASE_PORT + j)
                    })
                    .collect(),
                discovery: DiscoveryConfig {
                    enabled: false,
                    ..settings.discovery
                },
                ..Default::default()
            },
            max_tx_count: 10000,
            gossip_batch_size: 0,
            load: MempoolLoadConfig {
                load_type: MempoolLoadType::UniformLoad(UniformLoadConfig::default()),
            },
        },
        metrics: MetricsConfig {
            enabled: true,
            listen_addr: format!("127.0.0.1:{metrics_port}").parse().unwrap(),
        },
        runtime: settings.runtime,
        value_sync: ValueSyncConfig::default(),
        logging: LoggingConfig::default(),
        test: TestConfig::default(),
    }
}

fn make_distributed_config(
    index: usize,
    _total: usize,
    machines: Vec<String>,
    bootstrap_set_size: usize,
    settings: MakeConfigSettings,
) -> Config {
    use itertools::Itertools;
    use malachitebft_config::*;
    use std::time::Duration;

    const CONSENSUS_BASE_PORT: usize = 27000;
    const MEMPOOL_BASE_PORT: usize = 28000;
    const METRICS_BASE_PORT: usize = 29000;

    let machine = machines[index % machines.len()].clone();
    let consensus_port = CONSENSUS_BASE_PORT + (index / machines.len());
    let mempool_port = MEMPOOL_BASE_PORT + (index / machines.len());
    let metrics_port = METRICS_BASE_PORT + (index / machines.len());

    Config {
        moniker: format!("starknet-{}", index),
        consensus: ConsensusConfig {
            value_payload: ValuePayload::PartsOnly,
            timeouts: TimeoutConfig::default(),
            p2p: P2pConfig {
                protocol: PubSubProtocol::default(),
                listen_addr: settings.transport.multiaddr(&machine, consensus_port),
                persistent_peers: if settings.discovery.enabled {
                    let peers =
                        ((index.saturating_sub(bootstrap_set_size))..index).collect::<Vec<_>>();

                    peers
                        .iter()
                        .unique()
                        .map(|j| {
                            settings.transport.multiaddr(
                                &machines[j % machines.len()].clone(),
                                CONSENSUS_BASE_PORT + (j / machines.len()),
                            )
                        })
                        .collect()
                } else {
                    let peers = (0..index).collect::<Vec<_>>();

                    peers
                        .iter()
                        .map(|j| {
                            settings.transport.multiaddr(
                                &machines[*j % machines.len()],
                                CONSENSUS_BASE_PORT + (*j / machines.len()),
                            )
                        })
                        .collect()
                },
                discovery: settings.discovery,
                ..Default::default()
            },
        },
        mempool: MempoolConfig {
            p2p: P2pConfig {
                protocol: PubSubProtocol::default(),
                listen_addr: settings.transport.multiaddr(&machine, mempool_port),
                persistent_peers: vec![],
                discovery: DiscoveryConfig {
                    enabled: false,
                    ..DiscoveryConfig::default()
                },
                ..Default::default()
            },
            max_tx_count: 10000,
            gossip_batch_size: 0,
            load: MempoolLoadConfig {
                load_type: MempoolLoadType::UniformLoad(UniformLoadConfig::default()),
            },
        },
        value_sync: ValueSyncConfig {
            enabled: false,
            status_update_interval: Duration::from_secs(0),
            request_timeout: Duration::from_secs(0),
        },
        metrics: MetricsConfig {
            enabled: true,
            listen_addr: format!("{machine}:{metrics_port}").parse().unwrap(),
        },
        runtime: settings.runtime,
        logging: LoggingConfig::default(),
        test: TestConfig::default(),
    }
}

fn default_config() -> Config {
    use malachitebft_config::{DiscoveryConfig, RuntimeConfig, TransportProtocol};

    make_config(
        1,
        3,
        MakeConfigSettings {
            runtime: RuntimeConfig::single_threaded(),
            transport: TransportProtocol::Tcp,
            discovery: DiscoveryConfig::default(),
        },
    )
}

#[test]
fn test_starknet_node() {
    // Create temp folder for configuration files
    let temp_dir = tempfile::TempDir::with_prefix("informalsystems-malachitebft-node-")
        .expect("Failed to create temp dir");

    let temp_path = temp_dir.path().to_owned();

    if std::env::var("KEEP_TEMP").is_ok() {
        std::mem::forget(temp_dir);
    }

    std::fs::create_dir_all(temp_path.join("config")).unwrap();

    // Create default configuration
    let node = StarknetNode::new(temp_path.clone(), ConfigSource::Default, Some(1));

    // Create configuration files
    use malachitebft_test_cli::*;

    let priv_keys = new::generate_private_keys(&node, 1, true);
    let pub_keys = priv_keys.iter().map(|pk| node.get_public_key(pk)).collect();
    let genesis = new::generate_genesis(&node, pub_keys, true);

    file::save_priv_validator_key(
        &node,
        &node.private_key_file(),
        &PrivateKeyFile::from(priv_keys[0].clone()),
    )
    .unwrap();

    file::save_genesis(&node, &node.genesis_file(), &genesis).unwrap();

    let config = node.load_config().unwrap();

    // Run the node for a few seconds
    const TIMEOUT: u64 = 3;
    use tokio::time::{timeout, Duration};
    let rt = malachitebft_test_cli::runtime::build_runtime(config.runtime).unwrap();
    let result = rt.block_on(async { timeout(Duration::from_secs(TIMEOUT), node.run()).await });

    // Check that the node did not quit before the timeout.
    assert!(result.is_err());
    let error = result.unwrap_err();
    assert_eq!(error.to_string(), "deadline has elapsed");
    let io_error: std::io::Error = error.into();
    assert_eq!(
        io_error.to_string(),
        std::io::Error::new(std::io::ErrorKind::TimedOut, "timed out").to_string()
    );
}

```
---
### `starknet/host/src/spawn.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
use std::path::{Path, PathBuf};
use std::time::Duration;

use tokio::task::JoinHandle;
use tracing::warn;

use malachitebft_config::{self as config, MempoolConfig, MempoolLoadConfig, ValueSyncConfig};
use malachitebft_core_types::ValuePayload;
use malachitebft_engine::consensus::{Consensus, ConsensusParams, ConsensusRef};
use malachitebft_engine::host::HostRef;
use malachitebft_engine::network::{Network, NetworkRef};
use malachitebft_engine::node::{Node, NodeRef};
use malachitebft_engine::sync::{Params as SyncParams, Sync, SyncRef};
use malachitebft_engine::util::events::TxEvent;
use malachitebft_engine::wal::{Wal, WalRef};
use malachitebft_metrics::{Metrics, SharedRegistry};
use malachitebft_network::Keypair;
use malachitebft_starknet_p2p_types::Ed25519Provider;
use malachitebft_sync as sync;
use malachitebft_test_mempool::Config as MempoolNetworkConfig;

use crate::actor::Host;
use crate::codec::ProtobufCodec;
use crate::config::Config;
use crate::host::{StarknetHost, StarknetParams};
use crate::mempool::network::{MempoolNetwork, MempoolNetworkRef};
use crate::mempool::{Mempool, MempoolRef};
use crate::mempool_load::{MempoolLoad, MempoolLoadRef, Params};
use crate::types::MockContext;
use crate::types::{Address, Height, PrivateKey, ValidatorSet};

pub async fn spawn_node_actor(
    cfg: Config,
    home_dir: PathBuf,
    initial_validator_set: ValidatorSet,
    private_key: PrivateKey,
    start_height: Option<Height>,
    tx_event: TxEvent<MockContext>,
    span: tracing::Span,
) -> (NodeRef, JoinHandle<()>) {
    let ctx = MockContext::new();

    let start_height = start_height.unwrap_or(Height::new(1, 1));

    let registry = SharedRegistry::global().with_moniker(cfg.moniker.as_str());
    let metrics = Metrics::register(&registry);
    let address = Address::from_public_key(private_key.public_key());
    let signing_provider = Ed25519Provider::new(private_key.clone());

    // Spawn mempool and its gossip layer
    let mempool_network = spawn_mempool_network_actor(&cfg, &private_key, &registry, &span).await;
    let mempool = spawn_mempool_actor(mempool_network, &cfg.mempool, &span).await;
    let mempool_load = spawn_mempool_load_actor(&cfg.mempool.load, mempool.clone(), &span).await;

    // Spawn consensus gossip
    let network = spawn_network_actor(&cfg, &private_key, &registry, &span).await;

    // Spawn the host actor
    let host = spawn_host_actor(
        &home_dir,
        &cfg,
        &address,
        &private_key,
        &initial_validator_set,
        mempool,
        mempool_load,
        network.clone(),
        metrics.clone(),
        &span,
    )
    .await;

    let sync = spawn_sync_actor(
        ctx,
        network.clone(),
        host.clone(),
        &cfg.value_sync,
        &registry,
        &span,
    )
    .await;

    let wal = spawn_wal_actor(&ctx, ProtobufCodec, &home_dir, &registry, &span).await;

    // Spawn consensus
    let consensus = spawn_consensus_actor(
        start_height,
        initial_validator_set,
        address,
        ctx,
        cfg,
        signing_provider,
        network.clone(),
        host.clone(),
        wal.clone(),
        sync.clone(),
        metrics,
        tx_event,
        &span,
    )
    .await;

    // Spawn the node actor
    let node = Node::new(ctx, network, consensus, wal, sync, host, span);

    let (actor_ref, handle) = node.spawn().await.unwrap();

    (actor_ref, handle)
}

async fn spawn_wal_actor(
    ctx: &MockContext,
    codec: ProtobufCodec,
    home_dir: &Path,
    registry: &SharedRegistry,
    span: &tracing::Span,
) -> WalRef<MockContext> {
    let wal_dir = home_dir.join("wal");
    std::fs::create_dir_all(&wal_dir).unwrap();
    let wal_file = wal_dir.join("consensus.wal");

    Wal::spawn(ctx, codec, wal_file, registry.clone(), span.clone())
        .await
        .unwrap()
}

async fn spawn_sync_actor(
    ctx: MockContext,
    network: NetworkRef<MockContext>,
    host: HostRef<MockContext>,
    config: &ValueSyncConfig,
    registry: &SharedRegistry,
    span: &tracing::Span,
) -> Option<SyncRef<MockContext>> {
    if !config.enabled {
        return None;
    }

    let params = SyncParams {
        status_update_interval: config.status_update_interval,
        request_timeout: config.request_timeout,
    };

    let metrics = sync::Metrics::register(registry);
    let actor_ref = Sync::spawn(ctx, network, host, params, metrics, span.clone())
        .await
        .unwrap();

    Some(actor_ref)
}

#[allow(clippy::too_many_arguments)]
async fn spawn_consensus_actor(
    initial_height: Height,
    initial_validator_set: ValidatorSet,
    address: Address,
    ctx: MockContext,
    cfg: Config,
    signing_provider: Ed25519Provider,
    network: NetworkRef<MockContext>,
    host: HostRef<MockContext>,
    wal: WalRef<MockContext>,
    sync: Option<SyncRef<MockContext>>,
    metrics: Metrics,
    tx_event: TxEvent<MockContext>,
    span: &tracing::Span,
) -> ConsensusRef<MockContext> {
    let consensus_params = ConsensusParams {
        initial_height,
        initial_validator_set,
        address,
        threshold_params: Default::default(),
        value_payload: ValuePayload::PartsOnly,
    };

    Consensus::spawn(
        ctx,
        consensus_params,
        cfg.consensus.timeouts,
        Box::new(signing_provider),
        network,
        host,
        wal,
        sync,
        metrics,
        tx_event,
        span.clone(),
    )
    .await
    .unwrap()
}

async fn spawn_network_actor(
    cfg: &Config,
    private_key: &PrivateKey,
    registry: &SharedRegistry,
    span: &tracing::Span,
) -> NetworkRef<MockContext> {
    use malachitebft_network as gossip;

    let bootstrap_protocol = match cfg.consensus.p2p.discovery.bootstrap_protocol {
        config::BootstrapProtocol::Kademlia => gossip::BootstrapProtocol::Kademlia,
        config::BootstrapProtocol::Full => gossip::BootstrapProtocol::Full,
    };

    let selector = match cfg.consensus.p2p.discovery.selector {
        config::Selector::Kademlia => gossip::Selector::Kademlia,
        config::Selector::Random => gossip::Selector::Random,
    };

    let config_gossip = gossip::Config {
        listen_addr: cfg.consensus.p2p.listen_addr.clone(),
        persistent_peers: cfg.consensus.p2p.persistent_peers.clone(),
        discovery: gossip::DiscoveryConfig {
            enabled: cfg.consensus.p2p.discovery.enabled,
            bootstrap_protocol,
            selector,
            num_outbound_peers: cfg.consensus.p2p.discovery.num_outbound_peers,
            num_inbound_peers: cfg.consensus.p2p.discovery.num_inbound_peers,
            ephemeral_connection_timeout: cfg.consensus.p2p.discovery.ephemeral_connection_timeout,
            ..Default::default()
        },
        idle_connection_timeout: Duration::from_secs(15 * 60),
        transport: gossip::TransportProtocol::from_multiaddr(&cfg.consensus.p2p.listen_addr)
            .unwrap_or_else(|| {
                panic!(
                    "No valid transport protocol found in listen address: {}",
                    cfg.consensus.p2p.listen_addr
                )
            }),
        pubsub_protocol: match cfg.consensus.p2p.protocol {
            config::PubSubProtocol::GossipSub(_) => gossip::PubSubProtocol::GossipSub,
            config::PubSubProtocol::Broadcast => gossip::PubSubProtocol::Broadcast,
        },
        gossipsub: match cfg.consensus.p2p.protocol {
            config::PubSubProtocol::GossipSub(config) => gossip::GossipSubConfig {
                mesh_n: config.mesh_n(),
                mesh_n_high: config.mesh_n_high(),
                mesh_n_low: config.mesh_n_low(),
                mesh_outbound_min: config.mesh_outbound_min(),
            },
            config::PubSubProtocol::Broadcast => gossip::GossipSubConfig::default(),
        },
        rpc_max_size: cfg.consensus.p2p.rpc_max_size.as_u64() as usize,
        pubsub_max_size: cfg.consensus.p2p.pubsub_max_size.as_u64() as usize,
        enable_sync: true,
    };

    let keypair = make_keypair(private_key);
    let codec = ProtobufCodec;

    Network::spawn(
        keypair,
        config_gossip,
        registry.clone(),
        codec,
        span.clone(),
    )
    .await
    .unwrap()
}

fn make_keypair(pk: &PrivateKey) -> Keypair {
    Keypair::ed25519_from_bytes(pk.inner().to_bytes()).unwrap()
}

async fn spawn_mempool_actor(
    mempool_network: MempoolNetworkRef,
    mempool_config: &MempoolConfig,
    span: &tracing::Span,
) -> MempoolRef {
    Mempool::spawn(
        mempool_network,
        mempool_config.gossip_batch_size,
        mempool_config.max_tx_count,
        span.clone(),
    )
    .await
    .unwrap()
}

async fn spawn_mempool_load_actor(
    mempool_load_config: &MempoolLoadConfig,
    mempool: MempoolRef,
    span: &tracing::Span,
) -> MempoolLoadRef {
    MempoolLoad::spawn(
        Params {
            load_type: mempool_load_config.load_type.clone(),
        },
        mempool,
        span.clone(),
    )
    .await
    .unwrap()
}

async fn spawn_mempool_network_actor(
    cfg: &Config,
    private_key: &PrivateKey,
    registry: &SharedRegistry,
    span: &tracing::Span,
) -> MempoolNetworkRef {
    let keypair = make_keypair(private_key);

    let config = MempoolNetworkConfig {
        listen_addr: cfg.mempool.p2p.listen_addr.clone(),
        persistent_peers: cfg.mempool.p2p.persistent_peers.clone(),
        idle_connection_timeout: Duration::from_secs(15 * 60),
    };

    MempoolNetwork::spawn(keypair, config, registry.clone(), span.clone())
        .await
        .unwrap()
}

#[allow(clippy::too_many_arguments)]
async fn spawn_host_actor(
    home_dir: &Path,
    cfg: &Config,
    address: &Address,
    private_key: &PrivateKey,
    initial_validator_set: &ValidatorSet,
    mempool: MempoolRef,
    mempool_load: MempoolLoadRef,
    network: NetworkRef<MockContext>,
    metrics: Metrics,
    span: &tracing::Span,
) -> HostRef<MockContext> {
    if cfg.consensus.value_payload != config::ValuePayload::PartsOnly {
        warn!(
            "`value_payload` must be set to `PartsOnly` for Starknet app, ignoring current configuration `{:?}`",
            cfg.consensus.value_payload
        );
    }

    let mock_params = StarknetParams {
        max_block_size: cfg.test.max_block_size,
        txs_per_part: cfg.test.txs_per_part,
        time_allowance_factor: cfg.test.time_allowance_factor,
        exec_time_per_tx: cfg.test.exec_time_per_tx,
        max_retain_blocks: cfg.test.max_retain_blocks,
        stable_block_times: cfg.test.stable_block_times,
    };

    let mock_host = StarknetHost::new(
        mock_params,
        mempool.clone(),
        mempool_load.clone(),
        *address,
        private_key.clone(),
        initial_validator_set.clone(),
    );

    Host::spawn(
        home_dir.to_owned(),
        mock_host,
        mempool,
        mempool_load,
        network,
        metrics,
        span.clone(),
    )
    .await
    .unwrap()
}

```
---
### `starknet/host/src/streaming.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
// When inserting part in a map, stream tries to connect all received parts in the right order,
// starting from beginning and emits parts sequence chunks  when it succeeds
// If it can't connect part, it buffers it
// E.g. buffered: 1 3 7
// part 0 (first) arrives -> 0 and 1 are emitted
// 4 arrives -> gets buffered
// 2 arrives -> 2, 3 and 4 are emitted

// `insert` returns connected sequence of parts if any is emitted

// Emitted parts are stored and simulated (if it is tx)
// (this is done inside `actor::on_received_proposal_part`)
// When finish part is stored, proposal value is built from all of them
use std::cmp::Ordering;
use std::collections::{BTreeMap, BinaryHeap, HashSet};
use std::fmt::Debug;

use derive_where::derive_where;

use malachitebft_core_consensus::PeerId;
use malachitebft_core_types::Round;
use malachitebft_engine::util::streaming::{Sequence, StreamId, StreamMessage};

use crate::types::{Address, Height, ProposalInit, ProposalPart};

/// Wraps a [`StreamMessage`] to implement custom ordering for a [`BinaryHeap`].
///
/// The default `BinaryHeap` is a max-heap, so we reverse the ordering
/// by implementing `Ord` in reverse to make it a min-heap, which suits the purpose of efficiently
/// providing available proposal part with smallest sequence number.
#[derive(Debug)]
pub struct MinSeq<T>(pub StreamMessage<T>);

impl<T> PartialEq for MinSeq<T> {
    fn eq(&self, other: &Self) -> bool {
        self.0.sequence == other.0.sequence
    }
}

impl<T> Eq for MinSeq<T> {}

impl<T> Ord for MinSeq<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        other.0.sequence.cmp(&self.0.sequence)
    }
}

impl<T> PartialOrd for MinSeq<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

#[derive(Debug)]
pub struct MinHeap<T>(pub BinaryHeap<MinSeq<T>>);

impl<T> Default for MinHeap<T> {
    fn default() -> Self {
        Self(BinaryHeap::new())
    }
}

impl<T> MinHeap<T> {
    pub fn push(&mut self, msg: StreamMessage<T>) {
        self.0.push(MinSeq(msg));
    }

    pub fn pop(&mut self) -> Option<StreamMessage<T>> {
        self.0.pop().map(|msg| msg.0)
    }

    fn peek(&self) -> Option<&StreamMessage<T>> {
        self.0.peek().map(|msg| &msg.0)
    }
}
#[derive(Debug)]
#[derive_where(Default)]
pub struct StreamState<T> {
    pub buffer: MinHeap<T>,
    pub init_info: Option<ProposalInit>,
    pub seen_sequences: HashSet<Sequence>,
    pub next_sequence: Sequence,
    pub total_messages: usize,
    pub fin_received: bool,
    pub emitted_messages: usize,
}

impl<T> StreamState<T> {
    fn has_emitted_all_messages(&self) -> bool {
        self.fin_received && self.emitted_messages == self.total_messages
    }

    fn emit(&mut self, msg: StreamMessage<T>, to_emit: &mut Vec<T>) {
        if let Some(data) = msg.content.into_data() {
            to_emit.push(data);
        }

        self.next_sequence = msg.sequence + 1;
        self.emitted_messages += 1;
    }

    // Emits all buffered successive parts if they are next in sequence
    fn emit_eligible_messages(&mut self, to_emit: &mut Vec<T>) {
        while let Some(msg) = self.buffer.peek() {
            if msg.sequence == self.next_sequence {
                let msg = self.buffer.pop().expect("peeked element should exist");
                self.emit(msg, to_emit);
            } else {
                break;
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ProposalParts {
    pub height: Height,
    pub round: Round,
    pub proposer: Address,
    pub parts: Vec<ProposalPart>,
}

#[derive(Default)]
pub struct PartStreamsMap {
    pub streams: BTreeMap<(PeerId, StreamId), StreamState<ProposalPart>>,
}

impl PartStreamsMap {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn insert(
        &mut self,
        peer_id: PeerId,
        msg: StreamMessage<ProposalPart>,
    ) -> Option<ProposalParts> {
        let stream_id = msg.stream_id.clone();
        let state = self
            .streams
            .entry((peer_id, stream_id.clone()))
            .or_default();

        if !state.seen_sequences.insert(msg.sequence) {
            // We have already seen a message with this sequence number.
            return None;
        }

        let result = if msg.is_first() {
            Self::insert_first(state, msg)
        } else {
            Self::insert_other(state, msg)
        };

        if state.has_emitted_all_messages() {
            self.streams.remove(&(peer_id, stream_id));
        }

        result
    }

    fn insert_first(
        state: &mut StreamState<ProposalPart>,
        msg: StreamMessage<ProposalPart>,
    ) -> Option<ProposalParts> {
        state.init_info = msg.content.as_data().and_then(|p| p.as_init()).cloned();

        let mut to_emit = Vec::with_capacity(1);
        state.emit(msg, &mut to_emit);
        state.emit_eligible_messages(&mut to_emit);

        let init_info = state.init_info.as_ref().unwrap();

        Some(ProposalParts {
            height: init_info.height,
            round: init_info.round,
            proposer: init_info.proposer,
            parts: to_emit,
        })
    }

    fn insert_other(
        state: &mut StreamState<ProposalPart>,
        msg: StreamMessage<ProposalPart>,
    ) -> Option<ProposalParts> {
        if msg.is_fin() {
            state.fin_received = true;
            state.total_messages = msg.sequence as usize + 1;
        }

        state.buffer.push(msg);

        let mut to_emit = vec![];
        state.emit_eligible_messages(&mut to_emit);

        if to_emit.is_empty() {
            return None;
        }

        let init_info = state.init_info.as_ref().unwrap();

        Some(ProposalParts {
            height: init_info.height,
            round: init_info.round,
            proposer: init_info.proposer,
            parts: to_emit,
        })
    }
}

```
---
### `starknet/p2p-proto/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-starknet-p2p-proto"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[dependencies]
prost.workspace = true

[build-dependencies]
prost-build.workspace = true
protox.workspace = true

[lints]
workspace = true

```
---
### `starknet/p2p-proto/build.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let protos = &[
        "./proto/sync.proto",
        "./proto/p2p/proto/common.proto",
        "./proto/p2p/proto/transaction.proto",
        "./proto/p2p/proto/consensus/consensus.proto",
        "./proto/p2p/proto/consensus/liveness.proto",
    ];

    for proto in protos {
        println!("cargo:rerun-if-changed={proto}");
    }

    let fds = protox::compile(protos, ["./proto"])?;

    let mut config = prost_build::Config::new();
    config.bytes(["."]);
    config.enable_type_names();
    config.default_package_filename("p2p");
    config.compile_fds(fds)?;

    Ok(())
}

```
---
### `starknet/p2p-proto/export-proto.sh`
*2025-05-18 23:58:49 | 1 KB*
```bash
#!/usr/bin/env bash

SCRIPT_PATH="$(dirname "$(realpath "$0")")"

ref="72dda96ebb88492581b1bb2591fd2314"
output="$SCRIPT_PATH/proto"

echo "Exporting proto files from 'buf.build/romac/starknet-p2p:$ref' to '$output'..."
buf export -o "$output" "buf.build/romac/starknet-p2p:$ref"

```
---
### `starknet/p2p-proto/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
#![allow(clippy::large_enum_variant)]

include!(concat!(env!("OUT_DIR"), "/p2p.rs"));

pub mod sync {
    include!(concat!(env!("OUT_DIR"), "/sync.rs"));
}

// pub mod certificate {
//     include!(concat!(env!("OUT_DIR"), "/certificate.rs"));
// }

impl From<Uint128> for u128 {
    fn from(value: Uint128) -> Self {
        (value.low as u128) | ((value.high as u128) << 64)
    }
}

impl From<u128> for Uint128 {
    fn from(value: u128) -> Self {
        Self {
            low: value as u64,
            high: (value >> 64) as u64,
        }
    }
}

```
---
### `starknet/p2p-types/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-starknet-p2p-types"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[dependencies]
malachitebft-core-types.workspace = true
malachitebft-proto.workspace = true
malachitebft-starknet-p2p-proto.workspace = true
malachitebft-signing-ed25519 = { workspace = true, features = ["serde", "rand"] }

starknet-core.workspace = true
starknet-crypto.workspace = true

bytes.workspace = true
rand.workspace = true
serde.workspace = true
sha3.workspace = true

[lints]
workspace = true

```
---
### `starknet/p2p-types/src/address.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use bytes::Bytes;
use core::fmt;
use serde::{Deserialize, Serialize};

use malachitebft_proto::{Error as ProtoError, Protobuf};
use malachitebft_starknet_p2p_proto as p2p_proto;

use crate::PublicKey;

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(transparent)]
pub struct Address(PublicKey);

impl Address {
    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn new(bytes: [u8; 32]) -> Self {
        Self::from_public_key(PublicKey::from_bytes(bytes))
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn from_public_key(public_key: PublicKey) -> Self {
        Self(public_key)
    }
}

impl fmt::Display for Address {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for byte in self.0.as_bytes().iter() {
            write!(f, "{:02X}", byte)?;
        }
        Ok(())
    }
}

impl fmt::Debug for Address {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Address({})", self)
    }
}

impl malachitebft_core_types::Address for Address {}

impl Protobuf for Address {
    type Proto = p2p_proto::Address;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        if proto.elements.len() != 32 {
            return Err(ProtoError::Other(format!(
                "Invalid address length: expected 32, got {}",
                proto.elements.len()
            )));
        }

        let mut bytes = [0; 32];
        bytes.copy_from_slice(&proto.elements);
        Ok(Address::new(bytes))
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(p2p_proto::Address {
            elements: Bytes::copy_from_slice(self.0.as_bytes().as_slice()),
        })
    }
}

```
---
### `starknet/p2p-types/src/block.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use crate::{BlockHash, Height, TransactionBatch};

use malachitebft_proto::{Error as ProtoError, Protobuf};
use malachitebft_starknet_p2p_proto as proto;

#[derive(Clone, Debug)]
pub struct Block {
    pub height: Height,
    pub transactions: TransactionBatch,
    pub block_hash: BlockHash,
}

impl Protobuf for Block {
    type Proto = proto::sync::Block;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        let transactions = proto
            .transactions
            .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("transactions"))?;

        let block_hash = proto
            .block_hash
            .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("block_hash"))?;

        Ok(Self {
            height: Height::new(proto.block_number, proto.fork_id),
            transactions: TransactionBatch::from_proto(transactions)?,
            block_hash: BlockHash::from_proto(block_hash)?,
        })
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(Self::Proto {
            block_number: self.height.block_number,
            fork_id: self.height.fork_id,
            transactions: Some(self.transactions.to_proto()?),
            block_hash: Some(self.block_hash.to_proto()?),
        })
    }
}

```
---
### `starknet/p2p-types/src/block_info.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use malachitebft_proto::{Error as ProtoError, Protobuf};
use malachitebft_starknet_p2p_proto::{self as p2p_proto};

use crate::proposal_commitment::L1DataAvailabilityMode;
use crate::{Address, Height};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct BlockInfo {
    pub height: Height,
    pub builder: Address,
    pub timestamp: u64,
    pub l1_gas_price_wei: u128,
    pub l1_data_gas_price_wei: u128,
    pub l2_gas_price_fri: u128,
    pub eth_to_strk_rate: u128,
    pub l1_da_mode: L1DataAvailabilityMode,
}

impl Protobuf for BlockInfo {
    type Proto = p2p_proto::BlockInfo;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        Ok(Self {
            height: Height::new(proto.block_number, proto.fork_id),
            builder: Address::from_proto(
                proto
                    .builder
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("builder"))?,
            )?,
            timestamp: proto.timestamp,
            l1_gas_price_wei: proto
                .l1_gas_price_wei
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l1_gas_price_wei"))?
                .into(),
            l1_data_gas_price_wei: proto
                .l1_data_gas_price_wei
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l1_data_gas_price_wei"))?
                .into(),
            l2_gas_price_fri: proto
                .l2_gas_price_fri
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l2_gas_price_fri"))?
                .into(),
            eth_to_strk_rate: proto
                .eth_to_strk_rate
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("eth_to_strk_rate"))?
                .into(),
            l1_da_mode: L1DataAvailabilityMode::from_proto(proto.l1_da_mode)?,
        })
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(Self::Proto {
            block_number: self.height.block_number,
            fork_id: self.height.fork_id,
            builder: Some(self.builder.to_proto()?),
            timestamp: self.timestamp,
            l2_gas_price_fri: Some(self.l2_gas_price_fri.into()),
            l1_gas_price_wei: Some(self.l1_gas_price_wei.into()),
            l1_data_gas_price_wei: Some(self.l1_data_gas_price_wei.into()),
            eth_to_strk_rate: Some(self.eth_to_strk_rate.into()),
            l1_da_mode: self.l1_da_mode.to_proto()?,
        })
    }
}

```
---
### `starknet/p2p-types/src/block_proof.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use bytes::Bytes;
use malachitebft_proto as proto;
use malachitebft_starknet_p2p_proto as p2p_proto;

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct BlockProof {
    pub bytes: Vec<Bytes>,
}

impl BlockProof {
    pub fn new(bytes: Vec<Bytes>) -> Self {
        Self { bytes }
    }
}

impl proto::Protobuf for BlockProof {
    type Proto = p2p_proto::BlockProof;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, proto::Error> {
        Ok(Self { bytes: proto.proof })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, proto::Error> {
        Ok(Self::Proto {
            proof: self.bytes.clone(),
        })
    }
}

```
---
### `starknet/p2p-types/src/context/impls.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use malachitebft_core_types::{
    self as common, NilOrVal, Round, SignedExtension, VoteType, VotingPower,
};

use crate::{
    Address, Hash, Height, MockContext, PartType, Proposal, ProposalPart, PublicKey, Validator,
    ValidatorSet, Vote,
};

impl common::ProposalPart<MockContext> for ProposalPart {
    fn is_first(&self) -> bool {
        self.part_type() == PartType::Init
    }

    fn is_last(&self) -> bool {
        self.part_type() == PartType::Fin
    }
}

impl common::Proposal<MockContext> for Proposal {
    fn height(&self) -> Height {
        self.height
    }

    fn round(&self) -> Round {
        self.round
    }

    fn value(&self) -> &Hash {
        &self.value_id
    }

    fn take_value(self) -> Hash {
        self.value_id
    }

    fn pol_round(&self) -> Round {
        self.pol_round
    }

    fn validator_address(&self) -> &Address {
        &self.proposer
    }
}

impl common::Vote<MockContext> for Vote {
    fn height(&self) -> Height {
        self.height
    }

    fn round(&self) -> Round {
        self.round
    }

    fn value(&self) -> &NilOrVal<Hash> {
        &self.block_hash
    }

    fn take_value(self) -> NilOrVal<Hash> {
        self.block_hash
    }

    fn vote_type(&self) -> VoteType {
        self.vote_type
    }

    fn validator_address(&self) -> &Address {
        &self.voter
    }

    fn extension(&self) -> Option<&SignedExtension<MockContext>> {
        None
    }

    fn extend(self, _extension: SignedExtension<MockContext>) -> Self {
        self
    }

    fn take_extension(&mut self) -> Option<SignedExtension<MockContext>> {
        None
    }
}

impl common::ValidatorSet<MockContext> for ValidatorSet {
    fn count(&self) -> usize {
        self.validators.len()
    }

    fn total_voting_power(&self) -> VotingPower {
        self.total_voting_power()
    }

    fn get_by_address(&self, address: &Address) -> Option<&Validator> {
        self.get_by_address(address)
    }

    fn get_by_index(&self, index: usize) -> Option<&Validator> {
        self.validators.get(index)
    }
}

impl common::Validator<MockContext> for Validator {
    fn address(&self) -> &Address {
        &self.address
    }

    fn public_key(&self) -> &PublicKey {
        &self.public_key
    }

    fn voting_power(&self) -> VotingPower {
        self.voting_power
    }
}

```
---
### `starknet/p2p-types/src/context.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use bytes::Bytes;

use malachitebft_core_types::{Context, NilOrVal, Round, ValidatorSet as _};

use crate::{
    Address, Ed25519, Hash, Height, Proposal, ProposalPart, Validator, ValidatorSet, Vote,
};

mod impls;

#[derive(Copy, Clone, Debug, Default)]
pub struct MockContext;

impl MockContext {
    pub fn new() -> Self {
        Self
    }
}

impl Context for MockContext {
    type Address = Address;
    type ProposalPart = ProposalPart;
    type Height = Height;
    type Proposal = Proposal;
    type ValidatorSet = ValidatorSet;
    type Validator = Validator;
    type Value = Hash;
    type Vote = Vote;
    type Extension = Bytes;
    type SigningScheme = Ed25519;

    fn select_proposer<'a>(
        &self,
        validator_set: &'a Self::ValidatorSet,
        height: Self::Height,
        round: Round,
    ) -> &'a Self::Validator {
        assert!(validator_set.count() > 0);
        assert!(round != Round::Nil && round.as_i64() >= 0);

        let proposer_index = {
            let height = height.as_u64() as usize;
            let round = round.as_i64() as usize;

            (height - 1 + round) % validator_set.count()
        };

        validator_set
            .get_by_index(proposer_index)
            .expect("proposer_index is valid")
    }

    fn new_proposal(
        &self,
        height: Height,
        round: Round,
        value_id: Hash,
        pol_round: Round,
        address: Address,
    ) -> Proposal {
        Proposal::new(height, round, value_id, pol_round, address)
    }

    fn new_prevote(
        &self,
        height: Height,
        round: Round,
        value_id: NilOrVal<Hash>,
        address: Address,
    ) -> Vote {
        Vote::new_prevote(height, round, value_id, address)
    }

    fn new_precommit(
        &self,
        height: Height,
        round: Round,
        value_id: NilOrVal<Hash>,
        address: Address,
    ) -> Vote {
        Vote::new_precommit(height, round, value_id, address)
    }
}

```
---
### `starknet/p2p-types/src/felt.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use bytes::Bytes;
use malachitebft_proto::Error;
use malachitebft_starknet_p2p_proto::Felt252;

pub type Felt = starknet_crypto::Felt;

pub trait FeltExt: Sized {
    fn from_proto(proto: Felt252) -> Result<Self, Error>;
    fn to_proto(&self) -> Result<Felt252, Error>;
}

impl FeltExt for Felt {
    fn from_proto(proto: Felt252) -> Result<Self, Error> {
        let mut felt = [0; 32];
        felt.copy_from_slice(&proto.elements);
        Ok(Self::from_bytes_be(&felt))
    }

    fn to_proto(&self) -> Result<Felt252, Error> {
        Ok(Felt252 {
            elements: Bytes::copy_from_slice(&self.to_bytes_be()),
        })
    }
}

```
---
### `starknet/p2p-types/src/hash.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use core::{fmt, str};

use bytes::Bytes;
use serde::{Deserialize, Serialize};

use malachitebft_proto as proto;
use malachitebft_starknet_p2p_proto as p2p_proto;
use starknet_core::types::Hash256;

use crate::Felt;

pub type MessageHash = Hash;
pub type BlockHash = Hash;

impl malachitebft_core_types::Value for BlockHash {
    type Id = BlockHash;

    fn id(&self) -> Self::Id {
        *self
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(transparent)]
pub struct Hash(Hash256);

impl Hash {
    pub const fn new(bytes: [u8; 32]) -> Self {
        Self(Hash256::from_bytes(bytes))
    }

    pub fn as_bytes(&self) -> &[u8; 32] {
        self.0.as_bytes()
    }

    pub fn as_felt(&self) -> Felt {
        self.0.try_into().unwrap()
    }

    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self) -> usize {
        self.as_bytes().len()
    }
}

impl PartialOrd for Hash {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Hash {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        self.as_bytes().cmp(other.as_bytes())
    }
}

impl proto::Protobuf for Hash {
    type Proto = p2p_proto::Hash;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, proto::Error> {
        Ok(Self::new(proto.elements.as_ref().try_into().map_err(
            |_| proto::Error::Other("Invalid hash length".to_string()),
        )?))
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, proto::Error> {
        Ok(p2p_proto::Hash {
            elements: Bytes::copy_from_slice(self.as_bytes().as_ref()),
        })
    }
}

impl fmt::Display for Hash {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

impl fmt::Debug for Hash {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.0, f)
    }
}

impl str::FromStr for Hash {
    type Err = Box<dyn core::error::Error>;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let hash = str::FromStr::from_str(s)?;
        Ok(Self(hash))
    }
}

```
---
### `starknet/p2p-types/src/height.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt;

/// A blockchain height
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Height {
    pub block_number: u64,
    pub fork_id: u64,
}

impl Height {
    pub const fn new(block_number: u64, fork_id: u64) -> Self {
        Self {
            block_number,
            fork_id,
        }
    }

    pub const fn as_u64(&self) -> u64 {
        self.block_number
    }

    pub const fn increment(&self) -> Self {
        self.increment_by(1)
    }

    pub const fn increment_by(&self, n: u64) -> Self {
        Self {
            block_number: self.block_number + n,
            fork_id: self.fork_id,
        }
    }

    pub fn decrement(&self) -> Option<Self> {
        self.block_number.checked_sub(1).map(|block_number| Self {
            block_number,
            fork_id: self.fork_id,
        })
    }
}

impl fmt::Display for Height {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.block_number.fmt(f)
    }
}

impl malachitebft_core_types::Height for Height {
    const ZERO: Self = Self::new(0, 0);
    const INITIAL: Self = Self::new(1, 0);

    fn increment_by(&self, n: u64) -> Self {
        Self {
            block_number: self.block_number + n,
            fork_id: self.fork_id,
        }
    }

    fn decrement_by(&self, n: u64) -> Option<Self> {
        Some(Self {
            block_number: self.block_number.saturating_sub(n),
            fork_id: self.fork_id,
        })
    }

    fn as_u64(&self) -> u64 {
        self.block_number
    }
}

impl Default for Height {
    fn default() -> Self {
        malachitebft_core_types::Height::ZERO
    }
}

```
---
### `starknet/p2p-types/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

mod context;
pub use context::MockContext;

mod felt;
pub use felt::{Felt, FeltExt};

mod address;
pub use address::Address;

mod height;
pub use height::Height;

mod vote;
pub use vote::Vote;

mod transaction;
pub use transaction::{Transaction, TransactionBatch};

mod validator;
pub use validator::Validator;

mod validator_set;
pub use validator_set::ValidatorSet;

mod proposal;
pub use proposal::Proposal;

mod proposal_commitment;
pub use proposal_commitment::{L1DataAvailabilityMode, ProposalCommitment};

mod proposal_part;
pub use proposal_part::{PartType, ProposalFin, ProposalInit, ProposalPart};

mod block;
pub use block::Block;

mod block_info;
pub use block_info::BlockInfo;

mod block_proof;
pub use block_proof::BlockProof;

mod hash;
pub use hash::{BlockHash, Hash, MessageHash};

mod streaming;
pub use streaming::{StreamContent, StreamMessage};

mod signing;
pub use signing::{Ed25519, Ed25519Provider, PrivateKey, PublicKey, Signature};

```
---
### `starknet/p2p-types/src/proposal.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
// use bytes::Bytes;
use malachitebft_core_types::Round;
// use malachitebft_proto as proto;
// use malachitebft_starknet_p2p_proto as p2p_proto;

use crate::{Address, Hash, Height};

/// A proposal for a value in a round
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Proposal {
    pub height: Height,
    pub round: Round,
    pub value_id: Hash,
    pub pol_round: Round,
    pub proposer: Address,
}

impl Proposal {
    pub fn new(
        height: Height,
        round: Round,
        value_id: Hash,
        pol_round: Round,
        proposer: Address,
    ) -> Self {
        Self {
            height,
            round,
            value_id,
            pol_round,
            proposer,
        }
    }
}

```
---
### `starknet/p2p-types/src/proposal_commitment.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use malachitebft_proto::{Error as ProtoError, Protobuf};
use malachitebft_starknet_p2p_proto::{self as p2p_proto};

use crate::felt::FeltExt;
use crate::{Address, Felt, Hash, Height};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ProposalCommitment {
    pub height: Height,
    pub parent_commitment: Hash,
    pub builder: Address,
    pub timestamp: u64,
    pub protocol_version: String,
    pub old_state_root: Hash,
    pub state_diff_commitment: Hash,
    pub transaction_commitment: Hash,
    pub event_commitment: Hash,
    pub receipt_commitment: Hash,
    pub concatenated_counts: Felt,
    pub l1_gas_price_fri: u128,
    pub l1_data_gas_price_fri: u128,
    pub l2_gas_price_fri: u128,
    pub l2_gas_used: u128,
    pub l1_da_mode: L1DataAvailabilityMode,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum L1DataAvailabilityMode {
    Calldata = 0,
    Blob = 1,
}

impl Protobuf for L1DataAvailabilityMode {
    type Proto = i32;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        let proto = p2p_proto::L1DataAvailabilityMode::try_from(proto).map_err(|_| {
            ProtoError::invalid_data::<Self::Proto>("invalid value for L1DataAvailabilityMode")
        })?;

        match proto {
            p2p_proto::L1DataAvailabilityMode::Calldata => Ok(Self::Calldata),
            p2p_proto::L1DataAvailabilityMode::Blob => Ok(Self::Blob),
        }
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        match self {
            Self::Calldata => Ok(p2p_proto::L1DataAvailabilityMode::Calldata as i32),
            Self::Blob => Ok(p2p_proto::L1DataAvailabilityMode::Blob as i32),
        }
    }
}

impl Protobuf for ProposalCommitment {
    type Proto = p2p_proto::ProposalCommitment;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        Ok(Self {
            height: Height::new(proto.block_number, proto.fork_id),
            parent_commitment: Hash::from_proto(
                proto
                    .parent_commitment
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("parent_commitment"))?,
            )?,
            builder: Address::from_proto(
                proto
                    .builder
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("builder"))?,
            )?,
            timestamp: proto.timestamp,
            protocol_version: proto.protocol_version,
            old_state_root: Hash::from_proto(
                proto
                    .old_state_root
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("old_state_root"))?,
            )?,
            state_diff_commitment: Hash::from_proto(proto.state_diff_commitment.ok_or_else(
                || ProtoError::missing_field::<Self::Proto>("state_diff_commitment"),
            )?)?,
            transaction_commitment: Hash::from_proto(proto.transaction_commitment.ok_or_else(
                || ProtoError::missing_field::<Self::Proto>("transaction_commitment"),
            )?)?,
            event_commitment: Hash::from_proto(
                proto
                    .event_commitment
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("event_commitment"))?,
            )?,
            receipt_commitment: Hash::from_proto(
                proto.receipt_commitment.ok_or_else(|| {
                    ProtoError::missing_field::<Self::Proto>("receipt_commitment")
                })?,
            )?,
            concatenated_counts: Felt::from_proto(
                proto.concatenated_counts.ok_or_else(|| {
                    ProtoError::missing_field::<Self::Proto>("concatenated_counts")
                })?,
            )?,
            l1_gas_price_fri: proto
                .l1_gas_price_fri
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l1_gas_price_fri"))?
                .into(),
            l1_data_gas_price_fri: proto
                .l1_data_gas_price_fri
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l1_data_gas_price_fri"))?
                .into(),
            l2_gas_price_fri: proto
                .l2_gas_price_fri
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l2_gas_price_fri"))?
                .into(),
            l2_gas_used: proto
                .l2_gas_used
                .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("l2_gas_used"))?
                .into(),
            l1_da_mode: L1DataAvailabilityMode::from_proto(proto.l1_da_mode)?,
        })
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(Self::Proto {
            block_number: self.height.block_number,
            fork_id: self.height.fork_id,
            parent_commitment: Some(self.parent_commitment.to_proto()?),
            builder: Some(self.builder.to_proto()?),
            timestamp: self.timestamp,
            protocol_version: self.protocol_version.clone(),
            old_state_root: Some(self.old_state_root.to_proto()?),
            state_diff_commitment: Some(self.state_diff_commitment.to_proto()?),
            transaction_commitment: Some(self.transaction_commitment.to_proto()?),
            event_commitment: Some(self.event_commitment.to_proto()?),
            receipt_commitment: Some(self.receipt_commitment.to_proto()?),
            concatenated_counts: Some(self.concatenated_counts.to_proto()?),
            l1_gas_price_fri: Some(self.l1_gas_price_fri.into()),
            l1_data_gas_price_fri: Some(self.l1_data_gas_price_fri.into()),
            l2_gas_price_fri: Some(self.l2_gas_price_fri.into()),
            l2_gas_used: Some(self.l2_gas_used.into()),
            l1_da_mode: self.l1_da_mode.to_proto()?,
        })
    }
}

```
---
### `starknet/p2p-types/src/proposal_part.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use bytes::Bytes;
use malachitebft_core_types::Round;
use malachitebft_proto as proto;
use malachitebft_starknet_p2p_proto::{self as p2p_proto};

use crate::{Address, BlockInfo, Hash, Height, ProposalCommitment, TransactionBatch};

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ProposalInit {
    pub height: Height,
    pub round: Round,
    pub valid_round: Round,
    pub proposer: Address,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ProposalFin {
    pub proposal_commitment_hash: Hash,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ProposalPart {
    Init(ProposalInit),
    BlockInfo(BlockInfo),
    Transactions(TransactionBatch),
    Commitment(Box<ProposalCommitment>),
    Fin(ProposalFin),
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum PartType {
    Init,
    BlockInfo,
    Transactions,
    ProposalCommitment,
    Fin,
}

impl ProposalPart {
    pub fn part_type(&self) -> PartType {
        match self {
            Self::Init(_) => PartType::Init,
            Self::BlockInfo(_) => PartType::BlockInfo,
            Self::Transactions(_) => PartType::Transactions,
            Self::Commitment(_) => PartType::ProposalCommitment,
            Self::Fin(_) => PartType::Fin,
        }
    }

    pub fn to_sign_bytes(&self) -> Bytes {
        proto::Protobuf::to_bytes(self).unwrap()
    }

    pub fn size_bytes(&self) -> usize {
        self.to_sign_bytes().len() // TODO: Do this more efficiently
    }

    pub fn tx_count(&self) -> usize {
        match self {
            Self::Transactions(txes) => txes.len(),
            _ => 0,
        }
    }

    pub fn as_init(&self) -> Option<&ProposalInit> {
        if let Self::Init(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn as_block_info(&self) -> Option<&BlockInfo> {
        if let Self::BlockInfo(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn as_transactions(&self) -> Option<&TransactionBatch> {
        if let Self::Transactions(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn as_commitment(&self) -> Option<&ProposalCommitment> {
        if let Self::Commitment(v) = self {
            Some(v)
        } else {
            None
        }
    }

    pub fn as_fin(&self) -> Option<&ProposalFin> {
        if let Self::Fin(v) = self {
            Some(v)
        } else {
            None
        }
    }
}

impl proto::Protobuf for ProposalPart {
    type Proto = p2p_proto::ProposalPart;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, proto::Error> {
        use p2p_proto::proposal_part::Messages;

        let message = proto
            .messages
            .ok_or_else(|| proto::Error::missing_field::<Self::Proto>("messages"))?;

        Ok(match message {
            Messages::Init(init) => ProposalPart::Init(ProposalInit {
                height: Height::new(init.height, 0),
                round: Round::new(init.round),
                valid_round: init.valid_round.into(),
                proposer: Address::from_proto(
                    init.proposer
                        .ok_or_else(|| proto::Error::missing_field::<Self::Proto>("proposer"))?,
                )?,
            }),

            Messages::BlockInfo(block_info) => {
                ProposalPart::BlockInfo(BlockInfo::from_proto(block_info)?)
            }

            Messages::Transactions(txes) => {
                let transactions = TransactionBatch::from_proto(txes)?;
                ProposalPart::Transactions(transactions)
            }

            Messages::Commitment(commitment) => {
                ProposalPart::Commitment(Box::new(ProposalCommitment::from_proto(commitment)?))
            }

            Messages::Fin(fin) => ProposalPart::Fin(ProposalFin {
                proposal_commitment_hash: Hash::from_proto(fin.proposal_commitment.ok_or_else(
                    || proto::Error::missing_field::<Self::Proto>("proposal_commitment"),
                )?)?,
            }),
        })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, proto::Error> {
        use p2p_proto::proposal_part::Messages;

        let message = match self {
            ProposalPart::Init(init) => Messages::Init(p2p_proto::ProposalInit {
                height: init.height.block_number,
                round: init.round.as_u32().expect("round should not be nil"),
                valid_round: init.valid_round.as_u32(),
                proposer: Some(init.proposer.to_proto()?),
            }),
            ProposalPart::BlockInfo(block_info) => Messages::BlockInfo(block_info.to_proto()?),
            ProposalPart::Transactions(txes) => {
                Messages::Transactions(p2p_proto::TransactionBatch {
                    transactions: txes
                        .as_slice()
                        .iter()
                        .map(|tx| tx.to_proto())
                        .collect::<Result<Vec<_>, _>>()?,
                })
            }
            ProposalPart::Commitment(commitment) => Messages::Commitment(commitment.to_proto()?),
            ProposalPart::Fin(fin) => Messages::Fin(p2p_proto::ProposalFin {
                proposal_commitment: Some(fin.proposal_commitment_hash.to_proto()?),
            }),
        };

        Ok(p2p_proto::ProposalPart {
            messages: Some(message),
        })
    }
}

```
---
### `starknet/p2p-types/src/signing/provider.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use bytes::Bytes;
use starknet_core::utils::starknet_keccak;

use malachitebft_core_types::{
    CertificateError, CommitCertificate, CommitSignature, NilOrVal, SignedExtension,
    SignedProposal, SignedProposalPart, SignedVote, SigningProvider, VotingPower,
};

use crate::{
    MockContext, PrivateKey, Proposal, ProposalPart, PublicKey, Signature, Validator, Vote,
};

#[derive(Debug)]
pub struct EcdsaProvider {
    private_key: PrivateKey,
}

impl EcdsaProvider {
    pub fn new(private_key: PrivateKey) -> Self {
        Self { private_key }
    }
}

impl SigningProvider<MockContext> for EcdsaProvider {
    fn sign_vote(&self, vote: Vote) -> SignedVote<MockContext> {
        // Votes are not signed for now
        // let hash = starknet_keccak(&vote.to_sign_bytes());
        // let signature = self.private_key.sign(&hash);
        SignedVote::new(vote, Signature::dummy())
    }

    fn verify_signed_vote(
        &self,
        _vote: &Vote,
        _signature: &Signature,
        _public_key: &PublicKey,
    ) -> bool {
        // Votes are not signed for now
        true
        // let hash = starknet_keccak(&vote.to_sign_bytes());
        // public_key.verify(&hash, signature)
    }

    fn sign_proposal(&self, proposal: Proposal) -> SignedProposal<MockContext> {
        // Proposals are never sent over the network
        SignedProposal::new(proposal, Signature::dummy())
    }

    fn verify_signed_proposal(
        &self,
        _proposal: &Proposal,
        _signature: &Signature,
        _public_key: &PublicKey,
    ) -> bool {
        // Proposals are never sent over the network
        true
    }

    fn sign_proposal_part(&self, proposal_part: ProposalPart) -> SignedProposalPart<MockContext> {
        let hash = starknet_keccak(&proposal_part.to_sign_bytes());
        let signature = self.private_key.sign(&hash);
        SignedProposalPart::new(proposal_part, signature)
    }

    fn verify_signed_proposal_part(
        &self,
        proposal_part: &ProposalPart,
        signature: &Signature,
        public_key: &PublicKey,
    ) -> bool {
        let hash = starknet_keccak(&proposal_part.to_sign_bytes());
        public_key.verify(&hash, signature)
    }

    fn sign_vote_extension(&self, extension: Bytes) -> SignedExtension<MockContext> {
        let hash = starknet_keccak(extension.as_ref());
        let signature = self.private_key.sign(&hash);
        SignedExtension::new(extension, signature)
    }

    fn verify_signed_vote_extension(
        &self,
        extension: &Bytes,
        signature: &Signature,
        public_key: &PublicKey,
    ) -> bool {
        let hash = starknet_keccak(extension.as_ref());
        public_key.verify(&hash, signature)
    }

    fn verify_commit_signature(
        &self,
        certificate: &CommitCertificate<MockContext>,
        commit_sig: &CommitSignature<MockContext>,
        validator: &Validator,
    ) -> Result<VotingPower, CertificateError<MockContext>> {
        use malachitebft_core_types::Validator;

        // Reconstruct the vote that was signed
        let vote = Vote::new_precommit(
            certificate.height,
            certificate.round,
            NilOrVal::Val(certificate.value_id),
            *validator.address(),
        );

        // Verify signature
        if !self.verify_signed_vote(&vote, &commit_sig.signature, validator.public_key()) {
            return Err(CertificateError::InvalidSignature(commit_sig.clone()));
        }

        Ok(validator.voting_power())
    }
}

```
---
### `starknet/p2p-types/src/signing.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use bytes::Bytes;
use malachitebft_core_types::{
    SignedExtension, SignedProposal, SignedProposalPart, SignedVote, SigningProvider,
};

pub use malachitebft_signing_ed25519::{Ed25519, PrivateKey, PublicKey, Signature};

use crate::{MockContext, Proposal, ProposalPart, Vote};

#[derive(Debug)]
pub struct Ed25519Provider {
    private_key: PrivateKey,
}

impl Ed25519Provider {
    pub fn new(private_key: PrivateKey) -> Self {
        Self { private_key }
    }

    pub fn private_key(&self) -> &PrivateKey {
        &self.private_key
    }

    pub fn sign(&self, data: &[u8]) -> Signature {
        self.private_key.sign(data)
    }

    pub fn verify(&self, data: &[u8], signature: &Signature, public_key: &PublicKey) -> bool {
        public_key.verify(data, signature).is_ok()
    }
}

impl SigningProvider<MockContext> for Ed25519Provider {
    fn sign_vote(&self, vote: Vote) -> SignedVote<MockContext> {
        // Votes are not signed for now
        SignedVote::new(vote, Signature::test())
    }

    fn verify_signed_vote(
        &self,
        _vote: &Vote,
        _signature: &Signature,
        _public_key: &PublicKey,
    ) -> bool {
        // Votes are not signed for now
        true
    }

    fn sign_proposal(&self, proposal: Proposal) -> SignedProposal<MockContext> {
        // Proposals are never sent over the network
        SignedProposal::new(proposal, Signature::test())
    }

    fn verify_signed_proposal(
        &self,
        _proposal: &Proposal,
        _signature: &Signature,
        _public_key: &PublicKey,
    ) -> bool {
        // Proposals are never sent over the network
        true
    }

    fn sign_proposal_part(&self, proposal_part: ProposalPart) -> SignedProposalPart<MockContext> {
        // Proposal parts are not signed for now
        SignedProposalPart::new(proposal_part, Signature::test())
    }

    fn verify_signed_proposal_part(
        &self,
        _proposal_part: &ProposalPart,
        _signature: &Signature,
        _public_key: &PublicKey,
    ) -> bool {
        // Proposal parts are not signed for now
        true
    }

    fn sign_vote_extension(&self, extension: Bytes) -> SignedExtension<MockContext> {
        // Vote extensions are not enabled
        SignedExtension::new(extension, Signature::test())
    }

    fn verify_signed_vote_extension(
        &self,
        _extension: &Bytes,
        _signature: &Signature,
        _public_key: &PublicKey,
    ) -> bool {
        // Vote extensions are not enabled
        true
    }
}

```
---
### `starknet/p2p-types/src/streaming.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use bytes::Bytes;
use malachitebft_proto::Protobuf;
use malachitebft_starknet_p2p_proto as p2p_proto;

pub struct StreamMessage {
    /// Receivers identify streams by (sender, stream_id).
    /// This means each node can allocate stream_ids independently
    /// and that many streams can be sent on a single network topic.
    pub id: Bytes,

    /// Identifies the sequence of each message in the stream starting from 0.
    pub sequence: u64,

    /// The content of this stream message
    pub content: StreamContent,
}

pub enum StreamContent {
    /// Serialized content.
    Data(Bytes),
    /// Final message.
    Fin,
}

impl Protobuf for StreamMessage {
    type Proto = p2p_proto::StreamMessage;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, malachitebft_proto::Error> {
        let content = match proto
            .message
            .ok_or_else(|| malachitebft_proto::Error::missing_field::<Self::Proto>("content"))?
        {
            p2p_proto::stream_message::Message::Content(data) => StreamContent::Data(data),
            p2p_proto::stream_message::Message::Fin(_) => StreamContent::Fin,
        };

        Ok(Self {
            id: proto.stream_id,
            sequence: proto.message_id,
            content,
        })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, malachitebft_proto::Error> {
        Ok(Self::Proto {
            stream_id: self.id.clone(),
            message_id: self.sequence,
            message: match &self.content {
                StreamContent::Data(data) => {
                    Some(p2p_proto::stream_message::Message::Content(data.clone()))
                }
                StreamContent::Fin => {
                    Some(p2p_proto::stream_message::Message::Fin(p2p_proto::Fin {}))
                }
            },
        })
    }
}

```
---
### `starknet/p2p-types/src/transaction.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use core::fmt;

use bytes::Bytes;
use malachitebft_proto::{self as proto};
use malachitebft_starknet_p2p_proto as p2p_proto;

use crate::Hash;

/// Transaction
#[derive(Clone, PartialEq, Eq, Ord, PartialOrd)]
pub struct Transaction {
    data: Bytes,
    hash: Hash,
}

impl Transaction {
    /// Create a new transaction from bytes
    pub fn new(data: impl Into<Bytes>) -> Self {
        let data = data.into();
        let hash = Self::compute_hash(&data);
        Self { data, hash }
    }

    /// Get bytes from a transaction
    pub fn to_bytes(&self) -> Bytes {
        self.data.clone()
    }

    /// Get bytes from a transaction
    pub fn as_bytes(&self) -> &[u8] {
        self.data.as_ref()
    }

    /// Size of this transaction in bytes
    pub fn size_bytes(&self) -> usize {
        self.data.len()
    }

    /// Hash of this transaction
    pub fn hash(&self) -> Hash {
        self.hash
    }

    /// Compute the hash of a transaction
    ///
    /// TODO: Use hash function from Context
    pub fn compute_hash(bytes: &[u8]) -> Hash {
        use sha3::Digest;
        let mut hasher = sha3::Keccak256::new();
        hasher.update(bytes);
        Hash::new(hasher.finalize().into())
    }
}

impl fmt::Debug for Transaction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Transaction({}, {} bytes)", self.hash, self.size_bytes())
    }
}

impl proto::Protobuf for Transaction {
    type Proto = p2p_proto::ConsensusTransaction;

    fn from_proto(proto: Self::Proto) -> Result<Self, proto::Error> {
        use malachitebft_starknet_p2p_proto::consensus_transaction::Txn;

        let txn = proto
            .txn
            .ok_or_else(|| proto::Error::missing_field::<Self::Proto>("txn"))?;

        let hash = proto
            .transaction_hash
            .ok_or_else(|| proto::Error::missing_field::<Self::Proto>("transaction_hash"))?;

        match txn {
            Txn::Dummy(bytes) => Ok(Self {
                data: bytes,
                hash: Hash::from_proto(hash)?,
            }),
            _ => Err(proto::Error::invalid_data::<Self::Proto>(
                "unknown transaction type",
            )),
        }
    }

    fn to_proto(&self) -> Result<Self::Proto, proto::Error> {
        use malachitebft_starknet_p2p_proto::consensus_transaction::Txn;

        Ok(Self::Proto {
            transaction_hash: Some(self.hash.to_proto()?),
            txn: Some(Txn::Dummy(self.to_bytes())),
        })
    }
}

/// Transaction batch (used by mempool and proposal part)
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct TransactionBatch(Vec<Transaction>);

impl TransactionBatch {
    /// Create a new transaction batch
    pub fn new(txes: Vec<Transaction>) -> Self {
        TransactionBatch(txes)
    }

    /// Add a transaction to the batch
    pub fn push(&mut self, tx: Transaction) {
        self.0.push(tx);
    }

    /// Add a set of transaction to the batch
    pub fn append(&mut self, txes: TransactionBatch) {
        let mut txes1 = txes.clone();
        self.0.append(&mut txes1.0);
    }

    /// Get the number of transactions in the batch
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Whether or not the batch is empty
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    /// Get transactions from a batch
    pub fn into_vec(self) -> Vec<Transaction> {
        self.0
    }

    /// Get transactions from a batch
    pub fn to_vec(&self) -> Vec<Transaction> {
        self.0.to_vec()
    }

    /// Get transactions from a batch
    pub fn as_slice(&self) -> &[Transaction] {
        &self.0
    }

    /// The size of this batch in bytes
    pub fn size_bytes(&self) -> usize {
        self.as_slice()
            .iter()
            .map(|tx| tx.size_bytes())
            .sum::<usize>()
    }
}

impl proto::Protobuf for TransactionBatch {
    type Proto = p2p_proto::TransactionBatch;

    fn from_proto(proto: Self::Proto) -> Result<Self, proto::Error> {
        Ok(Self::new(
            proto
                .transactions
                .into_iter()
                .map(Transaction::from_proto)
                .collect::<Result<Vec<_>, _>>()?,
        ))
    }

    fn to_proto(&self) -> Result<Self::Proto, proto::Error> {
        Ok(p2p_proto::TransactionBatch {
            transactions: self
                .as_slice()
                .iter()
                .map(Transaction::to_proto)
                .collect::<Result<_, _>>()?,
        })
    }
}

```
---
### `starknet/p2p-types/src/validator.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use malachitebft_core_types::VotingPower;
use serde::{Deserialize, Serialize};

use crate::{Address, PublicKey};

/// A validator is a public key and voting power
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Validator {
    pub address: Address,
    pub public_key: PublicKey,
    pub voting_power: VotingPower,
}

impl Validator {
    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn new(public_key: PublicKey, voting_power: VotingPower) -> Self {
        Self {
            address: Address::from_public_key(public_key),
            public_key,
            voting_power,
        }
    }
}

impl PartialOrd for Validator {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Validator {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.address.cmp(&other.address)
    }
}

```
---
### `starknet/p2p-types/src/validator_set.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::sync::Arc;

use malachitebft_core_types::VotingPower;
use serde::{Deserialize, Serialize};

use crate::{Address, PublicKey, Validator};

/// A validator set contains a list of validators sorted by address.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ValidatorSet {
    pub validators: Arc<Vec<Validator>>,
}

impl ValidatorSet {
    pub fn new(validators: impl IntoIterator<Item = Validator>) -> Self {
        let mut validators: Vec<_> = validators.into_iter().collect();
        ValidatorSet::sort_validators(&mut validators);

        assert!(!validators.is_empty());

        Self {
            validators: Arc::new(validators),
        }
    }

    /// The total voting power of the validator set
    pub fn total_voting_power(&self) -> VotingPower {
        self.validators.iter().map(|v| v.voting_power).sum()
    }

    /// Get a validator by its address
    pub fn get_by_address(&self, address: &Address) -> Option<&Validator> {
        self.validators.iter().find(|v| &v.address == address)
    }

    pub fn get_by_public_key(&self, public_key: &PublicKey) -> Option<&Validator> {
        self.validators.iter().find(|v| &v.public_key == public_key)
    }

    /// In place sort and deduplication of a list of validators
    fn sort_validators(vals: &mut Vec<Validator>) {
        // Sort the validators according to the current Tendermint requirements
        use core::cmp::Reverse;

        // first by validator power descending, then by address ascending
        vals.sort_unstable_by(|v1, v2| {
            let a = (Reverse(v1.voting_power), &v1.address);
            let b = (Reverse(v2.voting_power), &v2.address);
            a.cmp(&b)
        });

        vals.dedup();
    }

    pub fn get_keys(&self) -> Vec<PublicKey> {
        self.validators.iter().map(|v| v.public_key).collect()
    }
}

impl Serialize for ValidatorSet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(Serialize)]
        struct ValidatorSet<'a> {
            validators: &'a [Validator],
        }

        let vs = ValidatorSet {
            validators: &self.validators,
        };

        vs.serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for ValidatorSet {
    fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        #[derive(Deserialize)]
        struct ValidatorSet {
            validators: Vec<Validator>,
        }

        ValidatorSet::deserialize(deserializer).map(|vs| Self::new(vs.validators))
    }
}

```
---
### `starknet/p2p-types/src/vote.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use bytes::Bytes;

use malachitebft_core_types::{NilOrVal, Round, VoteType};
use malachitebft_proto as proto;
use malachitebft_starknet_p2p_proto as p2p_proto;

use crate::{Address, BlockHash, Height};

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Vote {
    pub vote_type: VoteType,
    pub height: Height,
    pub round: Round,
    pub block_hash: NilOrVal<BlockHash>,
    pub voter: Address,
}

impl Vote {
    pub fn new_prevote(
        height: Height,
        round: Round,
        block_hash: NilOrVal<BlockHash>,
        voter: Address,
    ) -> Self {
        Self {
            vote_type: VoteType::Prevote,
            height,
            round,
            block_hash,
            voter,
        }
    }

    pub fn new_precommit(
        height: Height,
        round: Round,
        value: NilOrVal<BlockHash>,
        address: Address,
    ) -> Self {
        Self {
            vote_type: VoteType::Precommit,
            height,
            round,
            block_hash: value,
            voter: address,
        }
    }

    pub fn to_sign_bytes(&self) -> Bytes {
        malachitebft_proto::Protobuf::to_bytes(self).unwrap()
    }
}

impl proto::Protobuf for Vote {
    type Proto = p2p_proto::Vote;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, proto::Error> {
        let vote_type = proto_to_common_vote_type(proto.vote_type());

        Ok(Self {
            vote_type,
            height: Height::new(proto.block_number, proto.fork_id),
            round: Round::new(proto.round),
            block_hash: match proto.block_hash {
                Some(block_hash) => NilOrVal::Val(BlockHash::from_proto(block_hash)?),
                None => NilOrVal::Nil,
            },
            voter: Address::from_proto(
                proto
                    .voter
                    .ok_or_else(|| proto::Error::missing_field::<Self::Proto>("voter"))?,
            )?,
        })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, proto::Error> {
        Ok(Self::Proto {
            vote_type: common_to_proto_vote_type(self.vote_type).into(),
            block_number: self.height.block_number,
            fork_id: self.height.fork_id,
            round: self.round.as_u32().expect("round should not be nil"),
            block_hash: match &self.block_hash {
                NilOrVal::Nil => None,
                NilOrVal::Val(v) => Some(v.to_proto()?),
            },
            voter: Some(self.voter.to_proto()?),
        })
    }
}

fn common_to_proto_vote_type(vote_type: VoteType) -> malachitebft_starknet_p2p_proto::VoteType {
    match vote_type {
        VoteType::Prevote => p2p_proto::VoteType::Prevote,
        VoteType::Precommit => p2p_proto::VoteType::Precommit,
    }
}

fn proto_to_common_vote_type(vote_type: p2p_proto::VoteType) -> VoteType {
    match vote_type {
        p2p_proto::VoteType::Prevote => VoteType::Prevote,
        p2p_proto::VoteType::Precommit => VoteType::Precommit,
    }
}

```
---
### `starknet/test/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-starknet-test"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[dependencies]
malachitebft-engine.workspace = true
malachitebft-core-types.workspace = true
malachitebft-config.workspace = true
malachitebft-core-consensus.workspace = true
malachitebft-metrics.workspace = true
malachitebft-starknet-host.workspace = true
malachitebft-test-framework.workspace = true

async-trait.workspace = true
axum.workspace = true
bytesize.workspace = true
eyre.workspace = true
rand.workspace = true
ractor.workspace = true
serde_json.workspace = true
tokio.workspace = true
tracing.workspace = true
tracing-subscriber.workspace = true
tempfile.workspace = true

[lints]
workspace = true

```
---
### `starknet/test/mbt/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-starknet-test-mbt"
description = "Library for model-based testing of the starknet"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[dependencies]
malachitebft-core-types = { workspace = true }
malachitebft-starknet-host = { workspace = true }
malachitebft-engine = { workspace = true }
malachitebft-peer = { workspace = true }

serde = { workspace = true, features = ["derive"] }
itf = { workspace = true }
glob = { workspace = true }
multihash = { workspace = true }
bytes = { workspace = true }


[dev-dependencies]
tempfile = { version = "3.19.1" }
```
---
### `starknet/test/mbt/src/deserializers.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use crate::streaming::Message;
use serde::Deserialize;
// Quint specification has its own Option type that is treated as enum in rust
// so message has to be extracted from it and be converted to rust's Option type
#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(tag = "tag", content = "value")]
enum MessageOption {
    Some(Message),
    None,
}

pub(crate) fn quint_option_message<'de, D>(de: D) -> Result<Option<Message>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let opt = MessageOption::deserialize(de)?;
    match opt {
        MessageOption::Some(message) => Ok(Some(message)),
        MessageOption::None => Ok(None),
    }
}

```
---
### `starknet/test/mbt/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod deserializers;
pub mod streaming;
#[cfg(test)]
pub mod tests;
pub mod utils;

```
---
### `starknet/test/mbt/src/streaming.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use crate::deserializers as de;
use itf::de::{As, Integer};
use serde::Deserialize;
use std::{
    cmp::Ordering,
    collections::{BinaryHeap, HashSet},
};

pub type Sequence = i64;
pub type Payload = String;

// This and buffer struct are defined just for testing purposes so they implement and contain
// only the necessary functions and fields (e.g. push, peek, pop functions are not implemented)
#[derive(Clone, Debug, Deserialize)]
pub struct BufferRecord(#[serde(with = "As::<Integer>")] pub Sequence, pub Message);

impl PartialEq for BufferRecord {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Eq for BufferRecord {}

impl PartialOrd for BufferRecord {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

// Buffer should act as MinHeap so the ordering is reversed
impl Ord for BufferRecord {
    fn cmp(&self, other: &Self) -> Ordering {
        other.0.cmp(&self.0)
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct Buffer(pub BinaryHeap<BufferRecord>);

impl PartialEq for Buffer {
    fn eq(&self, other: &Self) -> bool {
        self.0.iter().eq(other.0.iter())
    }
}

impl Eq for Buffer {}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Hash)]
#[serde(tag = "tag")]
pub enum MessageType {
    #[serde(rename = "INIT")]
    Init,
    #[serde(rename = "DATA")]
    Data,
    #[serde(rename = "FIN")]
    Fin,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Hash)]
#[serde(rename_all = "camelCase")]
pub struct Message {
    #[serde(with = "As::<Integer>")]
    pub sequence: Sequence,
    pub msg_type: MessageType,
    pub payload: Payload,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct StreamState {
    pub buffer: Buffer,
    #[serde(deserialize_with = "de::quint_option_message")]
    pub init_message: Option<Message>,
    pub received: HashSet<Message>,
    #[serde(with = "As::<Integer>")]
    pub next_sequence: Sequence,
    #[serde(with = "As::<Integer>")]
    pub total_messages: i32,
    pub fin_received: bool,
    pub emitted: Vec<Message>,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct State {
    pub state: StreamState,
    #[serde(deserialize_with = "de::quint_option_message")]
    pub incoming_message: Option<Message>,
}

```
---
### `starknet/test/mbt/src/tests/streaming/runner.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
use std::collections::HashSet;

use super::utils;
use crate::streaming::{Message, MessageType, State as SpecificationState};
use itf::Runner as ItfRunner;
use malachitebft_engine::util::streaming::{StreamContent, StreamId, StreamMessage};
use malachitebft_peer::PeerId;
use malachitebft_starknet_host::{
    streaming::{PartStreamsMap, StreamState as StreamStateImpl},
    types::ProposalPart,
};

pub struct StreamingRunner {
    peer_id: PeerId,
    stream_id: StreamId,
    incoming_messages_pool: HashSet<Message>,
    complete_proposal_message_sequence: Vec<Message>,
}

impl StreamingRunner {
    pub fn new(peer_id: PeerId, stream_id: StreamId) -> Self {
        let complete_proposal_message_sequence = vec![
            Message {
                sequence: 0,
                msg_type: MessageType::Init,
                payload: "Init".to_string(),
            },
            Message {
                sequence: 1,
                msg_type: MessageType::Data,
                payload: "Data 1".to_string(),
            },
            Message {
                sequence: 2,
                msg_type: MessageType::Data,
                payload: "Data 2".to_string(),
            },
            Message {
                sequence: 3,
                msg_type: MessageType::Fin,
                payload: "Fin".to_string(),
            },
        ];
        let incoming_messages_pool = complete_proposal_message_sequence.iter().cloned().collect();
        Self {
            peer_id,
            stream_id,
            incoming_messages_pool,
            complete_proposal_message_sequence,
        }
    }
}

impl ItfRunner for StreamingRunner {
    type ActualState = PartStreamsMap;

    // There is no result in the model, so it is empty
    type Result = ();

    type ExpectedState = SpecificationState;

    type Error = ();

    fn init(&mut self, expected: &Self::ExpectedState) -> Result<Self::ActualState, Self::Error> {
        println!(" init: expected state={:?}", expected.state);
        let mut streams_map = PartStreamsMap::default();

        let initial_state: StreamStateImpl<ProposalPart> = StreamStateImpl {
            buffer: utils::spec_to_impl_buffer(&expected.state.buffer, self.stream_id.clone()),
            init_info: utils::init_message_to_proposal_init(&expected.incoming_message),
            seen_sequences: expected
                .state
                .received
                .iter()
                .map(|msg| msg.sequence as u64)
                .collect(),
            next_sequence: expected.state.next_sequence as u64,
            total_messages: expected.state.total_messages as usize,
            fin_received: expected.state.fin_received,
            emitted_messages: expected.state.emitted.len(),
        };

        streams_map
            .streams
            .insert((self.peer_id, self.stream_id.clone()), initial_state);
        Ok(streams_map)
    }

    fn step(
        &mut self,
        actual: &mut Self::ActualState,
        expected: &Self::ExpectedState,
    ) -> Result<Self::Result, Self::Error> {
        let stream_state = actual.streams.get(&(self.peer_id, self.stream_id.clone()));
        // If exact stream state can't be found, then the proposal is completely emitted and
        // stream is already removed
        println!(" step: model input={:?}", expected.incoming_message);
        match stream_state {
            Some(stream_state) => {
                println!(" step: actual state={:?}", stream_state);
                println!(" step: model state={:?}", expected.state);

                let message = match &expected.incoming_message {
                    Some(msg) => match &msg.msg_type {
                        MessageType::Init => {
                            let proposal_init = utils::generate_dummy_proposal_init();
                            StreamMessage::<ProposalPart>::new(
                                self.stream_id.clone(),
                                msg.sequence as u64,
                                StreamContent::Data(ProposalPart::Init(proposal_init)),
                            )
                        }
                        MessageType::Data => {
                            let transactions = utils::generate_dummy_transactions();
                            StreamMessage::<ProposalPart>::new(
                                self.stream_id.clone(),
                                msg.sequence as u64,
                                StreamContent::Data(ProposalPart::Transactions(transactions)),
                            )
                        }
                        MessageType::Fin => StreamMessage::<ProposalPart>::new(
                            self.stream_id.clone(),
                            msg.sequence as u64,
                            StreamContent::Fin,
                        ),
                    },
                    None => {
                        return Ok(());
                    }
                };

                actual.insert(self.peer_id, message);
            }

            None => println!(" stream state not found (proposal emitted completely)"),
        }

        Ok(())
    }

    // If there is no result, then the result invariant is always true
    fn result_invariant(
        &self,
        _result: &Self::Result,
        _expected: &Self::ExpectedState,
    ) -> Result<bool, Self::Error> {
        Ok(true)
    }

    fn state_invariant(
        &self,
        actual: &Self::ActualState,
        expected: &Self::ExpectedState,
    ) -> Result<bool, Self::Error> {
        let actual_stream_state = actual.streams.get(&(self.peer_id, self.stream_id.clone()));

        match actual_stream_state {
            Some(actual_stream_state) => {
                println!(" state invariant: actual state={:?}", actual_stream_state);
                println!(" state invariant: expected state={:?}", expected.state);

                // Compare the actual and expected states
                assert!(
                    utils::compare_buffers(&actual_stream_state.buffer, &expected.state.buffer),
                    "unexpected buffer value"
                );

                assert_eq!(
                    actual_stream_state.init_info.is_some(),
                    expected.state.init_message.is_some(),
                    "unexpected init info value"
                );

                assert!(
                    utils::messages_equal_sequences(
                        &actual_stream_state.seen_sequences,
                        &expected.state.received
                    ),
                    "unexpected seen sequences value"
                );

                assert_eq!(
                    actual_stream_state.next_sequence, expected.state.next_sequence as u64,
                    "unexpected next sequence value"
                );

                assert_eq!(
                    actual_stream_state.total_messages as i32, expected.state.total_messages,
                    "unexpected total messages value"
                );

                assert_eq!(
                    actual_stream_state.fin_received, expected.state.fin_received,
                    "unexpected fin received value"
                );

                assert_eq!(
                    actual_stream_state.emitted_messages,
                    expected.state.emitted.len(),
                    "unexpected emitted messages value"
                );

                // Check if invariant is satisfied
                if actual_stream_state.fin_received {
                    assert!(
                        actual_stream_state.total_messages > 0,
                        "total messages equal to 0 after fin received"
                    );

                    assert!(
                        actual_stream_state.next_sequence
                            <= actual_stream_state.total_messages as u64,
                        "next sequence greater than total messages after fin received"
                    );
                }

                assert!(
                    actual_stream_state.seen_sequences.is_subset(
                        &self
                            .incoming_messages_pool
                            .iter()
                            .map(|msg| msg.sequence as u64)
                            .collect()
                    ),
                    "seen sequences are not subset of incoming messages pool"
                );

                assert!(
                    actual_stream_state.emitted_messages
                        <= self.complete_proposal_message_sequence.len(),
                    "emitted messages length exceeds the complete proposal message sequence length"
                );

                Ok(true)
            }
            None => {
                // This means message is emitted completely, thus stream (StreamState) is
                //  removed from streams map
                if expected.state.init_message.is_some()
                    && expected.state.fin_received
                    && expected.state.received == self.incoming_messages_pool
                    && expected.state.emitted == self.complete_proposal_message_sequence
                    && expected.state.emitted.len() as i32 == expected.state.total_messages
                {
                    Ok(true)
                } else {
                    Ok(false)
                }
            }
        }
    }
}

```
---
### `starknet/test/mbt/src/tests/streaming/utils.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::collections::HashSet;

use crate::streaming::{Buffer, Message};
use malachitebft_core_types::Round;
use malachitebft_engine::util::streaming::{Sequence, StreamId};
use malachitebft_engine::util::streaming::{StreamContent, StreamMessage};
use malachitebft_starknet_host::types::{PrivateKey, TransactionBatch};
use malachitebft_starknet_host::{
    streaming::MinHeap,
    types::{Address, Height, ProposalInit, ProposalPart, Transaction},
};

pub fn messages_equal_sequences(
    sequences: &HashSet<Sequence>,
    messages: &HashSet<Message>,
) -> bool {
    messages
        .iter()
        .map(|msg| msg.sequence as u64)
        .collect::<HashSet<_>>()
        == *sequences
}

//Because both buffers use same BinaryHeap implementation, we can assume that the order of elements
//will be the same for the same set of elements thus we can just compare the sets of sequences
pub fn compare_buffers(actual_buffer: &MinHeap<ProposalPart>, expected_buffer: &Buffer) -> bool {
    let actual_set: HashSet<_> = actual_buffer
        .0
        .iter()
        .map(|msg| msg.0.sequence as i64)
        .collect();
    let expected_set: HashSet<_> = expected_buffer.0.iter().map(|rec| rec.0).collect();

    actual_set == expected_set
}

pub fn spec_to_impl_buffer(spec_buffer: &Buffer, stream_id: StreamId) -> MinHeap<ProposalPart> {
    let mut impl_buffer = MinHeap::default();

    for rec in &spec_buffer.0 {
        let message = match rec.1.msg_type {
            crate::streaming::MessageType::Init => {
                let proposal_init = generate_dummy_proposal_init();
                StreamMessage::<ProposalPart>::new(
                    stream_id.clone(),
                    rec.0 as u64,
                    StreamContent::Data(ProposalPart::Init(proposal_init)),
                )
            }
            crate::streaming::MessageType::Data => {
                let transactions = generate_dummy_transactions();
                StreamMessage::<ProposalPart>::new(
                    stream_id.clone(),
                    rec.0 as u64,
                    StreamContent::Data(ProposalPart::Transactions(transactions)),
                )
            }
            crate::streaming::MessageType::Fin => StreamMessage::<ProposalPart>::new(
                stream_id.clone(),
                rec.0 as u64,
                StreamContent::Fin,
            ),
        };
        impl_buffer.push(message);
    }

    impl_buffer
}

// Specifications init messages is just string, so no useful data can be extracted from it
pub fn init_message_to_proposal_init(message: &Option<Message>) -> Option<ProposalInit> {
    message.as_ref().map(|_| generate_dummy_proposal_init())
}

pub fn generate_dummy_proposal_init() -> ProposalInit {
    let bytes: [u8; 32] = [
        0x08, 0xd7, 0xa2, 0x0f, 0x32, 0x0c, 0x4d, 0x23, 0xd9, 0xad, 0xf3, 0x29, 0xf5, 0x7c, 0x7b,
        0x62, 0x35, 0x9d, 0x97, 0xce, 0x0b, 0xb3, 0xb7, 0x66, 0x19, 0xd8, 0x50, 0x4d, 0x59, 0xa1,
        0x88, 0x4b,
    ];
    let private_key = PrivateKey::from(bytes);

    let proposer_addr = Address::new(*private_key.public_key().as_bytes());

    let height = Height {
        block_number: 1,
        fork_id: 1,
    };

    let round = Round::new(2);
    let valid_round = Round::new(1);

    ProposalInit {
        height,
        round,
        valid_round,
        proposer: proposer_addr,
    }
}

pub fn generate_dummy_transactions() -> TransactionBatch {
    let tx1 = Transaction::new(vec![0x01, 0x02, 0x03]);
    let tx2 = Transaction::new(vec![0x04, 0x05, 0x06]);
    let tx3 = Transaction::new(vec![0x07, 0x08, 0x09]);

    TransactionBatch::new(vec![tx1, tx2, tx3])
}

```
---
### `starknet/test/mbt/src/tests/streaming.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use bytes::Bytes;
use glob::glob;
use malachitebft_engine::util::streaming::StreamId;
use malachitebft_peer::PeerId;

use crate::{streaming::State, utils::*};

pub mod runner;
pub mod utils;

const SHA2_256: u64 = 0x12;

#[test]
fn test_mbt_part_streaming_specified_traces() {
    let temp_dir = tempfile::TempDir::with_prefix("informalsystems-malachitebft-part-streaming")
        .expect("Failed to create temp dir");
    let temp_path = temp_dir.path().to_owned();

    if std::env::var("KEEP_TEMP").is_ok() {
        std::mem::forget(temp_dir);
    }

    let quint_seed = quint_seed();

    println!("{}", temp_path.to_string_lossy());
    generate_test_traces(
        "block-streaming/part_stream.qnt",
        &temp_path.to_string_lossy(),
        quint_seed,
    );

    for json_fixture in glob(&format!("{}/*.itf.json", temp_path.display()))
        .expect("Failed to read glob pattern")
        .flatten()
    {
        println!(
            " Running trace {:?}",
            json_fixture.file_name().unwrap().to_str().unwrap()
        );

        let json = std::fs::read_to_string(&json_fixture).unwrap();
        let trace = itf::trace_from_str::<State>(&json).unwrap();

        let hash = multihash::Multihash::<64>::wrap(SHA2_256, b"PeerId").unwrap();
        let peer_id = PeerId::from_multihash(hash).unwrap();

        let streaming_runner = runner::StreamingRunner::new(peer_id, StreamId::new(Bytes::new()));
        trace.run_on(streaming_runner).unwrap();
    }
}

#[test]
fn test_mbt_part_streaming_random_traces() {
    let temp_dir = tempfile::TempDir::with_prefix("informalsystems-malachitebft-part-streaming")
        .expect("Failed to create temp dir");
    let temp_path = temp_dir.path().to_owned();

    if std::env::var("KEEP_TEMP").is_ok() {
        std::mem::forget(temp_dir);
    }

    let quint_seed = quint_seed();

    println!("{}", temp_path.to_string_lossy());
    generate_random_traces(
        "block-streaming/part_stream.qnt",
        &temp_path.to_string_lossy(),
        quint_seed,
        // current quint spec has 4 message parts in tests so there are 24 (4!) possible traces
        // given that duplicate messages case is not covered in the spec
        24,
    );

    for json_fixture in glob(&format!("{}/*.itf.json", temp_path.display()))
        .expect("Failed to read glob pattern")
        .flatten()
    {
        println!(
            " Running trace {:?}",
            json_fixture.file_name().unwrap().to_str().unwrap()
        );

        let json = std::fs::read_to_string(&json_fixture).unwrap();
        let trace = itf::trace_from_str::<State>(&json).unwrap();

        let hash = multihash::Multihash::<64>::wrap(SHA2_256, b"PeerId").unwrap();
        let peer_id = PeerId::from_multihash(hash).unwrap();

        let streaming_runner = runner::StreamingRunner::new(peer_id, StreamId::new(Bytes::new()));
        trace.run_on(streaming_runner).unwrap();
    }
}

```
---
### `starknet/test/mbt/src/tests.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod streaming;

```
---
### `starknet/test/mbt/src/utils.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::path::Path;

pub fn generate_test_traces(spec_rel_path: &str, gen_dir: &str, quint_seed: u64) {
    println!(" Generating test traces for {spec_rel_path:?}...");

    let spec_abs_path = format!("{}/specs/{spec_rel_path}", env!("CARGO_MANIFEST_DIR"),);
    let spec_path = Path::new(&spec_abs_path);

    std::process::Command::new("quint")
        .arg("test")
        .arg("--out-itf")
        .arg(format!("{gen_dir}/test_{{test}}_{{seq}}.itf.json"))
        .arg("--seed")
        .arg(quint_seed.to_string())
        .arg(spec_path)
        .current_dir(spec_path.parent().unwrap())
        .output()
        .expect("Failed to run quint test");

    println!(" Generated traces in {gen_dir:?}");
}

pub fn generate_random_traces(
    spec_rel_path: &str,
    gen_dir: &str,
    quint_seed: u64,
    num_traces: u64,
) {
    println!(" Generating random traces for {spec_rel_path:?}...");

    let spec_abs_path = format!("{}/specs/{spec_rel_path}", env!("CARGO_MANIFEST_DIR"),);
    let spec_path = Path::new(&spec_abs_path);

    std::process::Command::new("quint")
        .arg("run")
        .arg("--n-traces")
        .arg(num_traces.to_string())
        .arg("--max-samples")
        .arg("1000")
        .arg("--out-itf")
        .arg(format!("{gen_dir}/random_{{seq}}.itf.json"))
        .arg("--seed")
        .arg(quint_seed.to_string())
        .arg(spec_path)
        .current_dir(spec_path.parent().unwrap())
        .output()
        .expect("Failed to run quint test");

    println!(" Generated traces in {gen_dir:?}");
}

const DEFAULT_QUINT_SEED: u64 = 118;

pub fn quint_seed() -> u64 {
    let seed = std::env::var("QUINT_SEED")
        .ok()
        .and_then(|x| x.parse::<u64>().ok())
        .unwrap_or(DEFAULT_QUINT_SEED);

    println!("Using QUINT_SEED={seed}");

    seed
}

```
---
### `starknet/test/src/lib.rs`
*2025-05-18 23:58:49 | 8 KB*
```rust
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::str::FromStr;
use std::time::Duration;

use async_trait::async_trait;
use rand::rngs::StdRng;
use rand::SeedableRng;

use malachitebft_config::mempool_load::UniformLoadConfig;
use malachitebft_starknet_host::config::Config;
use malachitebft_starknet_host::node::{ConfigSource, Handle, StarknetNode};
use malachitebft_starknet_host::types::{Height, MockContext, PrivateKey, Validator, ValidatorSet};
use malachitebft_test_framework::HasTestRunner;
use malachitebft_test_framework::{NodeRunner, TestNode};

pub use malachitebft_test_framework::TestBuilder as GenTestBuilder;
pub use malachitebft_test_framework::{
    CanMakeConfig, CanMakeGenesis, CanMakePrivateKeyFile, EngineHandle, HandlerResult, Node,
    NodeId, TestParams,
};

use tempfile::TempDir;

#[cfg(test)]
pub mod tests;

pub type TestBuilder<S> = GenTestBuilder<MockContext, S>;

impl HasTestRunner<TestRunner> for MockContext {
    type Runner = TestRunner;
}

#[derive(Clone)]
pub struct TestRunner {
    pub id: usize,
    pub params: TestParams,
    pub nodes_count: usize,
    pub start_height: HashMap<NodeId, Height>,
    pub home_dir: HashMap<NodeId, PathBuf>,
    pub private_keys: HashMap<NodeId, PrivateKey>,
    pub validator_set: ValidatorSet,
    pub consensus_base_port: usize,
    pub mempool_base_port: usize,
    pub metrics_base_port: usize,
}

fn temp_dir(id: NodeId) -> PathBuf {
    TempDir::with_prefix(format!("malachitebft-test-app-{id}-"))
        .unwrap()
        .into_path()
}

#[async_trait]
impl NodeRunner<MockContext> for TestRunner {
    type NodeHandle = Handle;

    fn new<S>(id: usize, nodes: &[TestNode<MockContext, S>], params: TestParams) -> Self {
        let nodes_count = nodes.len();
        let base_port = 20_000 + id * 1000;

        let (validators, private_keys) = make_validators(nodes);
        let validator_set = ValidatorSet::new(validators);

        let start_height = nodes
            .iter()
            .map(|node| (node.id, node.start_height))
            .collect();

        let home_dir = nodes
            .iter()
            .map(|node| (node.id, temp_dir(node.id)))
            .collect();

        Self {
            id,
            params,
            nodes_count,
            start_height,
            home_dir,
            private_keys,
            validator_set,
            consensus_base_port: base_port,
            mempool_base_port: base_port + 100,
            metrics_base_port: base_port + 200,
        }
    }

    async fn spawn(&self, id: NodeId) -> eyre::Result<Handle> {
        let home_dir = &self.home_dir[&id].clone();

        let app = StarknetNode {
            home_dir: home_dir.clone(),
            config_source: ConfigSource::Value(Box::new(self.generate_config(id))),
            start_height: Some(self.start_height[&id].as_u64()),
        };

        let validators = self
            .validator_set
            .validators
            .iter()
            .map(|val| (val.public_key, val.voting_power))
            .collect();

        let genesis = app.make_genesis(validators);
        fs::create_dir_all(app.genesis_file().parent().unwrap())?;
        fs::write(app.genesis_file(), serde_json::to_string(&genesis)?)?;

        let priv_key_file = app.make_private_key_file(self.private_keys[&id].clone());
        fs::create_dir_all(app.private_key_file().parent().unwrap())?;
        fs::write(
            app.private_key_file(),
            serde_json::to_string(&priv_key_file)?,
        )?;

        let handle = app.start().await?;

        Ok(handle)
    }

    async fn reset_db(&self, id: NodeId) -> eyre::Result<()> {
        let db_dir = self.home_dir[&id].join("db");
        fs::remove_dir_all(&db_dir)?;
        fs::create_dir_all(&db_dir)?;
        Ok(())
    }
}

impl TestRunner {
    fn generate_config(&self, node: NodeId) -> Config {
        let mut config = self.generate_default_config(node);
        apply_params(&mut config, &self.params);
        config
    }

    fn generate_default_config(&self, node: NodeId) -> Config {
        use malachitebft_config::*;

        let transport = transport_from_env(TransportProtocol::Tcp);
        let protocol = PubSubProtocol::default();
        let i = node - 1;

        Config {
            moniker: format!("node-{}", node),
            logging: LoggingConfig::default(),
            consensus: ConsensusConfig {
                value_payload: ValuePayload::PartsOnly,
                timeouts: TimeoutConfig::default(),
                p2p: P2pConfig {
                    protocol,
                    discovery: DiscoveryConfig::default(),
                    listen_addr: transport.multiaddr("127.0.0.1", self.consensus_base_port + i),
                    persistent_peers: (0..self.nodes_count)
                        .filter(|j| i != *j)
                        .map(|j| transport.multiaddr("127.0.0.1", self.consensus_base_port + j))
                        .collect(),
                    ..Default::default()
                },
            },
            mempool: MempoolConfig {
                p2p: P2pConfig {
                    protocol,
                    listen_addr: transport.multiaddr("127.0.0.1", self.mempool_base_port + i),
                    persistent_peers: (0..self.nodes_count)
                        .filter(|j| i != *j)
                        .map(|j| transport.multiaddr("127.0.0.1", self.mempool_base_port + j))
                        .collect(),
                    ..Default::default()
                },
                max_tx_count: 10000,
                gossip_batch_size: 0,
                load: MempoolLoadConfig {
                    load_type: MempoolLoadType::UniformLoad(UniformLoadConfig::default()),
                },
            },
            value_sync: ValueSyncConfig {
                enabled: true,
                status_update_interval: Duration::from_secs(2),
                request_timeout: Duration::from_secs(5),
            },
            metrics: MetricsConfig {
                enabled: false,
                listen_addr: format!("127.0.0.1:{}", self.metrics_base_port + i)
                    .parse()
                    .unwrap(),
            },
            runtime: RuntimeConfig::single_threaded(),
            test: TestConfig {
                stable_block_times: true,
                ..TestConfig::default()
            },
        }
    }
}

use malachitebft_config::{TransportProtocol, ValuePayload};

fn transport_from_env(default: TransportProtocol) -> TransportProtocol {
    if let Ok(protocol) = std::env::var("MALACHITE_TRANSPORT") {
        TransportProtocol::from_str(&protocol).unwrap_or(default)
    } else {
        default
    }
}

fn make_validators<S>(
    nodes: &[TestNode<MockContext, S>],
) -> (Vec<Validator>, HashMap<NodeId, PrivateKey>) {
    let mut rng = StdRng::seed_from_u64(0x42);

    let mut validators = Vec::new();
    let mut private_keys = HashMap::new();

    for node in nodes {
        let sk = PrivateKey::generate(&mut rng);
        let val = Validator::new(sk.public_key(), node.voting_power);

        private_keys.insert(node.id, sk);

        if node.voting_power > 0 {
            validators.push(val);
        }
    }

    (validators, private_keys)
}

fn apply_params(config: &mut Config, params: &TestParams) {
    config.consensus.value_payload = ValuePayload::PartsOnly;
    config.value_sync.enabled = params.enable_value_sync;
    config.consensus.p2p.protocol = params.protocol;
    config.test.max_block_size = params.block_size;
    config.test.txs_per_part = params.txs_per_part;
    config.test.vote_extensions.enabled = params.vote_extensions.is_some();
    config.test.vote_extensions.size = params.vote_extensions.unwrap_or_default();
    config.test.max_retain_blocks = params.max_retain_blocks;
}

```
---
### `starknet/test/src/tests/full_nodes.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use std::time::Duration;

use malachitebft_test_framework::TestParams;

use crate::TestBuilder;

#[tokio::test]
pub async fn basic_full_node() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    // Add 3 validators with different voting powers
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(30)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add 2 full nodes that should follow consensus but not participate
    test.add_node()
        .full_node()
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .full_node()
        .start()
        .wait_until(HEIGHT)
        .success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn full_node_crash_and_sync() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Add validators
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add a full node that crashes and needs to sync
    test.add_node()
        .full_node()
        .start()
        .wait_until(3)
        .crash()
        .reset_db()
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn late_starting_full_node() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Add validators that start immediately
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add a full node that starts late
    test.add_node()
        .full_node()
        .start_after(1, Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn mixed_validator_and_full_node_failures() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Add stable validators
    test.add_node()
        .with_voting_power(30)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(30)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add a validator that crashes
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(5)
        .crash()
        .restart_after(Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    // Add full nodes - one stable, one that crashes
    test.add_node()
        .full_node()
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .full_node()
        .start()
        .wait_until(6)
        .crash()
        .restart_after(Duration::from_secs(15))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

```
---
### `starknet/test/src/tests/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod full_nodes;
pub mod n3f0;
pub mod n3f0_pubsub_protocol;
pub mod n3f1;
pub mod value_sync;
pub mod vote_rebroadcast;
pub mod wal;

```
---
### `starknet/test/src/tests/n3f0.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::time::Duration;

use crate::TestBuilder;

#[tokio::test]
pub async fn all_correct_nodes() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();

    test.build().run(Duration::from_secs(30)).await
}

```
---
### `starknet/test/src/tests/n3f0_pubsub_protocol.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::time::Duration;

use bytesize::ByteSize;
use malachitebft_config::{GossipSubConfig, PubSubProtocol};

use crate::{TestBuilder, TestParams};

async fn run_test(params: TestParams) {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();

    test.build()
        .run_with_params(Duration::from_secs(30), params)
        .await
}

#[tokio::test]
pub async fn broadcast_custom_config_1ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::Broadcast,
        block_size: ByteSize::kib(1),
        tx_size: ByteSize::kib(1),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn broadcast_custom_config_2ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::Broadcast,
        block_size: ByteSize::kib(2),
        tx_size: ByteSize::kib(2),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn gossip_custom_config_1ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::GossipSub(GossipSubConfig::default()),
        block_size: ByteSize::kib(1),
        tx_size: ByteSize::kib(1),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn gossip_custom_config_2ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::GossipSub(GossipSubConfig::default()),
        block_size: ByteSize::kib(2),
        tx_size: ByteSize::kib(2),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

```
---
### `starknet/test/src/tests/n3f1.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::time::Duration;

use crate::TestBuilder;

#[tokio::test]
pub async fn proposer_fails_to_start() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node().with_voting_power(1).success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn one_node_fails_to_start() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node().with_voting_power(1).success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn proposer_crashes_at_height_2() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(1)
        .start()
        .wait_until(2)
        .crash()
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn one_node_crashes_at_height_3() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(1)
        .start()
        .wait_until(3)
        .crash()
        .success();

    test.build().run(Duration::from_secs(30)).await
}

```
---
### `starknet/test/src/tests/value_sync.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use std::time::Duration;

use crate::{TestBuilder, TestParams};

#[tokio::test]
pub async fn crash_restart_from_start() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Node 1 starts with 10 voting power.
    test.add_node()
        .with_voting_power(10)
        .start()
        // Wait until it reaches height 10
        .wait_until(HEIGHT)
        // Record a successful test for this node
        .success();

    // Node 2 starts with 10 voting power, in parallel with node 1 and with the same behaviour
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Node 3 starts with 5 voting power, in parallel with node 1 and 2.
    test.add_node()
        .with_voting_power(5)
        .start()
        // Wait until the node reaches height 2...
        .wait_until(2)
        // ...and then kills it
        .crash()
        // Reset the database so that the node has to do Sync from height 1
        .reset_db()
        // After that, it waits 5 seconds before restarting the node
        .restart_after(Duration::from_secs(5))
        // Wait until the node reached the expected height
        .wait_until(HEIGHT)
        // Record a successful test for this node
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60), // Timeout for the whole test
            TestParams {
                enable_value_sync: true, // Enable Sync
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn crash_restart_from_latest() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(2)
        .crash()
        // We do not reset the database so that the node can restart from the latest height
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn aggressive_pruning() {
    const HEIGHT: u64 = 15;

    let mut test = TestBuilder::<()>::new();

    // Node 1 starts with 10 voting power.
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(2)
        .crash()
        .reset_db()
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60), // Timeout for the whole test
            TestParams {
                enable_value_sync: true, // Enable Sync
                max_retain_blocks: 10,   // Prune blocks older than 10
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn start_late() {
    const HEIGHT: u64 = 3;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT * 2)
        .success();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT * 2)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start_after(1, Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(30),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

```
---
### `starknet/test/src/tests/vote_rebroadcast.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::time::Duration;

use malachitebft_core_types::VoteType;

use crate::{TestBuilder, TestParams};

#[tokio::test]
pub async fn crash_restart_from_start() {
    const HEIGHT: u64 = 10;
    const CRASH_HEIGHT: u64 = 4;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        // Wait until the node reaches height 4...
        .wait_until(4)
        // ...then kill it
        .crash()
        // Reset the database so that the node has to do Sync from height 1
        .reset_db()
        // After that, it waits 5 seconds before restarting the node
        .restart_after(Duration::from_secs(5))
        // Wait until the node reached the expected height
        .wait_until(HEIGHT)
        // Record a successful test for this node
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                // Enable Sync to allow the node to catch up to the latest height
                enable_value_sync: true,
                ..TestParams::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn crash_restart_from_latest() {
    const HEIGHT: u64 = 10;
    const CRASH_HEIGHT: u64 = 4;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .crash()
        // We do not reset the database so that the node can restart from the latest height
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn start_late() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .start()
        .wait_until(1)
        .expect_vote_rebroadcast(1, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(1)
        .expect_vote_rebroadcast(1, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start_after(1, Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..Default::default()
            },
        )
        .await
}

```
---
### `starknet/test/src/tests/wal.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use std::time::Duration;

use eyre::bail;
use tracing::info;

use malachitebft_core_consensus::LocallyProposedValue;
use malachitebft_core_types::SignedVote;
use malachitebft_engine::util::events::Event;
use malachitebft_starknet_host::types::MockContext;

use crate::{HandlerResult, TestBuilder, TestParams};

#[tokio::test]
async fn proposer_crashes_after_proposing() {
    #[derive(Clone, Debug, Default)]
    struct State {
        first_proposed_value: Option<LocallyProposedValue<MockContext>>,
    }

    const CRASH_HEIGHT: u64 = 4;

    let mut test = TestBuilder::<State>::new();

    test.add_node().with_voting_power(10).start().success();
    test.add_node().with_voting_power(10).start().success();

    test.add_node()
        .with_voting_power(40)
        .start()
        .wait_until(CRASH_HEIGHT)
        // Wait until this node proposes a value
        .on_event(|event, state| match event {
            Event::ProposedValue(value) => {
                info!("Proposer proposed block: {:?}", value.value);
                state.first_proposed_value = Some(value);
                Ok(HandlerResult::ContinueTest)
            }
            _ => Ok(HandlerResult::WaitForNextEvent),
        })
        // Crash right after
        .crash()
        // Restart after 5 seconds
        .restart_after(Duration::from_secs(5))
        // Check that we replay messages from the WAL
        .expect_wal_replay(CRASH_HEIGHT)
        // Wait until it proposes a value again, while replaying WAL
        // Check that it is the same value as the first time
        .on_proposed_value(|value, state| {
            let Some(first_value) = state.first_proposed_value.as_ref() else {
                bail!("Proposer did not propose a block");
            };

            if first_value.value == value.value {
                info!("Proposer re-proposed the same block: {:?}", value.value);
                Ok(HandlerResult::ContinueTest)
            } else {
                bail!(
                    "Proposer just equivocated: expected {:?}, got {:?}",
                    first_value.value,
                    value.value
                )
            }
        })
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..TestParams::default()
            },
        )
        .await
}

#[tokio::test]
async fn non_proposer_crashes_after_voting() {
    #[derive(Clone, Debug, Default)]
    struct State {
        first_vote: Option<SignedVote<MockContext>>,
    }

    const CRASH_HEIGHT: u64 = 3;

    let mut test = TestBuilder::<State>::new();

    test.add_node()
        .with_voting_power(40)
        .start()
        .wait_until(CRASH_HEIGHT)
        // Wait until this node proposes a value
        .on_vote(|vote, state| {
            info!("Non-proposer voted");
            state.first_vote = Some(vote);

            Ok(HandlerResult::ContinueTest)
        })
        // Crash right after
        .crash()
        // Restart after 5 seconds
        .restart_after(Duration::from_secs(5))
        // Check that we replay messages from the WAL
        .expect_wal_replay(CRASH_HEIGHT)
        // Wait until it proposes a value again, while replaying WAL
        // Check that it is the same value as the first time
        .on_vote(|vote, state| {
            let Some(first_vote) = state.first_vote.as_ref() else {
                bail!("Non-proposer did not vote")
            };

            if first_vote.block_hash == vote.block_hash {
                info!("Non-proposer voted the same way: {first_vote:?}");
                Ok(HandlerResult::ContinueTest)
            } else {
                bail!(
                    "Non-proposer just equivocated: expected {:?}, got {:?}",
                    first_vote.block_hash,
                    vote.block_hash
                )
            }
        })
        .success();

    test.add_node().with_voting_power(10).start().success();
    test.add_node().with_voting_power(10).start().success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..TestParams::default()
            },
        )
        .await
}

```
---
### `sync/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-sync"
description = "Synchronization protocol for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish.workspace = true
rust-version.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true

[dependencies]
malachitebft-core-types = { workspace = true }
malachitebft-metrics = { workspace = true }
malachitebft-peer = { workspace = true }

async-trait = { workspace = true }
bytes = { workspace = true, features = ["serde"] }
dashmap = { workspace = true }
derive-where = { workspace = true }
displaydoc = { workspace = true }
genawaiter = { workspace = true }
libp2p = { workspace = true, features = ["request-response", "cbor"] }
rand = { workspace = true }
serde = { workspace = true }
thiserror = { workspace = true }
tracing = { workspace = true }

[lints]
workspace = true

```
---
### `sync/src/behaviour.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::time::Duration;

use bytes::Bytes;
use libp2p::metrics::Registry;
use libp2p::request_response::{self as rpc, OutboundRequestId, ProtocolSupport};
use libp2p::swarm::NetworkBehaviour;
use libp2p::{PeerId, StreamProtocol};
use thiserror::Error;

use crate::rpc::Codec;
use crate::types::{RawRequest, RawResponse, ResponseChannel};

// use crate::Metrics;

#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "Event")]
pub struct Behaviour {
    rpc: rpc::Behaviour<Codec>,
}

pub type Event = rpc::Event<RawRequest, RawResponse>;

#[derive(Copy, Clone, Debug)]
pub struct Config {
    pub request_timeout: Duration,
    pub max_request_size: usize,
    pub max_response_size: usize,
}

impl Config {
    pub fn with_request_timeout(mut self, request_timeout: Duration) -> Self {
        self.request_timeout = request_timeout;
        self
    }

    pub fn with_max_request_size(mut self, max_request_size: usize) -> Self {
        self.max_request_size = max_request_size;
        self
    }

    pub fn with_max_response_size(mut self, max_response_size: usize) -> Self {
        self.max_response_size = max_response_size;
        self
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            request_timeout: Duration::from_secs(30),
            max_request_size: 1024 * 1024,        // 1 MiB
            max_response_size: 512 * 1024 * 1024, // 512 MiB
        }
    }
}

impl Behaviour {
    pub const PROTOCOL: [(StreamProtocol, ProtocolSupport); 1] = [(
        StreamProtocol::new("/malachitebft-sync/v1beta1"),
        ProtocolSupport::Full,
    )];

    pub fn new(config: Config) -> Self {
        let rpc_config = rpc::Config::default().with_request_timeout(config.request_timeout);

        Self {
            rpc: rpc::Behaviour::with_codec(Codec::new(config), Self::PROTOCOL, rpc_config),
            // metrics: None,
        }
    }

    pub fn new_with_metrics(config: Config, _registry: &mut Registry) -> Self {
        let rpc_config = rpc::Config::default().with_request_timeout(config.request_timeout);

        Self {
            rpc: rpc::Behaviour::with_codec(Codec::new(config), Self::PROTOCOL, rpc_config),
            // metrics: Some(Metrics::new(registry)),
        }
    }

    pub fn send_response(&mut self, channel: ResponseChannel, data: Bytes) -> Result<(), Error> {
        self.rpc
            .send_response(channel, RawResponse(data))
            .map_err(|_| Error::SendResponse)
    }

    pub fn send_request(&mut self, peer: PeerId, data: Bytes) -> OutboundRequestId {
        self.rpc.send_request(&peer, RawRequest(data))
    }
}

#[derive(Clone, Debug, Error)]
pub enum Error {
    #[error("Failed to send response")]
    SendResponse,

    #[error("Failed to send request")]
    SendRequest,
}

impl Default for Behaviour {
    fn default() -> Self {
        Self::new(Config::default())
    }
}

```
---
### `sync/src/co.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use genawaiter::sync as gen;
use genawaiter::GeneratorState;

use crate::{Effect, Error, Resume};

pub type Gen<Ctx, F> = gen::Gen<Effect<Ctx>, Resume<Ctx>, F>;
pub type Co<Ctx> = gen::Co<Effect<Ctx>, Resume<Ctx>>;
pub type CoState<Ctx> = GeneratorState<Effect<Ctx>, Result<(), Error<Ctx>>>;

```
---
### `sync/src/handle.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
use core::marker::PhantomData;

use derive_where::derive_where;
use thiserror::Error;
use tracing::{debug, error, info, trace, warn};

use malachitebft_core_types::{CertificateError, CommitCertificate, Context, Height};

use crate::co::Co;
use crate::{
    perform, InboundRequestId, Metrics, OutboundRequestId, PeerId, RawDecidedValue, Request, State,
    Status, ValueRequest, ValueResponse,
};

#[derive_where(Debug)]
#[derive(Error)]
pub enum Error<Ctx: Context> {
    /// The coroutine was resumed with a value which
    /// does not match the expected type of resume value.
    #[error("Unexpected resume: {0:?}, expected one of: {1}")]
    UnexpectedResume(Resume<Ctx>, &'static str),
}

#[derive_where(Debug)]
pub enum Resume<Ctx: Context> {
    Continue(PhantomData<Ctx>),
}

impl<Ctx: Context> Default for Resume<Ctx> {
    fn default() -> Self {
        Self::Continue(PhantomData)
    }
}

#[derive_where(Debug)]
pub enum Effect<Ctx: Context> {
    /// Broadcast our status to our direct peers
    BroadcastStatus(Ctx::Height),

    /// Send a ValueSync request to a peer
    SendValueRequest(PeerId, ValueRequest<Ctx>),

    /// Send a response to a ValueSync request
    SendValueResponse(InboundRequestId, ValueResponse<Ctx>),

    /// Retrieve a value from the application
    GetDecidedValue(InboundRequestId, Ctx::Height),
}

#[derive_where(Debug)]
pub enum Input<Ctx: Context> {
    /// A tick has occurred
    Tick,

    /// A status update has been received from a peer
    Status(Status<Ctx>),

    /// Consensus just started a new height.
    /// The boolean indicates whether this was a restart or a new start.
    StartedHeight(Ctx::Height, bool),

    /// Consensus just decided on a new value
    Decided(Ctx::Height),

    /// A ValueSync request has been received from a peer
    ValueRequest(InboundRequestId, PeerId, ValueRequest<Ctx>),

    /// A ValueSync response has been received
    ValueResponse(OutboundRequestId, PeerId, ValueResponse<Ctx>),

    /// Got a response from the application to our `GetValue` request
    GotDecidedValue(InboundRequestId, Ctx::Height, Option<RawDecidedValue<Ctx>>),

    /// A request for a value timed out
    SyncRequestTimedOut(PeerId, Request<Ctx>),

    /// We received an invalid [`CommitCertificate`]
    InvalidCertificate(PeerId, CommitCertificate<Ctx>, CertificateError<Ctx>),
}

pub async fn handle<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    input: Input<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    match input {
        Input::Tick => on_tick(co, state, metrics).await,

        Input::Status(status) => on_status(co, state, metrics, status).await,

        Input::StartedHeight(height, restart) => {
            on_started_height(co, state, metrics, height, restart).await
        }

        Input::Decided(height) => on_decided(co, state, metrics, height).await,

        Input::ValueRequest(request_id, peer_id, request) => {
            on_value_request(co, state, metrics, request_id, peer_id, request).await
        }

        Input::ValueResponse(request_id, peer_id, response) => {
            on_value_response(co, state, metrics, request_id, peer_id, response).await
        }

        Input::GotDecidedValue(request_id, height, value) => {
            on_value(co, state, metrics, request_id, height, value).await
        }

        Input::SyncRequestTimedOut(peer_id, request) => {
            on_sync_request_timed_out(co, state, metrics, peer_id, request).await
        }

        Input::InvalidCertificate(peer, certificate, error) => {
            on_invalid_certificate(co, state, metrics, peer, certificate, error).await
        }
    }
}

pub async fn on_tick<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    _metrics: &Metrics,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug!(height.tip = %state.tip_height, "Broadcasting status");

    perform!(co, Effect::BroadcastStatus(state.tip_height));

    Ok(())
}

pub async fn on_status<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    status: Status<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug!(%status.peer_id, %status.tip_height, "Received peer status");

    let peer_height = status.tip_height;

    state.update_status(status);

    if !state.started {
        // Consensus has not started yet, no need to sync (yet).
        return Ok(());
    }

    if peer_height > state.tip_height {
        warn!(
            height.tip = %state.tip_height,
            height.sync = %state.sync_height,
            height.peer = %peer_height,
            "SYNC REQUIRED: Falling behind"
        );

        // We are lagging behind one of our peer at least,
        // request sync from any peer already at or above that peer's height.
        request_value(co, state, metrics).await?;
    }

    Ok(())
}

pub async fn on_started_height<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    height: Ctx::Height,
    restart: bool,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let tip_height = height.decrement().unwrap_or(height);

    debug!(height.tip = %tip_height, height.sync = %height, %restart, "Starting new height");

    state.started = true;
    state.sync_height = height;
    state.tip_height = tip_height;

    // Check if there is any peer already at or above the height we just started,
    // and request sync from that peer in order to catch up.
    request_value(co, state, metrics).await?;

    Ok(())
}

pub async fn on_decided<Ctx>(
    _co: Co<Ctx>,
    state: &mut State<Ctx>,
    _metrics: &Metrics,
    height: Ctx::Height,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug!(height.tip = %height, "Updating tip height");

    state.tip_height = height;
    state.remove_pending_decided_value_request(height);

    Ok(())
}

pub async fn on_value_request<Ctx>(
    co: Co<Ctx>,
    _state: &mut State<Ctx>,
    metrics: &Metrics,
    request_id: InboundRequestId,
    peer: PeerId,
    request: ValueRequest<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug!(%request.height, %peer, "Received request for value");

    metrics.decided_value_request_received(request.height.as_u64());

    perform!(co, Effect::GetDecidedValue(request_id, request.height));

    Ok(())
}

pub async fn on_value_response<Ctx>(
    _co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    request_id: OutboundRequestId,
    peer: PeerId,
    response: ValueResponse<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    debug!(%response.height, %request_id, %peer, "Received response");

    state.remove_pending_decided_value_request(response.height);

    metrics.decided_value_response_received(response.height.as_u64());

    Ok(())
}

pub async fn on_value<Ctx>(
    co: Co<Ctx>,
    _state: &mut State<Ctx>,
    metrics: &Metrics,
    request_id: InboundRequestId,
    height: Ctx::Height,
    value: Option<RawDecidedValue<Ctx>>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let response = match value {
        None => {
            error!(%height, "Received empty value response from host");
            None
        }
        Some(value) if value.certificate.height != height => {
            error!(
                %height, value.height = %value.certificate.height,
                "Received value response for wrong height"
            );
            None
        }
        Some(value) => {
            info!(%height, "Received value response from host, sending it out");
            Some(value)
        }
    };

    perform!(
        co,
        Effect::SendValueResponse(request_id, ValueResponse::new(height, response))
    );

    metrics.decided_value_response_sent(height.as_u64());

    Ok(())
}

pub async fn on_sync_request_timed_out<Ctx>(
    _co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    peer_id: PeerId,
    request: Request<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    match request {
        Request::ValueRequest(value_request) => {
            let height = value_request.height;
            warn!(%peer_id, %height, "Value request timed out");
            state.remove_pending_decided_value_request(height);
            metrics.decided_value_request_timed_out(height.as_u64());
        }
    };

    Ok(())
}

/// If there are no pending requests for the sync height,
/// and there is peer at a higher height than our sync height,
/// then sync from that peer.
async fn request_value<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    let sync_height = state.sync_height;

    if state.has_pending_decided_value_request(&sync_height) {
        warn!(height.sync = %sync_height, "Already have a pending value request for this height");
        return Ok(());
    }

    if let Some(peer) = state.random_peer_with_tip_at_or_above(sync_height) {
        request_value_from_peer(co, state, metrics, sync_height, peer).await?;
    } else {
        debug!(height.sync = %sync_height, "No peer to request sync from");
    }

    Ok(())
}

async fn request_value_from_peer<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    height: Ctx::Height,
    peer: PeerId,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    info!(height.sync = %height, %peer, "Requesting sync value from peer");

    perform!(
        co,
        Effect::SendValueRequest(peer, ValueRequest::new(height))
    );

    metrics.decided_value_request_sent(height.as_u64());
    state.store_pending_decided_value_request(height, peer);

    Ok(())
}

async fn on_invalid_certificate<Ctx>(
    co: Co<Ctx>,
    state: &mut State<Ctx>,
    metrics: &Metrics,
    from: PeerId,
    certificate: CommitCertificate<Ctx>,
    error: CertificateError<Ctx>,
) -> Result<(), Error<Ctx>>
where
    Ctx: Context,
{
    error!(%error, %certificate.height, %certificate.round, "Received invalid certificate");
    trace!("Certificate: {certificate:#?}");

    info!(height.sync = %certificate.height, "Requesting sync from another peer");
    state.remove_pending_decided_value_request(certificate.height);

    let Some(peer) = state.random_peer_with_tip_at_or_above_except(certificate.height, from) else {
        error!(height.sync = %certificate.height, "No other peer to request sync from");
        return Ok(());
    };

    request_value_from_peer(co, state, metrics, certificate.height, peer).await
}

```
---
### `sync/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
mod behaviour;
pub use behaviour::{Behaviour, Config, Event};

mod metrics;
pub use metrics::Metrics;

mod state;
pub use state::State;

mod types;
pub use types::*;

mod rpc;

mod macros;

#[doc(hidden)]
pub mod handle;
pub use handle::{Effect, Error, Input, Resume};

#[doc(hidden)]
pub mod co;

#[doc(hidden)]
pub use tracing;

```
---
### `sync/src/macros.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
/// Process an [`Input`][input] and handle the emitted [`Effects`][effect].
///
/// [input]: crate::handle::Input
/// [effect]: crate::handle::Effect
///
/// # Example
///
/// ```rust,ignore
/// malachitebft_core_consensus::process!(
///     // Input to process
///     input: input,
///     // Consensus state
///     state: &mut state,
///     // Metrics
///     metrics: &metrics,
///    // Effect handler
///     on: effect => handle_effect(effect).await
/// )
/// ```
#[macro_export]
macro_rules! process {
    (input: $input:expr, state: $state:expr, metrics: $metrics:expr, with: $effect:ident => $handle:expr) => {{
        let mut gen =
            $crate::co::Gen::new(|co| $crate::handle::handle(co, $state, $metrics, $input));

        let mut co_result = gen.resume_with($crate::Resume::default());

        loop {
            match co_result {
                $crate::co::CoState::Yielded($effect) => {
                    let resume = match $handle {
                        Ok(resume) => resume,
                        Err(error) => {
                            $crate::tracing::error!("Error when processing effect: {error:?}");
                            $crate::Resume::default()
                        }
                    };
                    co_result = gen.resume_with(resume)
                }
                $crate::co::CoState::Complete(result) => {
                    return result.map_err(Into::into);
                }
            }
        }
    }};
}

/// Yield an effect, expecting a specific type of resume value.
///
/// Effects yielded by this macro must resume with a value that matches the provided pattern.
/// If not pattern is give, then the yielded effect must resume with [`Resume::Continue`][continue].
///
/// # Errors
/// This macro will abort the current function with a [`Error::UnexpectedResume`][error] error
/// if the effect does not resume with a value that matches the provided pattern.
///
/// # Example
/// ```rust,ignore
/// // If we do not need to extract the resume value
/// let () = perform!(co, effect, Resume::ProposeValue(_, _));
///
/// /// If we need to extract the resume value
/// let value: Ctx::Value = perform!(co, effect, Resume::ProposeValue(_, value) => value);
/// ```
///
/// [continue]: crate::handle::Resume::Continue
/// [error]: crate::handle::Error::UnexpectedResume
#[macro_export]
macro_rules! perform {
    ($co:expr, $effect:expr) => {
        perform!($co, $effect, $crate::handle::Resume::Continue(_))
    };

    ($co:expr, $effect:expr, $pat:pat) => {
        perform!($co, $effect, $pat => ())
    };

    // TODO: Add support for multiple patterns + if guards
    ($co:expr, $effect:expr, $pat:pat => $expr:expr $(,)?) => {
        #[allow(unreachable_patterns)]
        match $co.yield_($effect).await {
            $pat => $expr,
            resume => {
                return ::core::result::Result::Err($crate::handle::Error::UnexpectedResume(
                    resume,
                    stringify!($pat)
                )
                .into())
            }
        }
    };
}

```
---
### `sync/src/metrics.rs`
*2025-05-18 23:58:49 | 6 KB*
```rust
use std::ops::Deref;
use std::sync::Arc;
use std::time::Instant;

use dashmap::DashMap;
use malachitebft_metrics::prometheus::metrics::counter::Counter;
use malachitebft_metrics::prometheus::metrics::histogram::{exponential_buckets, Histogram};
use malachitebft_metrics::SharedRegistry;

pub type DecidedValuesMetrics = Inner;

#[derive(Clone, Debug)]
pub struct Metrics(Arc<DecidedValuesMetrics>);

impl Deref for Metrics {
    type Target = Inner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[derive(Debug)]
pub struct Inner {
    requests_sent: Counter,
    requests_received: Counter,
    responses_sent: Counter,
    responses_received: Counter,
    client_latency: Histogram,
    server_latency: Histogram,
    request_timeouts: Counter,

    instant_request_sent: Arc<DashMap<(u64, i64), Instant>>,
    instant_request_received: Arc<DashMap<(u64, i64), Instant>>,
}

impl Inner {
    pub fn new() -> Self {
        Self {
            requests_sent: Counter::default(),
            requests_received: Counter::default(),
            responses_sent: Counter::default(),
            responses_received: Counter::default(),
            client_latency: Histogram::new(exponential_buckets(0.1, 2.0, 20)),
            server_latency: Histogram::new(exponential_buckets(0.1, 2.0, 20)),
            request_timeouts: Counter::default(),
            instant_request_sent: Arc::new(DashMap::new()),
            instant_request_received: Arc::new(DashMap::new()),
        }
    }
}

impl Default for Inner {
    fn default() -> Self {
        Self::new()
    }
}

impl Metrics {
    pub fn new() -> Self {
        Self(Arc::new(DecidedValuesMetrics::new()))
    }

    fn decided_values(&self) -> &DecidedValuesMetrics {
        &self.0
    }

    pub fn register(registry: &SharedRegistry) -> Self {
        let metrics = Self::new();

        registry.with_prefix("malachitebft_sync", |registry| {
            // Value sync related metrics
            registry.register(
                "value_requests_sent",
                "Number of ValueSync requests sent",
                metrics.decided_values().requests_sent.clone(),
            );

            registry.register(
                "value_requests_received",
                "Number of ValueSync requests received",
                metrics.decided_values().requests_received.clone(),
            );

            registry.register(
                "value_responses_sent",
                "Number of ValueSync responses sent",
                metrics.decided_values().responses_sent.clone(),
            );

            registry.register(
                "value_responses_received",
                "Number of ValueSync responses received",
                metrics.decided_values().responses_received.clone(),
            );

            registry.register(
                "value_client_latency",
                "Interval of time between when request was sent and response was received",
                metrics.decided_values().client_latency.clone(),
            );

            registry.register(
                "value_server_latency",
                "Interval of time between when request was received and response was sent",
                metrics.decided_values().server_latency.clone(),
            );

            registry.register(
                "value_request_timeouts",
                "Number of ValueSync request timeouts",
                metrics.decided_values().request_timeouts.clone(),
            );
        });

        metrics
    }

    pub fn decided_value_request_sent(&self, height: u64) {
        self.decided_values().requests_sent.inc();
        self.decided_values()
            .instant_request_sent
            .insert((height, -1), Instant::now());
    }

    pub fn decided_value_request_received(&self, height: u64) {
        self.decided_values().requests_received.inc();
        self.decided_values()
            .instant_request_received
            .insert((height, -1), Instant::now());
    }

    pub fn decided_value_response_sent(&self, height: u64) {
        self.decided_values().responses_sent.inc();

        if let Some((_, instant)) = self
            .decided_values()
            .instant_request_received
            .remove(&(height, -1))
        {
            self.decided_values()
                .server_latency
                .observe(instant.elapsed().as_secs_f64());
        }
    }

    pub fn decided_value_response_received(&self, height: u64) {
        self.decided_values().responses_received.inc();

        if let Some((_, instant)) = self
            .decided_values()
            .instant_request_sent
            .remove(&(height, -1))
        {
            self.decided_values()
                .client_latency
                .observe(instant.elapsed().as_secs_f64());
        }
    }

    pub fn decided_value_request_timed_out(&self, height: u64) {
        self.decided_values().request_timeouts.inc();
        self.decided_values()
            .instant_request_sent
            .remove(&(height, 0));
    }
}

impl Default for Metrics {
    fn default() -> Self {
        Self::new()
    }
}

```
---
### `sync/src/rpc.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use async_trait::async_trait;
use bytes::Bytes;
use libp2p::futures::{io, AsyncRead, AsyncWrite};
use libp2p::StreamProtocol;

use crate::behaviour::Config;
use crate::types::{RawRequest, RawResponse};

#[derive(Copy, Clone)]
pub struct Codec {
    config: Config,
}

impl Codec {
    pub fn new(config: Config) -> Self {
        Self { config }
    }
}

#[async_trait]
impl libp2p::request_response::Codec for Codec {
    type Protocol = StreamProtocol;

    type Request = RawRequest;
    type Response = RawResponse;

    async fn read_request<T>(&mut self, _: &Self::Protocol, io: &mut T) -> io::Result<Self::Request>
    where
        T: AsyncRead + Unpin + Send,
    {
        read_length_prefixed(io, self.config.max_request_size)
            .await
            .map(RawRequest)
    }

    async fn read_response<T>(
        &mut self,
        _: &Self::Protocol,
        io: &mut T,
    ) -> io::Result<Self::Response>
    where
        T: AsyncRead + Unpin + Send,
    {
        read_length_prefixed(io, self.config.max_response_size)
            .await
            .map(RawResponse)
    }

    async fn write_request<T>(
        &mut self,
        _: &Self::Protocol,
        io: &mut T,
        req: Self::Request,
    ) -> io::Result<()>
    where
        T: AsyncWrite + Unpin + Send,
    {
        write_length_prefixed(io, req.0, self.config.max_request_size).await
    }

    async fn write_response<T>(
        &mut self,
        _: &Self::Protocol,
        io: &mut T,
        res: Self::Response,
    ) -> io::Result<()>
    where
        T: AsyncWrite + Unpin + Send,
    {
        write_length_prefixed(io, res.0, self.config.max_response_size).await
    }
}

const U32_LENGTH: usize = size_of::<u32>();

async fn write_length_prefixed<T>(dst: &mut T, data: Bytes, max_len: usize) -> io::Result<()>
where
    T: AsyncWrite + Unpin + Send,
{
    use io::AsyncWriteExt;

    let len = data.len();
    if len > max_len || len > u32::MAX as usize {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "data too large",
        ));
    }

    dst.write_all(&(len as u32).to_be_bytes()).await?;
    dst.write_all(&data).await?;
    dst.flush().await?;

    Ok(())
}

async fn read_length_prefixed<T>(src: &mut T, max_len: usize) -> io::Result<Bytes>
where
    T: AsyncRead + Unpin + Send,
{
    use io::AsyncReadExt;

    let mut len_bytes = [0u8; U32_LENGTH];
    src.read_exact(&mut len_bytes).await?;
    let len = u32::from_be_bytes(len_bytes) as usize;

    if len > max_len {
        return Err(io::Error::new(io::ErrorKind::InvalidData, "data too large"));
    }

    let mut data = vec![0u8; len];
    src.read_exact(&mut data).await?;
    Ok(Bytes::from(data))
}

```
---
### `sync/src/state.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::collections::BTreeMap;

use rand::seq::IteratorRandom;

use malachitebft_core_types::{Context, Height, Round};
use malachitebft_peer::PeerId;

use crate::Status;

pub struct State<Ctx>
where
    Ctx: Context,
{
    rng: Box<dyn rand::RngCore + Send>,

    /// Consensus has started
    pub started: bool,

    /// Height of last decided value
    pub tip_height: Ctx::Height,

    /// Height currently syncing.
    pub sync_height: Ctx::Height,

    /// Decided value requests for these heights have been sent out to peers.
    pub pending_decided_value_requests: BTreeMap<Ctx::Height, PeerId>,

    /// The set of peers we are connected to in order to get values, certificates and votes.
    /// TODO - For now value and vote sync peers are the same. Might need to revise in the future.
    pub peers: BTreeMap<PeerId, Status<Ctx>>,
}

impl<Ctx> State<Ctx>
where
    Ctx: Context,
{
    pub fn new(rng: Box<dyn rand::RngCore + Send>) -> Self {
        Self {
            rng,
            started: false,
            tip_height: Ctx::Height::ZERO,
            sync_height: Ctx::Height::ZERO,
            pending_decided_value_requests: BTreeMap::new(),
            peers: BTreeMap::new(),
        }
    }

    pub fn update_status(&mut self, status: Status<Ctx>) {
        self.peers.insert(status.peer_id, status);
    }

    /// Select at random a peer that is currently running consensus at `height` and round >= `round`.
    /// TODO: Potentially extend `Status` to include consensus height and round.
    pub fn random_peer_with_sync_at(
        &mut self,
        sync_height: Ctx::Height,
        _round: Round,
    ) -> Option<PeerId> {
        let tip_height = sync_height.decrement().unwrap_or(sync_height);
        self.random_peer_with_tip_at(tip_height)
    }

    /// Select at random a peer whose tip is at the given height.
    pub fn random_peer_with_tip_at(&mut self, height: Ctx::Height) -> Option<PeerId> {
        self.peers
            .iter()
            .filter_map(move |(&peer, status)| (status.tip_height == height).then_some(peer))
            .choose_stable(&mut self.rng)
    }

    /// Select at random a peer whose tip at or above the given height.
    pub fn random_peer_with_tip_at_or_above(&mut self, height: Ctx::Height) -> Option<PeerId>
    where
        Ctx: Context,
    {
        self.peers
            .iter()
            .filter_map(move |(&peer, status)| (status.tip_height >= height).then_some(peer))
            .choose_stable(&mut self.rng)
    }

    /// Select at random a peer that that we know is at or above the given height, except the given one.
    pub fn random_peer_with_tip_at_or_above_except(
        &mut self,
        height: Ctx::Height,
        except: PeerId,
    ) -> Option<PeerId> {
        self.peers
            .iter()
            .filter_map(move |(&peer, status)| (status.tip_height >= height).then_some(peer))
            .filter(|&peer| peer != except)
            .choose_stable(&mut self.rng)
    }

    pub fn store_pending_decided_value_request(&mut self, height: Ctx::Height, peer: PeerId) {
        self.pending_decided_value_requests.insert(height, peer);
    }

    pub fn remove_pending_decided_value_request(&mut self, height: Ctx::Height) {
        self.pending_decided_value_requests.remove(&height);
    }

    pub fn has_pending_decided_value_request(&self, height: &Ctx::Height) -> bool {
        self.pending_decided_value_requests.contains_key(height)
    }
}

```
---
### `sync/src/types.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use bytes::Bytes;
use derive_where::derive_where;
use displaydoc::Display;
use libp2p::request_response;
use serde::{Deserialize, Serialize};

use malachitebft_core_types::{CommitCertificate, Context};
pub use malachitebft_peer::PeerId;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Display)]
#[displaydoc("{0}")]
pub struct InboundRequestId(String);

impl InboundRequestId {
    pub fn new(id: impl ToString) -> Self {
        Self(id.to_string())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Display)]
#[displaydoc("{0}")]
pub struct OutboundRequestId(String);

impl OutboundRequestId {
    pub fn new(id: impl ToString) -> Self {
        Self(id.to_string())
    }
}

pub type ResponseChannel = request_response::ResponseChannel<RawResponse>;

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct Status<Ctx: Context> {
    pub peer_id: PeerId,
    pub tip_height: Ctx::Height,
    pub history_min_height: Ctx::Height,
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Request<Ctx: Context> {
    ValueRequest(ValueRequest<Ctx>),
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub enum Response<Ctx: Context> {
    ValueResponse(ValueResponse<Ctx>),
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct ValueRequest<Ctx: Context> {
    pub height: Ctx::Height,
}

impl<Ctx: Context> ValueRequest<Ctx> {
    pub fn new(height: Ctx::Height) -> Self {
        Self { height }
    }
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct ValueResponse<Ctx: Context> {
    pub height: Ctx::Height,
    pub value: Option<RawDecidedValue<Ctx>>,
}

impl<Ctx: Context> ValueResponse<Ctx> {
    pub fn new(height: Ctx::Height, value: Option<RawDecidedValue<Ctx>>) -> Self {
        Self { height, value }
    }
}

#[derive_where(Clone, Debug, PartialEq, Eq)]
pub struct RawDecidedValue<Ctx: Context> {
    pub value_bytes: Bytes,
    pub certificate: CommitCertificate<Ctx>,
}

impl<Ctx: Context> RawDecidedValue<Ctx> {
    pub fn new(value_bytes: Bytes, certificate: CommitCertificate<Ctx>) -> Self {
        Self {
            value_bytes,
            certificate,
        }
    }
}

#[derive(Clone, Debug)]
pub enum RawMessage {
    Request {
        request_id: request_response::InboundRequestId,
        peer: PeerId,
        body: Bytes,
    },
    Response {
        request_id: request_response::OutboundRequestId,
        peer: PeerId,
        body: Bytes,
    },
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct RawRequest(pub Bytes);

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct RawResponse(pub Bytes);

```
---
### `test/Cargo.toml`
*2025-05-18 23:58:49 | 2 KB*
```toml
[package]
name = "informalsystems-malachitebft-test"
description = "Testing framework for the Malachite consensus engine"
publish = false

version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
malachitebft-engine = { workspace = true }
malachitebft-app = { workspace = true }
malachitebft-codec = { workspace = true }
malachitebft-core-types = { workspace = true }
malachitebft-config = { workspace = true }
malachitebft-core-consensus = { workspace = true }
malachitebft-proto = { workspace = true }
malachitebft-signing-ed25519 = { workspace = true, features = [
    "rand",
    "serde",
] }
malachitebft-sync = { workspace = true }

async-trait = { workspace = true }
base64 = { workspace = true }
bytes = { workspace = true }
ed25519-consensus = { workspace = true }
eyre = { workspace = true }
hex = { workspace = true }
prost = { workspace = true }
prost-types = { workspace = true }
rand = { workspace = true }
serde = { workspace = true, features = ["derive", "rc"] }
serde_json = { workspace = true }
sha3 = { workspace = true }
signature = { workspace = true }
tokio = { workspace = true }

[dev-dependencies]
malachitebft-test-app.workspace = true
malachitebft-test-framework.workspace = true

bytesize.workspace = true
tempfile.workspace = true
tokio.workspace = true
tracing.workspace = true

[build-dependencies]
prost-build = { workspace = true }
protox = { workspace = true }

[lints]
workspace = true

```
---
### `test/app/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-test-app"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish = false

[dependencies]
async-trait.workspace = true
bytes.workspace = true
color-eyre.workspace = true
config.workspace = true
derive-where.workspace = true
eyre.workspace = true
itertools.workspace = true
prost.workspace = true
rand.workspace = true
redb.workspace = true
serde.workspace = true
serde_json.workspace = true
sha3.workspace = true
toml.workspace = true
thiserror.workspace = true
tokio.workspace = true
tracing.workspace = true

malachitebft-app-channel.workspace = true
malachitebft-proto.workspace = true
malachitebft-test.workspace = true
malachitebft-test-cli.workspace = true

[dev-dependencies]
malachitebft-test-framework.workspace = true

[lints]
workspace = true

```
---
### `test/app/config.toml`
*2025-05-18 23:58:49 | 11 KB*
```toml
#######################################################################
###                   Main Base Config Options                      ###
#######################################################################

# A custom human readable name for this node
# Override with MALACHITE__MONIKER env variable
moniker = "malachite"

#######################################################
###          Logging Configuration Options          ###
#######################################################
[logging]
# The application log level.
# Override with MALACHITE__LOGGING__LOG_LEVEL env variable.
# See more: https://docs.rs/env_logger/latest/env_logger/#enabling-logging
log_level = "debug"

# The log format.
# Possible values:
# - "plaintext": log entries are in colorful text
# - "json": log entries are presented as JSON objects
# Override with MALACHITE__LOGGING__LOG_FORMAT env variable.
log_format = "plaintext"


#######################################################
###         Consensus Configuration Options         ###
#######################################################
[consensus]

## Timeouts

# How long we wait for a proposal block before prevoting nil
# Override with MALACHITE__CONSENSUS__TIMEOUT_PROPOSE env variable
timeout_propose = "3s"

# How much timeout_propose increases with each round
timeout_propose_delta = "500ms"

# How long we wait after receiving +2/3 prevotes for anything (ie. not a single block or nil)
# Override with MALACHITE__CONSENSUS__TIMEOUT_PREVOTE env variable
timeout_prevote = "1s"

# How much the timeout_prevote increases with each round
timeout_prevote_delta = "500ms"

# How long we wait after receiving +2/3 precommits for anything (ie. not a single block or nil)
# Override with MALACHITE__CONSENSUS__TIMEOUT_PRECOMMIT env variable
timeout_precommit = "1s"

# How much the timeout_precommit increases with each round
timeout_precommit_delta = "500ms"

# How long we wait after committing a block, before starting on the new
# height (this gives us a chance to receive some more precommits, even
# though we already have +2/3).
# Override with MALACHITE__CONSENSUS__TIMEOUT_COMMIT env variable
timeout_commit = "0s"


# How long we wait after entering a round before starting the rebroadcast liveness protocol
# Override with MALACHITE__CONSENSUS__TIMEOUT_REBROADCAST env variable
timeout_rebroadcast = "5s"

# The message(s) required to carry the value payload.
# Available options are:
# - "parts-only": Full value is included in the proposal parts and there is no explicit Proposal message (default)
# - "proposal-only": Full value is included in the (explicit) consensus Proposal message (not supported by test app)
# - "proposal-and-parts": Both proposal parts and Proposal message are required (similar to CometBFT implementation of Tendermint, not supported by test app)
# Override with MALACHITE__CONSENSUS__VALUE_PAYLOAD env variable
value_payload = "parts-only"

# VoteSync configuration options
[consensus.vote_sync]
# The mode of vote synchronization
# - "request-response": The lagging node sends a request to a peer for the missing votes
# - "rebroadcast": Nodes rebroadcast their last vote to all peers
# Override with MALACHITE__CONSENSUS__VOTE_SYNC__MODE env variable
mode = "request-response"

#######################################################
###       Consensus P2P Configuration Options       ###
#######################################################
[consensus.p2p]

# Address to listen for incoming connections
# Override with MALACHITE__CONSENSUS__P2P__LISTEN_ADDR env variable
listen_addr = "/ip4/0.0.0.0/udp/0/quic-v1"

# List of nodes to keep persistent connections to
# Override with MALACHITE__CONSENSUS__P2P__PERSISTENT_PEERS env variable
persistent_peers = []

# Transport protocol to use for P2P communication
# Valid values:
# - "tcp": TCP + Noise
# - "quic": QUIC
# Override with MALACHITE__CONSENSUS__P2P__TRANSPORT env variable
transport = "tcp"

# Enable the discovery protocol to find more peers
# Override with MALACHITE__CONSENSUS__P2P__DISCOVERY__ENABLED env variable
discovery = { enabled = true }

# The maximum size of messages to send over pub-sub
# Must be larger than the maximum block part size.
# Override with MALACHITE__CONSENSUS__P2P__PUBSUB_MAX_SIZE env variable
pubsub_max_size = "4 MiB"

# The maximum size of messages to send over RPC
# Must be larger than the maximum block size.
# Override with MALACHITE__CONSENSUS__P2P__RPC_MAX_SIZE env variable
rpc_max_size = "10 MiB"

#######################################################
###  Consensus P2P Protocol Configuration Options   ###
#######################################################
# GossipSub v1.1 is the default and recommended protocol for Consensus P2P.
[consensus.p2p.protocol]
# Valid options are "gossipsub" and "broadcast".
# Broadcast is an experimental protocol with no additional configuration options.
type = "gossipsub"

# GossipSub only. Target number of peers for the mesh network (D in the GossipSub spec)
mesh_n = 6

# GossipSub only. Maximum number of peers in mesh network before removing some (D_high in the GossipSub spec)
mesh_n_high = 12

# GossipSub only. Minimum number of peers in mesh network before adding more (D_low in the spec)
mesh_n_low = 4

# GossipSub only. Minimum number of outbound peers in the mesh network before adding more (D_out in the spec).
# This value must be smaller or equal than `mesh_n / 2` and smaller than `mesh_n_low`.
# When this value is set to 0 or does not meet the above constraints,
# it will be calculated as `max(1, min(mesh_n / 2, mesh_n_low - 1))`
mesh_outbound_min = 2

#######################################################
###         ValueSync Configuration Options         ###
#######################################################
[value_sync]
# Enable the ValueSync synchronization protocol
# Override with MALACHITE__VALUE_SYNC__ENABLED env variable
enabled = true

# Interval at which to update other peers of our status
# Override with MALACHITE__VALUE_SYNC__STATUS_UPDATE_INTERVAL env variable
status_update_interval = "10s"

# Timeout duration for ValueSync requests
# Override with MALACHITE__VALUE_SYNC__REQUEST_TIMEOUT env variable
request_timeout = "10s"

#######################################################
###          Mempool Configuration Options          ###
#######################################################
[mempool]

# Maximum number of transactions in the mempool
# Override with MALACHITE__MEMPOOL__MAX_TX_COUNT env variable
max_tx_count = 10000

# Maximum number of transactions to gossip at once in a batch.
# If set to 0, mempool does not gossip the transactions.
# Override with MALACHITE__MEMPOOL__GOSSIP_BATCH_SIZE
gossip_batch_size = 0

#######################################################
###       Mempool P2P Configuration Options       ###
#######################################################
[mempool.p2p]

# Address to listen for incoming connections
listen_addr = "/ip4/0.0.0.0/udp/0/quic-v1"

# List of nodes to keep persistent connections to
persistent_peers = []

# Transport protocol to use for P2P communication
# Valid values:
# - "tcp": TCP + Noise
# - "quic": QUIC
transport = "tcp"

# These have no effects on the mempool yet
pubsub_max_size = "4 MiB"
rpc_max_size = "10 MiB"

#######################################################
###   Mempool P2P Protocol Configuration Options    ###
#######################################################

# /!\ This setting has no effect on the mempool yet /!\
# GossipSub v1.1 is the default and recommended protocol for Mempool P2P.
[mempool.p2p.protocol]
# Valid options are "gossipsub" and "broadcast".
# Broadcast is an experimental protocol with no additional configuration options.
type = "gossipsub"


#######################################################
###         Sync Configuration Options         ###
#######################################################
[sync]
# Enable the synchronization protocol
# Override with MALACHITE__SYNC__ENABLED env variable
enabled = true

# Interval at which to update other peers of our status
# Override with MALACHITE__SYNC__STATUS_UPDATE_INTERVAL env variable
status_update_interval = "10s"

# Timeout duration for sync requests
# Override with MALACHITE__SYNC__REQUEST_TIMEOUT env variable
request_timeout = "10s"

#######################################################
###          Metrics Configuration Options          ###
#######################################################
[metrics]

# Enable the metrics server
# Override with MALACHITE__METRICS__ENABLED env variable
enabled = true

# Metrics are exported at `http://127.0.0.1:9000/metrics`
# Override with MALACHITE__METRICS__LISTEN_ADDR env variable
listen_addr = "127.0.0.1:9000"

#######################################################
###          Runtime Configuration Options          ###
#######################################################
[runtime]

# The flavor of Tokio runtime to use.
# Possible values:
# - "single_threaded": A single threaded runtime (default)
# - "multi_threaded":  A multi-threaded runtime
# Override with MALACHITE__RUNTIME__FLAVOR env variable
flavor = "single_threaded"

# For the multi-threaded runtime only.
# Sets the number of worker threads the Runtime will use.
# If set to 0, defaults to the number of cores available to the system.
# Override with MALACHITE__RUNTIME__WORKER_THREADS env variable
# worker_threads = 4


#######################################################
###          Test Node Configuration Options         ###
#######################################################
[test]

# Maximum block size
# Override with MALACHITE__TEST__MAX_BLOCK_SIZE env variable
max_block_size = "1 MiB"
# Override with MALACHITE__TEST__TX_SIZE env variable
tx_size = "1 KiB"
# Override with MALACHITE__TEST__TXS_PER_PART env variable
txs_per_part = 256
# Override with MALACHITE__TEST__TIME_ALLOWANCE_FACTOR env variable
time_allowance_factor = 0.5
# Override with MALACHITE__TEST__EXEC_TIME_PER_TX env variable
exec_time_per_tx = "1ms"
# Maximum number of blocks, relative to the current block, that can be kept in the block store.
# A value of 0 indicates that no blocks are pruned.
# Override with MALACHITE__TEST__MAX_RETAIN_BLOCKS env variable
max_retain_blocks = 1000
# Override with MALACHITE__TEST__VOTE_EXTENSIONS__ENABLED and MALACHITE__TEST__VOTE_EXTENSIONS__SIZE env variables
vote_extensions = { enabled = false, size = "0 KB" }


```
---
### `test/app/src/app.rs`
*2025-05-18 23:58:49 | 16 KB*
```rust
use std::time::Duration;

use eyre::eyre;
use tokio::time::sleep;
use tracing::{debug, error, info};

// use malachitebft_app_channel::app::config::ValuePayload;
use malachitebft_app_channel::app::streaming::StreamContent;
use malachitebft_app_channel::app::types::codec::Codec;
use malachitebft_app_channel::app::types::core::{Round, Validity};
use malachitebft_app_channel::app::types::sync::RawDecidedValue;
use malachitebft_app_channel::app::types::{LocallyProposedValue, ProposedValue};
use malachitebft_app_channel::{AppMsg, Channels, ConsensusMsg, NetworkMsg};
use malachitebft_test::codec::proto::ProtobufCodec;
use malachitebft_test::{Genesis, Height, TestContext};

use crate::state::{decode_value, State};

pub async fn run(
    genesis: Genesis,
    state: &mut State,
    channels: &mut Channels<TestContext>,
) -> eyre::Result<()> {
    while let Some(msg) = channels.consensus.recv().await {
        match msg {
            // The first message to handle is the `ConsensusReady` message, signaling to the app
            // that Malachite is ready to start consensus
            AppMsg::ConsensusReady { reply } => {
                let start_height = state
                    .store
                    .max_decided_value_height()
                    .await
                    .map(|height| height.increment())
                    .unwrap_or_else(|| Height::new(1));

                info!(%start_height, "Consensus is ready");

                sleep(Duration::from_millis(200)).await;

                // We can simply respond by telling the engine to start consensus
                // at the next height, and provide it with the appropriate validator set
                let validator_set = state
                    .ctx
                    .middleware()
                    .get_validator_set(&state.ctx, start_height, start_height, &genesis)
                    .expect("Validator set should be available");

                if reply.send((start_height, validator_set)).is_err() {
                    error!("Failed to send ConsensusReady reply");
                }
            }

            // The next message to handle is the `StartRound` message, signaling to the app
            // that consensus has entered a new round (including the initial round 0)
            AppMsg::StartedRound {
                height,
                round,
                proposer,
                reply_value,
            } => {
                info!(%height, %round, %proposer, "Started round");

                // We can use that opportunity to update our internal state
                state.current_height = height;
                state.current_round = round;
                state.current_proposer = Some(proposer);

                // If we have already built or seen values for this height and round,
                // send them back to consensus. This may happen when we are restarting after a crash.
                let proposals = state.store.get_undecided_proposals(height, round).await?;
                if reply_value.send(proposals).is_err() {
                    error!("Failed to send undecided proposals");
                }
            }

            // At some point, we may end up being the proposer for that round, and the engine
            // will then ask us for a value to propose to the other validators.
            AppMsg::GetValue {
                height,
                round,
                timeout: _,
                reply,
            } => {
                // NOTE: We can ignore the timeout as we are building the value right away.
                // If we were let's say reaping as many txes from a mempool and executing them,
                // then we would need to respect the timeout and stop at a certain point.

                info!(%height, %round, "Consensus is requesting a value to propose");
                tracing::debug!(%height, %round, "Middleware: {:?}", state.ctx.middleware());

                // Here it is important that, if we have previously built a value for this height and round,
                // we send back the very same value.
                let proposal = match state.get_previously_built_value(height, round).await? {
                    Some(mut proposal) => {
                        state
                            .ctx
                            .middleware()
                            .on_propose_value(&state.ctx, &mut proposal, true);

                        proposal
                    }
                    None => {
                        // If we have not previously built a value for that very same height and round,
                        // we need to create a new value to propose and send it back to consensus.
                        let mut proposal = state.propose_value(height, round).await?;

                        state
                            .ctx
                            .middleware()
                            .on_propose_value(&state.ctx, &mut proposal, false);

                        proposal
                    }
                };

                // Send it to consensus
                if reply.send(proposal.clone()).is_err() {
                    error!("Failed to send GetValue reply");
                }

                // The POL round is always nil when we propose a newly built value.
                // See L15/L18 of the Tendermint algorithm.
                let pol_round = Round::Nil;

                // Now what's left to do is to break down the value to propose into parts,
                // and send those parts over the network to our peers, for them to re-assemble the full value.
                for stream_message in state.stream_proposal(proposal, pol_round) {
                    debug!(%height, %round, "Streaming proposal part: {stream_message:?}");

                    channels
                        .network
                        .send(NetworkMsg::PublishProposalPart(stream_message))
                        .await?;
                }
            }

            // On the receiving end of these proposal parts (ie. when we are not the proposer),
            // we need to process these parts and re-assemble the full value.
            // To this end, we store each part that we receive and assemble the full value once we
            // have all its constituent parts. Then we send that value back to consensus for it to
            // consider and vote for or against it (ie. vote `nil`), depending on its validity.
            AppMsg::ReceivedProposalPart { from, part, reply } => {
                let part_type = match &part.content {
                    StreamContent::Data(part) => part.get_type(),
                    StreamContent::Fin => "end of stream",
                };

                debug!(%from, %part.sequence, part.type = %part_type, "Received proposal part");

                let proposed_value = state.received_proposal_part(from, part).await?;

                if reply.send(proposed_value).is_err() {
                    error!("Failed to send ReceivedProposalPart reply");
                }
            }

            // In some cases, e.g. to verify the signature of a vote received at a higher height
            // than the one we are at (e.g. because we are lagging behind a little bit),
            // the engine may ask us for the validator set at that height.
            //
            // We send back the appropriate validator set for that height.
            AppMsg::GetValidatorSet { height, reply } => {
                let validator_set = state.ctx.middleware().get_validator_set(
                    &state.ctx,
                    state.current_height,
                    height,
                    &genesis,
                );

                if reply.send(validator_set).is_err() {
                    error!("Failed to send GetValidatorSet reply");
                }
            }

            // After some time, consensus will finally reach a decision on the value
            // to commit for the current height, and will notify the application,
            // providing it with a commit certificate which contains the ID of the value
            // that was decided on as well as the set of commits for that value,
            // ie. the precommits together with their (aggregated) signatures.
            AppMsg::Decided {
                certificate,
                extensions: _,
                reply,
            } => {
                info!(
                    height = %certificate.height,
                    round = %certificate.round,
                    value = %certificate.value_id,
                    "Consensus has decided on value, committing..."
                );
                assert!(!certificate.commit_signatures.is_empty());

                // When that happens, we store the decided value in our store
                match state.commit(certificate).await {
                    Ok(_) => {
                        // And then we instruct consensus to start the next height
                        let validator_set = state
                            .ctx
                            .middleware()
                            .get_validator_set(
                                &state.ctx,
                                state.current_height,
                                state.current_height,
                                &genesis,
                            )
                            .expect("Validator set should be available");

                        if reply
                            .send(ConsensusMsg::StartHeight(
                                state.current_height,
                                validator_set,
                            ))
                            .is_err()
                        {
                            error!("Failed to send StartHeight reply");
                        }
                    }
                    Err(e) => {
                        // Commit failed, restart the height
                        error!("Commit failed: {e}");
                        error!("Restarting height {}", state.current_height);

                        let validator_set = state
                            .ctx
                            .middleware()
                            .get_validator_set(
                                &state.ctx,
                                state.current_height,
                                state.current_height,
                                &genesis,
                            )
                            .expect("Validator set should be available");

                        if reply
                            .send(ConsensusMsg::RestartHeight(
                                state.current_height,
                                validator_set,
                            ))
                            .is_err()
                        {
                            error!("Failed to send RestartHeight reply");
                        }
                    }
                }
                sleep(Duration::from_millis(500)).await;
            }

            // It may happen that our node is lagging behind its peers. In that case,
            // a synchronization mechanism will automatically kick to try and catch up to
            // our peers. When that happens, some of these peers will send us decided values
            // for the heights in between the one we are currently at (included) and the one
            // that they are at. When the engine receives such a value, it will forward to the application
            // to decode it from its wire format and send back the decoded value to consensus.
            AppMsg::ProcessSyncedValue {
                height,
                round,
                proposer,
                value_bytes,
                reply,
            } => {
                info!(%height, %round, "Processing synced value");

                let value = decode_value(value_bytes);

                let proposal = ProposedValue {
                    height,
                    round,
                    valid_round: Round::Nil,
                    proposer,
                    value,
                    validity: Validity::Valid,
                };

                state.store_synced_value(proposal.clone()).await?;

                if reply.send(proposal).is_err() {
                    error!("Failed to send ProcessSyncedValue reply");
                }
            }

            // If, on the other hand, we are not lagging behind but are instead asked by one of
            // our peer to help them catch up because they are the one lagging behind,
            // then the engine might ask the application to provide with the value
            // that was decided at some lower height. In that case, we fetch it from our store
            // and send it to consensus.
            AppMsg::GetDecidedValue { height, reply } => {
                info!(%height, "Received sync request for decided value");

                let decided_value = state.get_decided_value(height).await;
                info!(%height, "Found decided value: {decided_value:?}");

                let raw_decided_value = decided_value.map(|decided_value| RawDecidedValue {
                    certificate: decided_value.certificate,
                    value_bytes: ProtobufCodec.encode(&decided_value.value).unwrap(), // FIXME: unwrap
                });

                if reply.send(raw_decided_value).is_err() {
                    error!("Failed to send GetDecidedValue reply");
                }
            }

            // In order to figure out if we can help a peer that is lagging behind,
            // the engine may ask us for the height of the earliest available value in our store.
            AppMsg::GetHistoryMinHeight { reply } => {
                let min_height = state.get_earliest_height().await;

                if reply.send(min_height).is_err() {
                    error!("Failed to send GetHistoryMinHeight reply");
                }
            }

            AppMsg::RestreamProposal {
                height,
                round,
                valid_round,
                address: _,
                value_id,
            } => {
                info!(%height, %valid_round, "Restreaming existing proposal...");

                //  Look for a proposal at valid_round or round(should be already stored)
                let proposal_round = if valid_round == Round::Nil {
                    round
                } else {
                    valid_round
                };
                //  Look for a proposal for the given value_id at valid_round (should be already stored)
                let proposal = state
                    .store
                    .get_undecided_proposal(height, proposal_round, value_id)
                    .await?;

                if let Some(proposal) = proposal {
                    assert_eq!(proposal.value.id(), value_id);

                    let locally_proposed_value = LocallyProposedValue {
                        height,
                        round,
                        value: proposal.value,
                    };

                    for stream_message in state.stream_proposal(locally_proposed_value, valid_round)
                    {
                        debug!(%height, %valid_round, "Publishing proposal part: {stream_message:?}");

                        channels
                            .network
                            .send(NetworkMsg::PublishProposalPart(stream_message))
                            .await?;
                    }
                }
            }

            AppMsg::ExtendVote { reply, .. } => {
                if reply.send(None).is_err() {
                    error!("Failed to send ExtendVote reply");
                }
            }

            AppMsg::VerifyVoteExtension { reply, .. } => {
                if reply.send(Ok(())).is_err() {
                    error!("Failed to send VerifyVoteExtension reply");
                }
            }
        }
    }

    // If we get there, it can only be because the channel we use to receive message
    // from consensus has been closed, meaning that the consensus actor has died.
    // We can do nothing but return an error here.
    Err(eyre!("Consensus channel closed unexpectedly"))
}

```
---
### `test/app/src/config.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::path::Path;

use serde::{Deserialize, Serialize};

use malachitebft_app_channel::app::node::NodeConfig;

pub use malachitebft_app_channel::app::config::{
    ConsensusConfig, LogFormat, LogLevel, LoggingConfig, MetricsConfig, RuntimeConfig, TestConfig,
    TimeoutConfig, ValueSyncConfig,
};

/// Malachite configuration options
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
pub struct Config {
    /// A custom human-readable name for this node
    pub moniker: String,

    /// Log configuration options
    pub logging: LoggingConfig,

    /// Consensus configuration options
    pub consensus: ConsensusConfig,

    /// ValueSync configuration options
    pub value_sync: ValueSyncConfig,

    /// Metrics configuration options
    pub metrics: MetricsConfig,

    /// Runtime configuration options
    pub runtime: RuntimeConfig,

    /// Test configuration
    pub test: TestConfig,
}

impl NodeConfig for Config {
    fn moniker(&self) -> &str {
        &self.moniker
    }

    fn consensus(&self) -> &ConsensusConfig {
        &self.consensus
    }

    fn value_sync(&self) -> &ValueSyncConfig {
        &self.value_sync
    }
}

/// load_config parses the environment variables and loads the provided config file path
/// to create a Config struct.
pub fn load_config(path: impl AsRef<Path>, prefix: Option<&str>) -> eyre::Result<Config> {
    ::config::Config::builder()
        .add_source(::config::File::from(path.as_ref()))
        .add_source(
            ::config::Environment::with_prefix(prefix.unwrap_or("MALACHITE")).separator("__"),
        )
        .build()?
        .try_deserialize()
        .map_err(Into::into)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_default_config_file() {
        let file = include_str!("../config.toml");
        let config = toml::from_str::<Config>(file).unwrap();
        assert_eq!(config.consensus.timeouts, TimeoutConfig::default());

        let tmp_file = std::env::temp_dir().join("config-test.toml");
        std::fs::write(&tmp_file, file).unwrap();

        let config = load_config(&tmp_file, None).unwrap();
        assert_eq!(config.consensus.timeouts, TimeoutConfig::default());

        std::fs::remove_file(tmp_file).unwrap();
    }
}

```
---
### `test/app/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod app;
pub mod config;
pub mod node;
pub mod state;
pub mod store;
pub mod streaming;

```
---
### `test/app/src/node.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
#![allow(clippy::too_many_arguments)]

use std::path::PathBuf;
use std::sync::Arc;

use async_trait::async_trait;
use malachitebft_test::middleware::{DefaultMiddleware, Middleware};
use rand::{CryptoRng, RngCore};
use tokio::task::JoinHandle;
use tracing::Instrument;

use malachitebft_app_channel::app::config::*;
use malachitebft_app_channel::app::events::{RxEvent, TxEvent};
use malachitebft_app_channel::app::node::{
    CanGeneratePrivateKey, CanMakeConfig, CanMakeGenesis, CanMakePrivateKeyFile, EngineHandle,
    MakeConfigSettings, Node, NodeHandle,
};
use malachitebft_app_channel::app::types::core::VotingPower;
use malachitebft_app_channel::app::types::Keypair;

// Use the same types used for integration tests.
// A real application would use its own types and context instead.
use malachitebft_test::codec::proto::ProtobufCodec;
use malachitebft_test::{
    Address, Ed25519Provider, Genesis, Height, PrivateKey, PublicKey, TestContext, Validator,
    ValidatorSet,
};

use crate::config::Config;
use crate::state::State;
use crate::store::Store;

pub struct Handle {
    pub app: JoinHandle<()>,
    pub engine: EngineHandle,
    pub tx_event: TxEvent<TestContext>,
}

#[async_trait]
impl NodeHandle<TestContext> for Handle {
    fn subscribe(&self) -> RxEvent<TestContext> {
        self.tx_event.subscribe()
    }

    async fn kill(&self, _reason: Option<String>) -> eyre::Result<()> {
        self.engine.actor.kill_and_wait(None).await?;
        self.app.abort();
        self.engine.handle.abort();
        Ok(())
    }
}

/// Main application struct implementing the consensus node functionality
#[derive(Clone)]
pub struct App {
    pub home_dir: PathBuf,
    pub config: Config,
    pub validator_set: ValidatorSet,
    pub private_key: PrivateKey,
    pub start_height: Option<Height>,
    pub middleware: Option<Arc<dyn Middleware>>,
}

#[async_trait]
impl Node for App {
    type Context = TestContext;
    type Config = Config;
    type Genesis = Genesis;
    type PrivateKeyFile = PrivateKey;
    type SigningProvider = Ed25519Provider;
    type NodeHandle = Handle;

    fn get_home_dir(&self) -> PathBuf {
        self.home_dir.to_owned()
    }

    fn load_config(&self) -> eyre::Result<Self::Config> {
        Ok(self.config.clone())
    }

    fn get_signing_provider(&self, private_key: PrivateKey) -> Self::SigningProvider {
        Ed25519Provider::new(private_key)
    }

    fn get_address(&self, pk: &PublicKey) -> Address {
        Address::from_public_key(pk)
    }

    fn get_public_key(&self, pk: &PrivateKey) -> PublicKey {
        pk.public_key()
    }

    fn get_keypair(&self, pk: PrivateKey) -> Keypair {
        Keypair::ed25519_from_bytes(pk.inner().to_bytes()).unwrap()
    }

    fn load_private_key(&self, file: Self::PrivateKeyFile) -> PrivateKey {
        file
    }

    fn load_private_key_file(&self) -> eyre::Result<Self::PrivateKeyFile> {
        Ok(self.private_key.clone())
    }

    fn load_genesis(&self) -> eyre::Result<Self::Genesis> {
        let validators = self
            .validator_set
            .validators
            .iter()
            .map(|v| (v.public_key, v.voting_power))
            .collect();

        Ok(self.make_genesis(validators))
    }

    async fn start(&self) -> eyre::Result<Handle> {
        let config = self.load_config()?;

        let span = tracing::error_span!("node", moniker = %config.moniker);
        let _guard = span.enter();

        let middleware = self
            .middleware
            .clone()
            .unwrap_or_else(|| Arc::new(DefaultMiddleware));

        let ctx = TestContext::with_middleware(middleware);
        let codec = ProtobufCodec;

        let public_key = self.get_public_key(&self.private_key);
        let address = self.get_address(&public_key);
        let signing_provider = self.get_signing_provider(self.private_key.clone());
        let genesis = self.load_genesis()?;

        let (mut channels, engine_handle) = malachitebft_app_channel::start_engine(
            ctx.clone(),
            codec,
            self.clone(),
            config.clone(),
            self.start_height,
            self.validator_set.clone(),
        )
        .await?;

        drop(_guard);

        let db_path = self.get_home_dir().join("db");
        std::fs::create_dir_all(&db_path)?;

        let store = Store::open(db_path.join("store.db")).await?;
        let start_height = self.start_height.unwrap_or_default();

        let mut state = State::new(
            ctx,
            config,
            genesis.clone(),
            address,
            start_height,
            store,
            signing_provider,
        );

        let tx_event = channels.events.clone();

        let app_handle = tokio::spawn(
            async move {
                if let Err(e) = crate::app::run(genesis, &mut state, &mut channels).await {
                    tracing::error!("Application has failed with an error: {e}");
                }
            }
            .instrument(span),
        );

        Ok(Handle {
            app: app_handle,
            engine: engine_handle,
            tx_event,
        })
    }

    async fn run(self) -> eyre::Result<()> {
        let handles = self.start().await?;
        handles.app.await.map_err(Into::into)
    }
}

impl CanMakeGenesis for App {
    fn make_genesis(&self, validators: Vec<(PublicKey, VotingPower)>) -> Self::Genesis {
        let validators = validators
            .into_iter()
            .map(|(pk, vp)| Validator::new(pk, vp));

        let validator_set = ValidatorSet::new(validators);

        Genesis { validator_set }
    }
}

impl CanGeneratePrivateKey for App {
    fn generate_private_key<R>(&self, rng: R) -> PrivateKey
    where
        R: RngCore + CryptoRng,
    {
        PrivateKey::generate(rng)
    }
}

impl CanMakePrivateKeyFile for App {
    fn make_private_key_file(&self, private_key: PrivateKey) -> Self::PrivateKeyFile {
        private_key
    }
}

impl CanMakeConfig for App {
    fn make_config(index: usize, total: usize, settings: MakeConfigSettings) -> Self::Config {
        make_config(index, total, settings)
    }
}

/// Generate configuration for node "index" out of "total" number of nodes.
fn make_config(index: usize, total: usize, settings: MakeConfigSettings) -> Config {
    use itertools::Itertools;
    use rand::seq::IteratorRandom;
    use rand::Rng;

    const CONSENSUS_BASE_PORT: usize = 27000;
    const METRICS_BASE_PORT: usize = 29000;

    let consensus_port = CONSENSUS_BASE_PORT + index;
    let metrics_port = METRICS_BASE_PORT + index;

    Config {
        moniker: format!("test-{}", index),
        consensus: ConsensusConfig {
            // Current test app does not support proposal-only value payload properly as Init does not include valid_round
            value_payload: ValuePayload::ProposalAndParts,
            timeouts: TimeoutConfig::default(),
            p2p: P2pConfig {
                protocol: PubSubProtocol::default(),
                listen_addr: settings.transport.multiaddr("127.0.0.1", consensus_port),
                persistent_peers: if settings.discovery.enabled {
                    let mut rng = rand::thread_rng();
                    let count = if total > 1 {
                        rng.gen_range(1..=(total / 2))
                    } else {
                        0
                    };
                    let peers = (0..total)
                        .filter(|j| *j != index)
                        .choose_multiple(&mut rng, count);

                    peers
                        .iter()
                        .unique()
                        .map(|index| {
                            settings
                                .transport
                                .multiaddr("127.0.0.1", CONSENSUS_BASE_PORT + index)
                        })
                        .collect()
                } else {
                    (0..total)
                        .filter(|j| *j != index)
                        .map(|j| {
                            settings
                                .transport
                                .multiaddr("127.0.0.1", CONSENSUS_BASE_PORT + j)
                        })
                        .collect()
                },
                discovery: settings.discovery,
                ..Default::default()
            },
        },
        metrics: MetricsConfig {
            enabled: true,
            listen_addr: format!("127.0.0.1:{metrics_port}").parse().unwrap(),
        },
        runtime: settings.runtime,
        value_sync: ValueSyncConfig::default(),
        logging: LoggingConfig::default(),
        test: TestConfig::default(),
    }
}

```
---
### `test/app/src/state.rs`
*2025-05-18 23:58:49 | 17 KB*
```rust
//! Internal state of the application. This is a simplified abstract to keep it simple.
//! A regular application would have mempool implemented, a proper database and input methods like RPC.

use std::collections::HashSet;

use bytes::Bytes;
use eyre::eyre;
use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};
use sha3::Digest;
use tracing::{debug, error};

use malachitebft_app_channel::app::consensus::ProposedValue;
use malachitebft_app_channel::app::streaming::{StreamContent, StreamId, StreamMessage};
use malachitebft_app_channel::app::types::codec::Codec;
use malachitebft_app_channel::app::types::core::{CommitCertificate, Round, Validity};
use malachitebft_app_channel::app::types::{LocallyProposedValue, PeerId};
use malachitebft_test::codec::proto::ProtobufCodec;
use malachitebft_test::{
    Address, Ed25519Provider, Genesis, Height, ProposalData, ProposalFin, ProposalInit,
    ProposalPart, TestContext, ValidatorSet, Value, ValueId,
};

use crate::config::Config;
use crate::store::{DecidedValue, Store};
use crate::streaming::{PartStreamsMap, ProposalParts};

/// Number of historical values to keep in the store
const HISTORY_LENGTH: u64 = 500;

/// Represents the internal state of the application node
/// Contains information about current height, round, proposals and blocks
pub struct State {
    pub ctx: TestContext,
    pub config: Config,
    pub genesis: Genesis,
    pub address: Address,
    pub current_height: Height,
    pub current_round: Round,
    pub current_proposer: Option<Address>,
    pub peers: HashSet<PeerId>,
    pub store: Store,

    signing_provider: Ed25519Provider,
    streams_map: PartStreamsMap,
    rng: StdRng,
}

impl State {
    /// Creates a new State instance with the given validator address and starting height
    pub fn new(
        ctx: TestContext,
        config: Config,
        genesis: Genesis,
        address: Address,
        height: Height,
        store: Store,
        signing_provider: Ed25519Provider,
    ) -> Self {
        Self {
            ctx,
            config,
            genesis,
            address,
            store,
            signing_provider,
            current_height: height,
            current_round: Round::new(0),
            current_proposer: None,
            streams_map: PartStreamsMap::new(),
            rng: StdRng::from_entropy(),
            peers: HashSet::new(),
        }
    }

    /// Returns the set of validators.
    pub fn get_validator_set(&self) -> &ValidatorSet {
        &self.genesis.validator_set
    }

    /// Returns the earliest height available in the state
    pub async fn get_earliest_height(&self) -> Height {
        self.store
            .min_decided_value_height()
            .await
            .unwrap_or_default()
    }

    /// Processes and adds a new proposal to the state if it's valid
    /// Returns Some(ProposedValue) if the proposal was accepted, None otherwise
    pub async fn received_proposal_part(
        &mut self,
        from: PeerId,
        part: StreamMessage<ProposalPart>,
    ) -> eyre::Result<Option<ProposedValue<TestContext>>> {
        let sequence = part.sequence;

        // Check if we have a full proposal
        let Some(parts) = self.streams_map.insert(from, part) else {
            return Ok(None);
        };

        // Check if the proposal is outdated
        if parts.height < self.current_height {
            debug!(
                height = %self.current_height,
                round = %self.current_round,
                part.height = %parts.height,
                part.round = %parts.round,
                part.sequence = %sequence,
                "Received outdated proposal part, ignoring"
            );

            return Ok(None);
        }

        // Verify the proposal signature
        match self.verify_proposal_signature(&parts) {
            Ok(()) => {
                // Signature verified successfully, continue processing
            }
            Err(SignatureVerificationError::MissingInitPart) => {
                return Err(eyre!(
                    "Expected to have full proposal but `Init` proposal part is missing for proposer: {}",
                    parts.proposer
                ));
            }
            Err(SignatureVerificationError::MissingFinPart) => {
                return Err(eyre!(
                    "Expected to have full proposal but `Fin` proposal part is missing for proposer: {}",
                    parts.proposer
                ));
            }
            Err(SignatureVerificationError::ProposerNotFound) => {
                error!(proposer = %parts.proposer, "Proposer not found in validator set");
                return Ok(None);
            }
            Err(SignatureVerificationError::InvalidSignature) => {
                error!(proposer = %parts.proposer, "Invalid signature in Fin part");
                return Ok(None);
            }
        }

        // Re-assemble the proposal from its parts
        let value = assemble_value_from_parts(parts)?;

        self.store.store_undecided_proposal(value.clone()).await?;

        Ok(Some(value))
    }

    /// Retrieves a decided block at the given height
    pub async fn get_decided_value(&self, height: Height) -> Option<DecidedValue> {
        self.store.get_decided_value(height).await.ok().flatten()
    }

    /// Commits a value with the given certificate, updating internal state
    /// and moving to the next height
    pub async fn commit(
        &mut self,
        certificate: CommitCertificate<TestContext>,
    ) -> eyre::Result<()> {
        let (height, round, value_id) =
            (certificate.height, certificate.round, certificate.value_id);

        // Get the first proposal with the given value id. There may be multiple identical ones
        // if peers have restreamed at different rounds.
        let Ok(Some(proposal)) = self
            .store
            .get_undecided_proposal_by_value_id(value_id)
            .await
        else {
            return Err(eyre!(
                "Trying to commit a value with value id {value_id} at height {height} and round {round} for which there is no proposal"
            ));
        };

        let middleware = self.ctx.middleware();
        debug!(%height, %round, "Middleware: {middleware:?}");

        match middleware.on_commit(&self.ctx, &certificate, &proposal) {
            // Commit was successful, move to next height
            Ok(()) => {
                self.store
                    .store_decided_value(&certificate, proposal.value)
                    .await?;

                // Prune the store, keep the last HISTORY_LENGTH decided values, remove all undecided proposals for the decided height
                let retain_height = Height::new(height.as_u64().saturating_sub(HISTORY_LENGTH));
                self.store.prune(height, retain_height).await?;

                // Move to next height
                self.current_height = self.current_height.increment();
                self.current_round = Round::Nil;

                Ok(())
            }
            // Commit failed, reset height
            Err(e) => {
                error!("Middleware commit failed: {e}");
                Err(eyre!("Resetting at height {height}"))
            }
        }
    }

    pub async fn store_synced_value(
        &mut self,
        proposal: ProposedValue<TestContext>,
    ) -> eyre::Result<()> {
        self.store.store_undecided_proposal(proposal).await?;
        Ok(())
    }

    /// Retrieves a previously built proposal value for the given height and round.
    /// Called by the consensus engine to re-use a previously built value.
    /// There should be at most one proposal for a given height and round when the proposer is not byzantine.
    /// We assume this implementation is not byzantine and we are the proposer for the given height and round.
    /// Therefore there must be a single proposal for the rounds where we are the proposer, with the proposer address matching our own.
    pub async fn get_previously_built_value(
        &self,
        height: Height,
        round: Round,
    ) -> eyre::Result<Option<LocallyProposedValue<TestContext>>> {
        let proposals = self.store.get_undecided_proposals(height, round).await?;

        assert!(
            proposals.len() <= 1,
            "There should be at most one proposal for a given height and round"
        );

        proposals
            .first()
            .map(|p| LocallyProposedValue::new(p.height, p.round, p.value.clone()))
            .map(Some)
            .map(Ok)
            .unwrap_or_else(|| Ok(None))
    }

    /// Creates a new proposal value for the given height and round
    async fn create_proposal(
        &mut self,
        height: Height,
        round: Round,
    ) -> eyre::Result<ProposedValue<TestContext>> {
        assert_eq!(height, self.current_height);
        assert_eq!(round, self.current_round);

        // Create a new value
        let value = self.make_value();

        let proposal = ProposedValue {
            height,
            round,
            valid_round: Round::Nil,
            proposer: self.address, // We are the proposer
            value,
            validity: Validity::Valid, // Our proposals are de facto valid
        };

        // Insert the new proposal into the undecided proposals
        self.store
            .store_undecided_proposal(proposal.clone())
            .await?;

        Ok(proposal)
    }

    /// Make up a new value to propose
    /// A real application would have a more complex logic here,
    /// typically reaping transactions from a mempool and executing them against its state,
    /// before computing the merkle root of the new app state.
    fn make_value(&mut self) -> Value {
        let value = self.rng.gen_range(100..=100000);
        Value::new(value)
    }

    pub async fn get_proposal(
        &self,
        height: Height,
        round: Round,
        _valid_round: Round,
        _proposer: Address,
        value_id: ValueId,
    ) -> Option<LocallyProposedValue<TestContext>> {
        Some(LocallyProposedValue::new(
            height,
            round,
            Value::new(value_id.as_u64()),
        ))
    }

    /// Creates a new proposal value for the given height
    pub async fn propose_value(
        &mut self,
        height: Height,
        round: Round,
    ) -> eyre::Result<LocallyProposedValue<TestContext>> {
        assert_eq!(height, self.current_height);
        assert_eq!(round, self.current_round);

        let proposal = self.create_proposal(height, round).await?;

        Ok(LocallyProposedValue::new(
            proposal.height,
            proposal.round,
            proposal.value,
        ))
    }

    fn stream_id(&self) -> StreamId {
        let mut bytes = Vec::with_capacity(size_of::<u64>() + size_of::<u32>());
        bytes.extend_from_slice(&self.current_height.as_u64().to_be_bytes());
        bytes.extend_from_slice(&self.current_round.as_u32().unwrap().to_be_bytes());
        StreamId::new(bytes.into())
    }

    /// Creates a stream message containing a proposal part.
    /// Updates internal sequence number and current proposal.
    pub fn stream_proposal(
        &mut self,
        value: LocallyProposedValue<TestContext>,
        pol_round: Round,
    ) -> impl Iterator<Item = StreamMessage<ProposalPart>> {
        let parts = self.value_to_parts(value, pol_round);
        let stream_id = self.stream_id();

        let mut msgs = Vec::with_capacity(parts.len() + 1);
        let mut sequence = 0;

        for part in parts {
            let msg = StreamMessage::new(stream_id.clone(), sequence, StreamContent::Data(part));
            sequence += 1;
            msgs.push(msg);
        }

        msgs.push(StreamMessage::new(
            stream_id.clone(),
            sequence,
            StreamContent::Fin,
        ));

        msgs.into_iter()
    }

    fn value_to_parts(
        &self,
        value: LocallyProposedValue<TestContext>,
        pol_round: Round,
    ) -> Vec<ProposalPart> {
        let mut hasher = sha3::Keccak256::new();
        let mut parts = Vec::new();

        // Init
        // Include metadata about the proposal
        {
            parts.push(ProposalPart::Init(ProposalInit::new(
                value.height,
                value.round,
                pol_round,
                self.address,
            )));

            hasher.update(value.height.as_u64().to_be_bytes().as_slice());
            hasher.update(value.round.as_i64().to_be_bytes().as_slice());
        }

        // Data
        // Include each prime factor of the value as a separate proposal part
        {
            for factor in factor_value(value.value) {
                parts.push(ProposalPart::Data(ProposalData::new(factor)));

                hasher.update(factor.to_be_bytes().as_slice());
            }
        }

        // Fin
        // Sign the hash of the proposal parts
        {
            let hash = hasher.finalize().to_vec();
            let signature = self.signing_provider.sign(&hash);
            parts.push(ProposalPart::Fin(ProposalFin::new(signature)));
        }

        parts
    }

    /// Verifies the signature of the proposal.
    /// Returns `Ok(())` if the signature is valid, or an appropriate `SignatureVerificationError`.
    fn verify_proposal_signature(
        &self,
        parts: &ProposalParts,
    ) -> Result<(), SignatureVerificationError> {
        let mut hasher = sha3::Keccak256::new();

        let init = parts
            .init()
            .ok_or(SignatureVerificationError::MissingInitPart)?;

        let fin = parts
            .fin()
            .ok_or(SignatureVerificationError::MissingFinPart)?;

        let hash = {
            hasher.update(init.height.as_u64().to_be_bytes());
            hasher.update(init.round.as_i64().to_be_bytes());

            // The correctness of the hash computation relies on the parts being ordered by sequence
            // number, which is guaranteed by the `PartStreamsMap`.
            for part in parts.parts.iter().filter_map(|part| part.as_data()) {
                hasher.update(part.factor.to_be_bytes());
            }

            hasher.finalize()
        };

        // Retrieve the the proposer
        let proposer = self
            .get_validator_set()
            .get_by_address(&parts.proposer)
            .ok_or(SignatureVerificationError::ProposerNotFound)?;

        // Verify the signature
        if !self
            .signing_provider
            .verify(&hash, &fin.signature, &proposer.public_key)
        {
            return Err(SignatureVerificationError::InvalidSignature);
        }

        Ok(())
    }
}

/// Re-assemble a [`ProposedValue`] from its [`ProposalParts`].
///
/// This is done by multiplying all the factors in the parts.
fn assemble_value_from_parts(parts: ProposalParts) -> eyre::Result<ProposedValue<TestContext>> {
    let init = parts.init().ok_or_else(|| eyre!("Missing Init part"))?;

    let value = parts
        .parts
        .iter()
        .filter_map(|part| part.as_data())
        .fold(1, |acc, data| acc * data.factor);

    Ok(ProposedValue {
        height: parts.height,
        round: parts.round,
        valid_round: init.pol_round,
        proposer: parts.proposer,
        value: Value::new(value),
        validity: Validity::Valid, // TODO: Check signature in Fin part
    })
}

/// Decodes a Value from its byte representation using ProtobufCodec
pub fn decode_value(bytes: Bytes) -> Value {
    ProtobufCodec.decode(bytes).unwrap()
}

/// Returns the list of prime factors of the given value
///
/// In a real application, this would typically split transactions
/// into chunks ino order to reduce bandwidth requirements due
/// to duplication of gossip messages.
fn factor_value(value: Value) -> Vec<u64> {
    let mut factors = Vec::new();
    let mut n = value.value;

    let mut i = 2;
    while i * i <= n {
        if n % i == 0 {
            factors.push(i);
            n /= i;
        } else {
            i += 1;
        }
    }

    if n > 1 {
        factors.push(n);
    }

    factors
}

/// Represents errors that can occur during the verification of a proposal's signature.
#[derive(Debug)]
enum SignatureVerificationError {
    /// Indicates that the `Init` part of the proposal is unexpectedly missing.
    MissingInitPart,

    /// Indicates that the `Fin` part of the proposal is unexpectedly missing.
    MissingFinPart,

    /// Indicates that the proposer was not found in the validator set.
    ProposerNotFound,

    /// Indicates that the signature in the `Fin` part is invalid.
    InvalidSignature,
}

```
---
### `test/app/src/store/keys.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use core::mem::size_of;

use malachitebft_app_channel::app::types::core::Round;
use malachitebft_test::{Height, ValueId};

pub type UndecidedValueKey = (HeightKey, RoundKey, ValueIdKey);

#[derive(Copy, Clone, Debug)]
pub struct HeightKey;

impl redb::Value for HeightKey {
    type SelfType<'a> = Height;
    type AsBytes<'a> = [u8; size_of::<u64>()];

    fn fixed_width() -> Option<usize> {
        Some(size_of::<u64>())
    }

    fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
    where
        Self: 'a,
    {
        let height = <u64 as redb::Value>::from_bytes(data);

        Height::new(height)
    }

    fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
    where
        Self: 'a,
        Self: 'b,
    {
        <u64 as redb::Value>::as_bytes(&value.as_u64())
    }

    fn type_name() -> redb::TypeName {
        redb::TypeName::new("Height")
    }
}

impl redb::Key for HeightKey {
    fn compare(data1: &[u8], data2: &[u8]) -> std::cmp::Ordering {
        <u64 as redb::Key>::compare(data1, data2)
    }
}

#[derive(Copy, Clone, Debug)]
pub struct RoundKey;

impl redb::Value for RoundKey {
    type SelfType<'a> = Round;
    type AsBytes<'a> = [u8; size_of::<i64>()];

    fn fixed_width() -> Option<usize> {
        Some(size_of::<i64>())
    }

    fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
    where
        Self: 'a,
    {
        let round = <i64 as redb::Value>::from_bytes(data);
        Round::from(round)
    }

    fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
    where
        Self: 'a,
        Self: 'b,
    {
        <i64 as redb::Value>::as_bytes(&value.as_i64())
    }

    fn type_name() -> redb::TypeName {
        redb::TypeName::new("Round")
    }
}

impl redb::Key for RoundKey {
    fn compare(data1: &[u8], data2: &[u8]) -> std::cmp::Ordering {
        <i64 as redb::Key>::compare(data1, data2)
    }
}

#[derive(Copy, Clone, Debug)]
pub struct ValueIdKey;

impl redb::Value for ValueIdKey {
    type SelfType<'a> = ValueId;
    type AsBytes<'a> = [u8; size_of::<u64>()];

    fn fixed_width() -> Option<usize> {
        Some(size_of::<u64>())
    }

    fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
    where
        Self: 'a,
    {
        let id = <u64 as redb::Value>::from_bytes(data);
        ValueId::new(id)
    }

    fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
    where
        Self: 'a,
        Self: 'b,
    {
        <u64 as redb::Value>::as_bytes(&value.as_u64())
    }

    fn type_name() -> redb::TypeName {
        redb::TypeName::new("ValueId")
    }
}

impl redb::Key for ValueIdKey {
    fn compare(data1: &[u8], data2: &[u8]) -> std::cmp::Ordering {
        <u64 as redb::Key>::compare(data1, data2)
    }
}

```
---
### `test/app/src/store.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
use std::path::Path;
use std::sync::Arc;

use bytes::Bytes;
use prost::Message;
use redb::ReadableTable;
use thiserror::Error;
use tracing::error;

use malachitebft_app_channel::app::types::codec::Codec;
use malachitebft_app_channel::app::types::core::{CommitCertificate, Round};
use malachitebft_app_channel::app::types::ProposedValue;
use malachitebft_proto::{Error as ProtoError, Protobuf};
use malachitebft_test::codec::proto as codec;
use malachitebft_test::codec::proto::ProtobufCodec;
use malachitebft_test::proto;
use malachitebft_test::{Height, TestContext, Value, ValueId};

mod keys;
use keys::{HeightKey, UndecidedValueKey};

#[derive(Clone, Debug)]
pub struct DecidedValue {
    pub value: Value,
    pub certificate: CommitCertificate<TestContext>,
}

fn decode_certificate(bytes: &[u8]) -> Result<CommitCertificate<TestContext>, ProtoError> {
    let proto = proto::CommitCertificate::decode(bytes)?;
    codec::decode_commit_certificate(proto)
}

fn encode_certificate(certificate: &CommitCertificate<TestContext>) -> Result<Vec<u8>, ProtoError> {
    let proto = codec::encode_commit_certificate(certificate)?;
    Ok(proto.encode_to_vec())
}

#[derive(Debug, Error)]
pub enum StoreError {
    #[error("Database error: {0}")]
    Database(#[from] redb::DatabaseError),

    #[error("Storage error: {0}")]
    Storage(#[from] redb::StorageError),

    #[error("Table error: {0}")]
    Table(#[from] redb::TableError),

    #[error("Commit error: {0}")]
    Commit(#[from] redb::CommitError),

    #[error("Transaction error: {0}")]
    Transaction(#[from] redb::TransactionError),

    #[error("Failed to encode/decode Protobuf: {0}")]
    Protobuf(#[from] ProtoError),

    #[error("Failed to join on task: {0}")]
    TaskJoin(#[from] tokio::task::JoinError),
}

const CERTIFICATES_TABLE: redb::TableDefinition<HeightKey, Vec<u8>> =
    redb::TableDefinition::new("certificates");

const DECIDED_VALUES_TABLE: redb::TableDefinition<HeightKey, Vec<u8>> =
    redb::TableDefinition::new("decided_values");

const UNDECIDED_PROPOSALS_TABLE: redb::TableDefinition<UndecidedValueKey, Vec<u8>> =
    redb::TableDefinition::new("undecided_values");

struct Db {
    db: redb::Database,
}

impl Db {
    fn new(path: impl AsRef<Path>) -> Result<Self, StoreError> {
        Ok(Self {
            db: redb::Database::create(path).map_err(StoreError::Database)?,
        })
    }

    fn get_decided_value(&self, height: Height) -> Result<Option<DecidedValue>, StoreError> {
        let tx = self.db.begin_read()?;
        let value = {
            let table = tx.open_table(DECIDED_VALUES_TABLE)?;
            let value = table.get(&height)?;
            value.and_then(|value| Value::from_bytes(&value.value()).ok())
        };
        let certificate = {
            let table = tx.open_table(CERTIFICATES_TABLE)?;
            let value = table.get(&height)?;
            value.and_then(|value| decode_certificate(&value.value()).ok())
        };

        let decided_value = value
            .zip(certificate)
            .map(|(value, certificate)| DecidedValue { value, certificate });

        Ok(decided_value)
    }

    fn insert_decided_value(&self, decided_value: DecidedValue) -> Result<(), StoreError> {
        let height = decided_value.certificate.height;

        let tx = self.db.begin_write()?;
        {
            let mut values = tx.open_table(DECIDED_VALUES_TABLE)?;
            values.insert(height, decided_value.value.to_bytes()?.to_vec())?;
        }
        {
            let mut certificates = tx.open_table(CERTIFICATES_TABLE)?;
            certificates.insert(height, encode_certificate(&decided_value.certificate)?)?;
        }
        tx.commit()?;

        Ok(())
    }

    pub fn get_undecided_proposal(
        &self,
        height: Height,
        round: Round,
        value_id: ValueId,
    ) -> Result<Option<ProposedValue<TestContext>>, StoreError> {
        let tx = self.db.begin_read()?;
        let table = tx.open_table(UNDECIDED_PROPOSALS_TABLE)?;

        let value = if let Ok(Some(value)) = table.get(&(height, round, value_id)) {
            Some(
                ProtobufCodec
                    .decode(Bytes::from(value.value()))
                    .map_err(StoreError::Protobuf)?,
            )
        } else {
            None
        };

        Ok(value)
    }

    fn get_undecided_proposals(
        &self,
        height: Height,
        round: Round,
    ) -> Result<Vec<ProposedValue<TestContext>>, StoreError> {
        let tx = self.db.begin_read()?;
        let table = tx.open_table(UNDECIDED_PROPOSALS_TABLE)?;

        let mut proposals = Vec::new();
        for result in table.iter()? {
            let (key, value) = result?;
            let (h, r, _) = key.value();

            if h == height && r == round {
                let bytes = value.value();

                let proposal = ProtobufCodec
                    .decode(Bytes::from(bytes))
                    .map_err(StoreError::Protobuf)?;

                proposals.push(proposal);
            }
        }

        Ok(proposals)
    }

    fn insert_undecided_proposal(
        &self,
        proposal: ProposedValue<TestContext>,
    ) -> Result<(), StoreError> {
        let key = (proposal.height, proposal.round, proposal.value.id());
        let value = ProtobufCodec.encode(&proposal)?;
        let tx = self.db.begin_write()?;
        {
            let mut table = tx.open_table(UNDECIDED_PROPOSALS_TABLE)?;
            table.insert(key, value.to_vec())?;
        }
        tx.commit()?;
        Ok(())
    }

    fn prune(&self, current_height: Height, retain_height: Height) -> Result<(), StoreError> {
        let tx = self.db.begin_write().unwrap();
        {
            // Remove all undecided proposals with height <= current_height
            let mut undecided = tx.open_table(UNDECIDED_PROPOSALS_TABLE)?;
            undecided.retain(|(height, _, _), _| height > current_height)?;

            // Prune decided values and certificates up to the retain height
            let mut decided = tx.open_table(DECIDED_VALUES_TABLE)?;
            let mut certificates = tx.open_table(CERTIFICATES_TABLE)?;

            // Keep only decided values with height >= retain_height
            decided.retain(|k, _| k >= retain_height)?;
            // Keep only certificates with height >= retain_height
            certificates.retain(|k, _| k >= retain_height)?;
        }
        tx.commit()?;

        Ok(())
    }

    fn min_decided_value_height(&self) -> Option<Height> {
        let tx = self.db.begin_read().unwrap();
        let table = tx.open_table(DECIDED_VALUES_TABLE).unwrap();
        let (key, _) = table.first().ok()??;
        Some(key.value())
    }

    fn max_decided_value_height(&self) -> Option<Height> {
        let tx = self.db.begin_read().unwrap();
        let table = tx.open_table(DECIDED_VALUES_TABLE).unwrap();
        let (key, _) = table.last().ok()??;
        Some(key.value())
    }

    fn create_tables(&self) -> Result<(), StoreError> {
        let tx = self.db.begin_write()?;
        // Implicitly creates the tables if they do not exist yet
        let _ = tx.open_table(DECIDED_VALUES_TABLE)?;
        let _ = tx.open_table(CERTIFICATES_TABLE)?;
        let _ = tx.open_table(UNDECIDED_PROPOSALS_TABLE)?;
        tx.commit()?;
        Ok(())
    }

    fn get_undecided_proposal_by_value_id(
        &self,
        value_id: ValueId,
    ) -> Result<Option<ProposedValue<TestContext>>, StoreError> {
        let tx = self.db.begin_read()?;
        let table = tx.open_table(UNDECIDED_PROPOSALS_TABLE)?;

        for result in table.iter()? {
            let (_, value) = result?;
            let proposal: ProposedValue<TestContext> = ProtobufCodec
                .decode(Bytes::from(value.value()))
                .map_err(StoreError::Protobuf)?;

            if proposal.value.id() == value_id {
                return Ok(Some(proposal));
            }
        }

        Ok(None)
    }
}

#[derive(Clone)]
pub struct Store {
    db: Arc<Db>,
}

impl Store {
    pub async fn open(path: impl AsRef<Path>) -> Result<Self, StoreError> {
        let path = path.as_ref().to_owned();
        tokio::task::spawn_blocking(move || {
            let db = Db::new(path)?;
            db.create_tables()?;
            Ok(Self { db: Arc::new(db) })
        })
        .await?
    }

    pub async fn min_decided_value_height(&self) -> Option<Height> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.min_decided_value_height())
            .await
            .ok()
            .flatten()
    }

    pub async fn max_decided_value_height(&self) -> Option<Height> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.max_decided_value_height())
            .await
            .ok()
            .flatten()
    }

    pub async fn get_decided_value(
        &self,
        height: Height,
    ) -> Result<Option<DecidedValue>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.get_decided_value(height)).await?
    }

    pub async fn store_decided_value(
        &self,
        certificate: &CommitCertificate<TestContext>,
        value: Value,
    ) -> Result<(), StoreError> {
        let decided_value = DecidedValue {
            value,
            certificate: certificate.clone(),
        };

        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.insert_decided_value(decided_value)).await?
    }

    pub async fn store_undecided_proposal(
        &self,
        value: ProposedValue<TestContext>,
    ) -> Result<(), StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.insert_undecided_proposal(value)).await?
    }

    pub async fn get_undecided_proposal(
        &self,
        height: Height,
        round: Round,
        value_id: ValueId,
    ) -> Result<Option<ProposedValue<TestContext>>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.get_undecided_proposal(height, round, value_id))
            .await?
    }

    pub async fn get_undecided_proposals(
        &self,
        height: Height,
        round: Round,
    ) -> Result<Vec<ProposedValue<TestContext>>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.get_undecided_proposals(height, round)).await?
    }

    pub async fn prune(
        &self,
        current_height: Height,
        retain_height: Height,
    ) -> Result<(), StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.prune(current_height, retain_height)).await?
    }

    pub async fn get_undecided_proposal_by_value_id(
        &self,
        value_id: ValueId,
    ) -> Result<Option<ProposedValue<TestContext>>, StoreError> {
        let db = Arc::clone(&self.db);
        tokio::task::spawn_blocking(move || db.get_undecided_proposal_by_value_id(value_id)).await?
    }
}

```
---
### `test/app/src/streaming.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::cmp::Ordering;
use std::collections::{BTreeMap, BinaryHeap, HashSet};

use malachitebft_app_channel::app::consensus::PeerId;
use malachitebft_app_channel::app::streaming::{Sequence, StreamId, StreamMessage};
use malachitebft_app_channel::app::types::core::Round;
use malachitebft_test::{Address, Height, ProposalFin, ProposalInit, ProposalPart};

struct MinSeq<T>(StreamMessage<T>);

impl<T> PartialEq for MinSeq<T> {
    fn eq(&self, other: &Self) -> bool {
        self.0.sequence == other.0.sequence
    }
}

impl<T> Eq for MinSeq<T> {}

impl<T> Ord for MinSeq<T> {
    fn cmp(&self, other: &Self) -> Ordering {
        other.0.sequence.cmp(&self.0.sequence)
    }
}

impl<T> PartialOrd for MinSeq<T> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

struct MinHeap<T>(BinaryHeap<MinSeq<T>>);

impl<T> Default for MinHeap<T> {
    fn default() -> Self {
        Self(BinaryHeap::new())
    }
}

impl<T> MinHeap<T> {
    fn push(&mut self, msg: StreamMessage<T>) {
        self.0.push(MinSeq(msg));
    }

    fn len(&self) -> usize {
        self.0.len()
    }

    fn drain(&mut self) -> Vec<T> {
        let mut vec = Vec::with_capacity(self.0.len());
        while let Some(MinSeq(msg)) = self.0.pop() {
            if let Some(data) = msg.content.into_data() {
                vec.push(data);
            }
        }
        vec
    }
}

#[derive(Default)]
struct StreamState {
    buffer: MinHeap<ProposalPart>,
    init_info: Option<ProposalInit>,
    seen_sequences: HashSet<Sequence>,
    total_messages: usize,
    fin_received: bool,
}

impl StreamState {
    fn is_done(&self) -> bool {
        self.init_info.is_some() && self.fin_received && self.buffer.len() == self.total_messages
    }

    fn insert(&mut self, msg: StreamMessage<ProposalPart>) -> Option<ProposalParts> {
        if msg.is_first() {
            self.init_info = msg.content.as_data().and_then(|p| p.as_init()).cloned();
        }

        if msg.is_fin() {
            self.fin_received = true;
            self.total_messages = msg.sequence as usize + 1;
        }

        self.buffer.push(msg);

        if self.is_done() {
            let init_info = self.init_info.take()?;

            Some(ProposalParts {
                height: init_info.height,
                round: init_info.round,
                proposer: init_info.proposer,
                parts: self.buffer.drain(),
            })
        } else {
            None
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ProposalParts {
    pub height: Height,
    pub round: Round,
    pub proposer: Address,
    pub parts: Vec<ProposalPart>,
}

impl ProposalParts {
    pub fn init(&self) -> Option<&ProposalInit> {
        self.parts.iter().find_map(|p| p.as_init())
    }

    pub fn fin(&self) -> Option<&ProposalFin> {
        self.parts.iter().find_map(|p| p.as_fin())
    }
}

#[derive(Default)]
pub struct PartStreamsMap {
    streams: BTreeMap<(PeerId, StreamId), StreamState>,
}

impl PartStreamsMap {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn insert(
        &mut self,
        peer_id: PeerId,
        msg: StreamMessage<ProposalPart>,
    ) -> Option<ProposalParts> {
        let stream_id = msg.stream_id.clone();

        let state = self
            .streams
            .entry((peer_id, stream_id.clone()))
            .or_default();

        if !state.seen_sequences.insert(msg.sequence) {
            // We have already seen a message with this sequence number.
            return None;
        }

        let result = state.insert(msg);

        if state.is_done() {
            self.streams.remove(&(peer_id, stream_id));
        }

        result
    }
}

```
---
### `test/build.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let protos = &[
        "proto/consensus.proto",
        "proto/sync.proto",
        "proto/liveness.proto",
    ];

    for proto in protos {
        println!("cargo:rerun-if-changed={proto}");
    }

    let fds = protox::compile(protos, ["proto"])?;

    let mut config = prost_build::Config::new();
    config.enable_type_names();
    config.bytes(["."]);

    config.compile_fds(fds)?;

    Ok(())
}

```
---
### `test/cli/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-test-cli"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish = false

[lints]
workspace = true

[dependencies]
malachitebft-core-types.workspace = true
malachitebft-metrics.workspace = true
malachitebft-config.workspace = true
malachitebft-app.workspace = true

axum = { workspace = true }
bytesize = { workspace = true }
clap = { workspace = true, features = ["derive", "env"] }
color-eyre = { workspace = true }
directories = { workspace = true }
itertools = { workspace = true }
tokio = { workspace = true, features = ["full"] }
thiserror = { workspace = true }
tracing = { workspace = true }
tracing-appender = { workspace = true }
tracing-subscriber = { workspace = true, features = ["env-filter", "fmt", "json"] }
serde = { workspace = true }
serde_json = { workspace = true }
rand = { workspace = true }
toml = { workspace = true }

```
---
### `test/cli/src/args.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
//! Command-line interface arguments for a basic implementation.
//!
//! Read configuration from the configuration files found in the directory
//! provided with the `--home` global parameter.
//!
//! The command-line parameters are stored in the `Args` structure.
//! `clap` parses the command-line parameters into this structure.

use std::path::PathBuf;

use clap::{Parser, Subcommand};
use directories::BaseDirs;

use crate::cmd::distributed_testnet::DistributedTestnetCmd;
use crate::cmd::dump_wal::DumpWalCmd;
use crate::cmd::init::InitCmd;
use crate::cmd::start::StartCmd;
use crate::cmd::testnet::TestnetCmd;
use crate::error::Error;

const APP_FOLDER: &str = ".malachite";
const CONFIG_FILE: &str = "config.toml";
const GENESIS_FILE: &str = "genesis.json";
const PRIV_VALIDATOR_KEY_FILE: &str = "priv_validator_key.json";

#[derive(Parser, Clone, Debug, Default)]
#[command(version, about, long_about = None)]
pub struct Args {
    /// Home directory for Malachite (default: `~/.malachite`)
    #[arg(long, global = true, value_name = "HOME_DIR")]
    pub home: Option<PathBuf>,

    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand, Clone, Debug)]
pub enum Commands {
    /// Start node
    Start(StartCmd),

    /// Initialize configuration
    Init(InitCmd),

    /// Generate testnet configuration
    Testnet(TestnetCmd),

    /// Generate distributed testnet configuration
    DistributedTestnet(DistributedTestnetCmd),

    /// Dump WAL entries
    DumpWal(DumpWalCmd),
}

impl Default for Commands {
    fn default() -> Self {
        Commands::Start(StartCmd::default())
    }
}

impl Args {
    /// new returns a new instance of the arguments.
    pub fn new() -> Args {
        Args::parse()
    }

    /// get_home_dir returns the application home folder.
    /// Typically, `$HOME/.malachite`, dependent on the operating system.
    pub fn get_home_dir(&self) -> Result<PathBuf, Error> {
        match self.home {
            Some(ref path) => Ok(path.clone()),
            None => Ok(BaseDirs::new()
                .ok_or(Error::DirPath)?
                .home_dir()
                .join(APP_FOLDER)),
        }
    }

    /// get_config_dir returns the configuration folder based on the home folder.
    pub fn get_config_dir(&self) -> Result<PathBuf, Error> {
        Ok(self.get_home_dir()?.join("config"))
    }

    /// get_config_file_path returns the configuration file path based on the command-line arguments
    /// and the configuration folder.
    pub fn get_config_file_path(&self) -> Result<PathBuf, Error> {
        Ok(self.get_config_dir()?.join(CONFIG_FILE))
    }

    /// get_genesis_file_path returns the genesis file path based on the command-line arguments and
    /// the configuration folder.
    pub fn get_genesis_file_path(&self) -> Result<PathBuf, Error> {
        Ok(self.get_config_dir()?.join(GENESIS_FILE))
    }

    /// get_priv_validator_key_file_path returns the private validator key file path based on the
    /// configuration folder.
    pub fn get_priv_validator_key_file_path(&self) -> Result<PathBuf, Error> {
        Ok(self.get_config_dir()?.join(PRIV_VALIDATOR_KEY_FILE))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_args() {
        let args = Args::parse_from(["test", "init"]);
        assert!(matches!(args.command, Commands::Init(_)));

        let args = Args::parse_from(["test", "start"]);
        assert!(matches!(args.command, Commands::Start(_)));
    }

    #[test]
    fn parse_home_path() {
        let args = Args::parse_from(["test", "start", "--home", "/tmp"]);
        assert_eq!(
            args.get_config_file_path().unwrap(),
            PathBuf::from("/tmp/config/config.toml")
        );
        assert_eq!(
            args.get_genesis_file_path().unwrap(),
            PathBuf::from("/tmp/config/genesis.json")
        );
    }
}

```
---
### `test/cli/src/cmd/distributed_testnet.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
//! Distributed testnet command

use std::path::Path;
use std::time::Duration;

use clap::Parser;
use color_eyre::eyre::{eyre, Result};
use tracing::info;

use malachitebft_app::node::{
    CanGeneratePrivateKey, CanMakeDistributedConfig, CanMakeGenesis, CanMakePrivateKeyFile,
    MakeConfigSettings, Node,
};
use malachitebft_config::*;

use crate::args::Args;
use crate::cmd::testnet::RuntimeFlavour;
use crate::file::{save_config, save_genesis, save_priv_validator_key};

#[derive(Parser, Debug, Clone, PartialEq)]
pub struct DistributedTestnetCmd {
    /// Number of validator nodes in the testnet
    #[clap(short, long)]
    pub nodes: usize,

    /// Generate deterministic private keys for reproducibility
    #[clap(short, long)]
    pub deterministic: bool,

    /// The flavor of Tokio runtime to use.
    /// Possible values:
    /// - "single-threaded": A single threaded runtime (default)
    /// - "multi-threaded:N":  A multi-threaded runtime with as N worker threads
    ///   Use a value of 0 for N to use the number of cores available on the system.
    #[clap(short, long, default_value = "single-threaded", verbatim_doc_comment)]
    pub runtime: RuntimeFlavour,

    /// The IPs of the available machines in the network (comma separated) on which to run the nodes
    #[clap(long, value_delimiter = ',', verbatim_doc_comment)]
    pub machines: Vec<String>,

    /// Enable peer discovery.
    /// If enabled, the node will attempt to discover other nodes in the network
    #[clap(long, default_value = "false")]
    pub enable_discovery: bool,

    /// Bootstrap protocol
    /// The protocol used to bootstrap the discovery mechanism
    /// Possible values:
    /// - "kademlia": Kademlia
    /// - "full": Full mesh (default)
    #[clap(long, default_value = "full", verbatim_doc_comment)]
    pub bootstrap_protocol: BootstrapProtocol,

    /// Selector
    /// The selection strategy used to select persistent peers
    /// Possible values:
    /// - "kademlia": Kademlia-based selection, only available with the Kademlia bootstrap protocol
    /// - "random": Random selection (default)
    #[clap(long, default_value = "random", verbatim_doc_comment)]
    pub selector: Selector,

    /// Number of outbound peers
    #[clap(long, default_value = "20", verbatim_doc_comment)]
    pub num_outbound_peers: usize,

    /// Number of inbound peers
    /// Must be greater than or equal to the number of outbound peers
    #[clap(long, default_value = "20", verbatim_doc_comment)]
    pub num_inbound_peers: usize,

    /// Ephemeral connection timeout
    /// The duration in milliseconds an ephemeral connection is kept alive
    #[clap(long, default_value = "5000", verbatim_doc_comment)]
    pub ephemeral_connection_timeout_ms: u64,

    /// The size of the bootstrap set.
    #[clap(long, default_value = "1", verbatim_doc_comment)]
    pub bootstrap_set_size: usize,

    /// The transport protocol to use for P2P communication
    /// Possible values:
    /// - "quic": QUIC (default)
    /// - "tcp": TCP + Noise
    #[clap(short, long, default_value = "quic", verbatim_doc_comment)]
    pub transport: TransportProtocol,
}

impl DistributedTestnetCmd {
    /// Execute the testnet command
    pub fn run<N>(&self, node: &N, home_dir: &Path) -> Result<()>
    where
        N: Node
            + CanGeneratePrivateKey
            + CanMakeDistributedConfig
            + CanMakeGenesis
            + CanMakePrivateKeyFile,
    {
        let runtime = match self.runtime {
            RuntimeFlavour::SingleThreaded => RuntimeConfig::SingleThreaded,
            RuntimeFlavour::MultiThreaded(n) => RuntimeConfig::MultiThreaded { worker_threads: n },
        };

        let settings = MakeConfigSettings {
            runtime,
            transport: self.transport,
            discovery: DiscoveryConfig {
                enabled: self.enable_discovery,
                bootstrap_protocol: self.bootstrap_protocol,
                selector: self.selector,
                num_outbound_peers: self.num_outbound_peers,
                num_inbound_peers: self.num_inbound_peers,
                ephemeral_connection_timeout: Duration::from_millis(
                    self.ephemeral_connection_timeout_ms,
                ),
            },
        };

        distributed_testnet(
            node,
            self.nodes,
            home_dir,
            self.machines.clone(),
            self.bootstrap_set_size,
            self.deterministic,
            settings,
        )
        .map_err(|e| {
            eyre!(
                "Failed to generate distributed testnet configuration: {:?}",
                e
            )
        })
    }
}

fn distributed_testnet<N>(
    node: &N,
    nodes: usize,
    home_dir: &Path,
    machines: Vec<String>,
    bootstrap_set_size: usize,
    deterministic: bool,
    settings: MakeConfigSettings,
) -> Result<()>
where
    N: Node
        + CanGeneratePrivateKey
        + CanMakeDistributedConfig
        + CanMakeGenesis
        + CanMakePrivateKeyFile,
{
    let private_keys = crate::new::generate_private_keys(node, nodes, deterministic);
    let public_keys = private_keys
        .iter()
        .map(|pk| node.get_public_key(pk))
        .collect();
    let genesis = crate::new::generate_genesis(node, public_keys, deterministic);

    for (i, private_key) in private_keys.iter().enumerate().take(nodes) {
        let node_home_dir = home_dir
            .join((i % machines.len()).to_string())
            .join(i.to_string());

        info!(
            id = %i,
            home = %node_home_dir.display(),
            "Generating configuration for node..."
        );

        let args = Args {
            home: Some(node_home_dir),
            ..Args::default()
        };

        save_config::<N>(
            &args.get_config_file_path()?,
            &N::make_distributed_config(i, nodes, machines.clone(), bootstrap_set_size, settings),
        )?;

        let priv_validator_key = node.make_private_key_file((*private_key).clone());
        save_priv_validator_key(
            node,
            &args.get_priv_validator_key_file_path()?,
            &priv_validator_key,
        )?;

        save_genesis(node, &args.get_genesis_file_path()?, &genesis)?;
    }

    Ok(())
}

```
---
### `test/cli/src/cmd/dump_wal.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::path::PathBuf;

use clap::Parser;
use color_eyre::eyre;
use malachitebft_core_types::Context;
use tracing::{error, info};

use malachitebft_app::engine::wal::{log_entries, WalCodec};
use malachitebft_app::wal::Log;

#[derive(Parser, Debug, Clone, Default, PartialEq)]
pub struct DumpWalCmd {
    pub wal_file: PathBuf,
}

impl DumpWalCmd {
    pub fn run<Ctx, Codec>(&self, codec: Codec) -> eyre::Result<()>
    where
        Ctx: Context,
        Codec: WalCodec<Ctx>,
    {
        let mut log = Log::open(&self.wal_file)?;

        let len = log.len();
        let mut count = 0;

        info!("WAL Dump");
        info!("- Entries: {len}");
        info!("- Size:    {} bytes", log.size_bytes().unwrap_or(0));
        info!("Entries:");

        for (idx, entry) in log_entries(&mut log, &codec)?.enumerate() {
            count += 1;

            match entry {
                Ok(entry) => {
                    info!("- #{idx}: {entry:?}");
                }
                Err(e) => {
                    error!("- #{idx}: Error decoding WAL entry: {e}");
                }
            }
        }

        if count != len {
            error!("Expected {len} entries, but found {count} entries");
        }

        Ok(())
    }
}

```
---
### `test/cli/src/cmd/init.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
//! Init command

use std::path::Path;
use std::time::Duration;

use clap::Parser;
use tracing::{info, warn};

use malachitebft_app::node::{
    CanGeneratePrivateKey, CanMakeConfig, CanMakeGenesis, CanMakePrivateKeyFile,
    MakeConfigSettings, Node,
};
use malachitebft_config::{
    BootstrapProtocol, DiscoveryConfig, RuntimeConfig, Selector, TransportProtocol,
};

use crate::error::Error;
use crate::file::{save_config, save_genesis, save_priv_validator_key};
use crate::new::{generate_genesis, generate_private_keys};

#[derive(Parser, Debug, Clone, Default, PartialEq)]
pub struct InitCmd {
    /// Overwrite existing configuration files
    #[clap(long)]
    pub overwrite: bool,

    /// Enable peer discovery.
    /// If enabled, the node will attempt to discover other nodes in the network
    #[clap(long, default_value = "true")]
    pub enable_discovery: bool,

    /// Bootstrap protocol
    /// The protocol used to bootstrap the discovery mechanism
    /// Possible values:
    /// - "kademlia": Kademlia
    /// - "full": Full mesh (default)
    #[clap(long, default_value = "full", verbatim_doc_comment)]
    pub bootstrap_protocol: BootstrapProtocol,

    /// Selector
    /// The selection strategy used to select persistent peers
    /// Possible values:
    /// - "kademlia": Kademlia-based selection, only available with the Kademlia bootstrap protocol
    /// - "random": Random selection (default)
    #[clap(long, default_value = "random", verbatim_doc_comment)]
    pub selector: Selector,

    /// Number of outbound peers
    #[clap(long, default_value = "20", verbatim_doc_comment)]
    pub num_outbound_peers: usize,

    /// Number of inbound peers
    /// Must be greater than or equal to the number of outbound peers
    #[clap(long, default_value = "20", verbatim_doc_comment)]
    pub num_inbound_peers: usize,

    /// Ephemeral connection timeout
    /// The duration in milliseconds an ephemeral connection is kept alive
    #[clap(long, default_value = "5000", verbatim_doc_comment)]
    pub ephemeral_connection_timeout_ms: u64,
}

impl InitCmd {
    /// Execute the init command
    pub fn run<N>(
        &self,
        node: &N,
        config_file: &Path,
        genesis_file: &Path,
        priv_validator_key_file: &Path,
    ) -> Result<(), Error>
    where
        N: Node + CanMakeConfig + CanMakePrivateKeyFile + CanGeneratePrivateKey + CanMakeGenesis,
    {
        let settings = MakeConfigSettings {
            runtime: RuntimeConfig::SingleThreaded,
            transport: TransportProtocol::Tcp,
            discovery: DiscoveryConfig {
                enabled: self.enable_discovery,
                bootstrap_protocol: self.bootstrap_protocol,
                selector: self.selector,
                num_outbound_peers: self.num_outbound_peers,
                num_inbound_peers: self.num_inbound_peers,
                ephemeral_connection_timeout: Duration::from_millis(
                    self.ephemeral_connection_timeout_ms,
                ),
            },
        };

        let config = N::make_config(0, 1, settings);

        init(
            node,
            &config,
            config_file,
            genesis_file,
            priv_validator_key_file,
            self.overwrite,
        )?;

        Ok(())
    }
}

/// init command to generate defaults.
pub fn init<N>(
    node: &N,
    config: &N::Config,
    config_file: &Path,
    genesis_file: &Path,
    priv_validator_key_file: &Path,
    overwrite: bool,
) -> Result<(), Error>
where
    N: Node + CanMakePrivateKeyFile + CanGeneratePrivateKey + CanMakeGenesis,
{
    // Save configuration
    if config_file.exists() && !overwrite {
        warn!(file = ?config_file.display(), "Configuration file already exists, skipping")
    } else {
        info!(file = ?config_file, "Saving configuration");
        save_config::<N>(config_file, config)?;
    }

    // Save default priv_validator_key
    if priv_validator_key_file.exists() && !overwrite {
        warn!(
            file = ?priv_validator_key_file.display(),
            "Private key file already exists, skipping",
        );
    } else {
        info!(file = ?priv_validator_key_file, "Saving private key");
        let private_keys = generate_private_keys(node, 1, false);
        let priv_validator_key = node.make_private_key_file(private_keys[0].clone());
        save_priv_validator_key(node, priv_validator_key_file, &priv_validator_key)?;
    }

    // Save default genesis
    if genesis_file.exists() && !overwrite {
        warn!(
            "Genesis file already exists at {:?}, skipping",
            genesis_file.display()
        )
    } else {
        let private_keys = generate_private_keys(node, 1, false);
        let public_keys = private_keys
            .iter()
            .map(|pk| node.get_public_key(pk))
            .collect();

        let genesis = generate_genesis(node, public_keys, false);
        info!(file = ?genesis_file, "Saving test genesis");
        save_genesis(node, genesis_file, &genesis)?;
    }

    Ok(())
}

```
---
### `test/cli/src/cmd/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod distributed_testnet;
pub mod dump_wal;
pub mod init;
pub mod start;
pub mod testnet;

```
---
### `test/cli/src/cmd/start.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use clap::Parser;
use color_eyre::eyre;
use tracing::info;

use malachitebft_app::node::Node;
use malachitebft_config::MetricsConfig;

use crate::metrics;

#[derive(Parser, Debug, Clone, Default, PartialEq)]
pub struct StartCmd {
    #[clap(long)]
    pub start_height: Option<u64>,
}

impl StartCmd {
    pub async fn run(&self, node: impl Node, metrics: Option<MetricsConfig>) -> eyre::Result<()> {
        info!("Node is starting...");

        start(node, metrics).await?;

        info!("Node has stopped");

        Ok(())
    }
}

/// start command to run a node.
pub async fn start(node: impl Node, metrics: Option<MetricsConfig>) -> eyre::Result<()> {
    // Enable Prometheus
    if let Some(metrics) = metrics {
        if metrics.enabled {
            tokio::spawn(metrics::serve(metrics.listen_addr));
        }
    }

    // Start the node
    node.run().await?;

    Ok(())
}

```
---
### `test/cli/src/cmd/testnet.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
//! Testnet command

use std::path::Path;
use std::str::FromStr;
use std::time::Duration;

use clap::Parser;
use color_eyre::eyre::{eyre, Result};
use tracing::info;

use malachitebft_app::node::{
    CanGeneratePrivateKey, CanMakeConfig, CanMakeGenesis, CanMakePrivateKeyFile,
    MakeConfigSettings, Node,
};
use malachitebft_config::*;

use crate::args::Args;
use crate::error::Error;
use crate::file::{save_config, save_genesis, save_priv_validator_key};

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum RuntimeFlavour {
    SingleThreaded,
    MultiThreaded(usize),
}

impl FromStr for RuntimeFlavour {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.contains(':') {
            match s.split_once(':') {
                Some(("multi-threaded", n)) => Ok(RuntimeFlavour::MultiThreaded(
                    n.parse()
                        .map_err(|_| "Invalid number of threads".to_string())?,
                )),
                _ => Err(format!("Invalid runtime flavour: {s}")),
            }
        } else {
            match s {
                "single-threaded" => Ok(RuntimeFlavour::SingleThreaded),
                "multi-threaded" => Ok(RuntimeFlavour::MultiThreaded(0)),
                _ => Err(format!("Invalid runtime flavour: {s}")),
            }
        }
    }
}

#[derive(Parser, Debug, Clone, PartialEq)]
pub struct TestnetCmd {
    /// Number of validator nodes in the testnet
    #[clap(short, long)]
    pub nodes: usize,

    /// Generate deterministic private keys for reproducibility
    #[clap(short, long)]
    pub deterministic: bool,

    /// The flavor of Tokio runtime to use.
    /// Possible values:
    /// - "single-threaded": A single threaded runtime (default)
    /// - "multi-threaded:N":  A multi-threaded runtime with as N worker threads
    ///   Use a value of 0 for N to use the number of cores available on the system.
    #[clap(short, long, default_value = "single-threaded", verbatim_doc_comment)]
    pub runtime: RuntimeFlavour,

    /// Enable peer discovery.
    /// If enabled, the node will attempt to discover other nodes in the network
    #[clap(long, default_value = "false")]
    pub enable_discovery: bool,

    /// Bootstrap protocol
    /// The protocol used to bootstrap the discovery mechanism
    /// Possible values:
    /// - "kademlia": Kademlia
    /// - "full": Full mesh (default)
    #[clap(long, default_value = "full", verbatim_doc_comment)]
    pub bootstrap_protocol: BootstrapProtocol,

    /// Selector
    /// The selection strategy used to select persistent peers
    /// Possible values:
    /// - "kademlia": Kademlia-based selection, only available with the Kademlia bootstrap protocol
    /// - "random": Random selection (default)
    #[clap(long, default_value = "random", verbatim_doc_comment)]
    pub selector: Selector,

    /// Number of outbound peers
    #[clap(long, default_value = "20", verbatim_doc_comment)]
    pub num_outbound_peers: usize,

    /// Number of inbound peers
    /// Must be greater than or equal to the number of outbound peers
    #[clap(long, default_value = "20", verbatim_doc_comment)]
    pub num_inbound_peers: usize,

    /// Ephemeral connection timeout
    /// The duration in milliseconds an ephemeral connection is kept alive
    #[clap(long, default_value = "5000", verbatim_doc_comment)]
    pub ephemeral_connection_timeout_ms: u64,

    /// The transport protocol to use for P2P communication
    /// Possible values:
    /// - "tcp": TCP + Noise (default)
    /// - "quic": QUIC
    #[clap(short, long, default_value = "tcp", verbatim_doc_comment)]
    pub transport: TransportProtocol,
}

impl TestnetCmd {
    /// Execute the testnet command
    pub fn run<N>(&self, node: &N, home_dir: &Path) -> Result<()>
    where
        N: Node + CanMakeConfig + CanMakePrivateKeyFile + CanGeneratePrivateKey + CanMakeGenesis,
    {
        let runtime = match self.runtime {
            RuntimeFlavour::SingleThreaded => RuntimeConfig::SingleThreaded,
            RuntimeFlavour::MultiThreaded(n) => RuntimeConfig::MultiThreaded { worker_threads: n },
        };

        let settings = MakeConfigSettings {
            runtime,
            transport: self.transport,
            discovery: DiscoveryConfig {
                enabled: self.enable_discovery,
                bootstrap_protocol: self.bootstrap_protocol,
                selector: self.selector,
                num_outbound_peers: self.num_outbound_peers,
                num_inbound_peers: self.num_inbound_peers,
                ephemeral_connection_timeout: Duration::from_millis(
                    self.ephemeral_connection_timeout_ms,
                ),
            },
        };

        testnet(node, self.nodes, home_dir, self.deterministic, settings)
            .map_err(|e| eyre!("Failed to generate testnet configuration: {:?}", e))
    }
}

pub fn testnet<N>(
    node: &N,
    nodes: usize,
    home_dir: &Path,
    deterministic: bool,
    settings: MakeConfigSettings,
) -> std::result::Result<(), Error>
where
    N: Node + CanMakeConfig + CanMakePrivateKeyFile + CanGeneratePrivateKey + CanMakeGenesis,
{
    let private_keys = crate::new::generate_private_keys(node, nodes, deterministic);
    let public_keys = private_keys
        .iter()
        .map(|pk| node.get_public_key(pk))
        .collect();

    let genesis = crate::new::generate_genesis(node, public_keys, deterministic);

    for (i, private_key) in private_keys.iter().enumerate().take(nodes) {
        // Use home directory `home_dir/<index>`
        let node_home_dir = home_dir.join(i.to_string());

        info!(
            id = %i,
            home = %node_home_dir.display(),
            "Generating configuration for node..."
        );

        // Set the destination folder
        let args = Args {
            home: Some(node_home_dir),
            ..Args::default()
        };

        // Save config
        save_config::<N>(
            &args.get_config_file_path()?,
            &N::make_config(i, nodes, settings),
        )?;

        // Save private key
        let priv_validator_key = node.make_private_key_file((*private_key).clone());
        save_priv_validator_key(
            node,
            &args.get_priv_validator_key_file_path()?,
            &priv_validator_key,
        )?;

        // Save genesis
        save_genesis(node, &args.get_genesis_file_path()?, &genesis)?;
    }

    Ok(())
}

```
---
### `test/cli/src/error.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Custom error messages for CLI helper functions.
//! This low level implementation allows the developer to choose their own error handling library.
use std::path::PathBuf;

/// Error messages for commands
#[derive(Debug, thiserror::Error)]
pub enum Error {
    /// Error creating parent directory
    #[error("Error creating parent directory: {}", .0.display())]
    ParentDir(PathBuf),

    /// Error opening file
    #[error("Error opening file: {}", .0.display())]
    OpenFile(PathBuf),

    /// Error writing file
    #[error("Error writing file: {}", .0.display())]
    WriteFile(PathBuf),

    /// Error loading file
    #[error("Error loading file: {}", .0.display())]
    LoadFile(PathBuf),

    /// Error converting to JSON
    #[error("Error converting to JSON: {0}")]
    ToJSON(String),

    /// Error determining home directory path
    #[error("Error determining home directory path")]
    DirPath,

    /// Error joining threads
    #[error("Error joining threads")]
    Join,
}

```
---
### `test/cli/src/file.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! File save functions

use std::fs;
use std::path::Path;

use malachitebft_app::node::Node;

use crate::error::Error;

/// Save configuration to file
pub fn save_config<N: Node>(config_file: &Path, config: &N::Config) -> Result<(), Error> {
    save(
        config_file,
        &toml::to_string_pretty(config).map_err(|e| Error::ToJSON(e.to_string()))?,
    )
}

/// Save genesis to file
pub fn save_genesis<N: Node>(
    _node: &N,
    genesis_file: &Path,
    genesis: &N::Genesis,
) -> Result<(), Error> {
    save(
        genesis_file,
        &serde_json::to_string_pretty(genesis).map_err(|e| Error::ToJSON(e.to_string()))?,
    )
}

/// Save private_key validator key to file
pub fn save_priv_validator_key<N: Node>(
    _node: &N,
    priv_validator_key_file: &Path,
    priv_validator_key: &N::PrivateKeyFile,
) -> Result<(), Error> {
    save(
        priv_validator_key_file,
        &serde_json::to_string_pretty(priv_validator_key)
            .map_err(|e| Error::ToJSON(e.to_string()))?,
    )
}

fn save(path: &Path, data: &str) -> Result<(), Error> {
    use std::io::Write;

    if let Some(parent_dir) = path.parent() {
        fs::create_dir_all(parent_dir).map_err(|_| Error::ParentDir(parent_dir.to_path_buf()))?;
    }

    let mut f = fs::OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|_| Error::OpenFile(path.to_path_buf()))?;

    f.write_all(data.as_bytes())
        .map_err(|_| Error::WriteFile(path.to_path_buf()))?;

    Ok(())
}

```
---
### `test/cli/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod args;
pub mod cmd;
pub mod error;
pub mod file;
pub mod logging;
pub mod metrics;
pub mod new;
pub mod runtime;

pub mod config {
    pub use malachitebft_config::*;
}

```
---
### `test/cli/src/logging.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use std::sync::OnceLock;

use tracing::error;
use tracing_appender::non_blocking::WorkerGuard;
use tracing_subscriber::layer::SubscriberExt;
use tracing_subscriber::util::SubscriberInitExt;
use tracing_subscriber::{fmt, reload, Registry};

use malachitebft_config::LogFormat;

pub use malachitebft_config::LogLevel;
pub use tracing_subscriber::filter::EnvFilter;

static RELOAD_HANDLE: OnceLock<reload::Handle<EnvFilter, Registry>> = OnceLock::new();
static DEFAULT_LOG_LEVEL: OnceLock<String> = OnceLock::new();

pub fn reset() {
    let log_level = DEFAULT_LOG_LEVEL
        .get()
        .expect("failed to get the default log level");

    reload_env_filter(build_tracing_filter(log_level));
}

pub fn reload(log_level: LogLevel) {
    let env_filter = build_tracing_filter(&log_level.to_string());
    reload_env_filter(env_filter);
}

fn reload_env_filter(env_filter: EnvFilter) {
    if let Some(handle) = RELOAD_HANDLE.get() {
        if let Err(e) = handle.reload(env_filter) {
            error!("Failed to reload the log level: {e}");
        }
    } else {
        error!("ERROR: Failed to get the reload handle");
    }
}

/// Initialize logging.
///
/// Returns a drop guard responsible for flushing any remaining logs when the program terminates.
/// The guard must be assigned to a binding that is not _, as _ will result in the guard being dropped immediately.
pub fn init(log_level: LogLevel, log_format: LogFormat) -> WorkerGuard {
    let log_level = if let Ok(rust_log) = std::env::var("RUST_LOG") {
        rust_log
    } else {
        log_level.to_string()
    };

    DEFAULT_LOG_LEVEL
        .set(log_level.clone())
        .expect("failed to set the default log level");

    let env_filter = build_tracing_filter(&log_level);

    let (reload_filter, reload_handle) = reload::Layer::new(env_filter);
    RELOAD_HANDLE
        .set(reload_handle)
        .expect("failed to set the reload handle");

    let (non_blocking, guard) = tracing_appender::non_blocking(std::io::stdout());

    // Construct a tracing subscriber with the supplied filter and enable reloading.
    let fmt_layer = fmt::Layer::default()
        .with_target(false)
        .with_writer(non_blocking)
        .with_ansi(enable_ansi())
        .with_thread_ids(false);

    // There must be a better way to use conditionals in the builder pattern.
    match log_format {
        LogFormat::Plaintext => {
            tracing_subscriber::registry()
                .with(reload_filter)
                .with(fmt_layer)
                .init();
        }
        LogFormat::Json => {
            tracing_subscriber::registry()
                .with(reload_filter)
                .with(fmt_layer.json())
                .init();
        }
    };

    guard
}

/// Checks if output is going to a terminal.
///
/// Determines if both stdout and stderr are proper terminals (TTY).
/// This helps decide whether to enable colored output with ANSI escape codes.
/// Colors are disabled when output is redirected to a file.
pub fn enable_ansi() -> bool {
    use std::io::IsTerminal;
    std::io::stdout().is_terminal() && std::io::stderr().is_terminal()
}

/// Common prefixes of the crates targeted by the default log level.
const TARGET_CRATES: &[&str] = &["informalsystems_malachitebft"];

/// Build a tracing directive setting the log level for the relayer crates to the
/// given `log_level`.
pub fn default_directive(log_level: &str) -> String {
    use itertools::Itertools;

    TARGET_CRATES
        .iter()
        .map(|&c| format!("{c}={log_level}"))
        .join(",")
}

/// Builds a tracing filter based on the input `log_levels`.
/// Enables tracing exclusively for the relayer crates.
/// Returns error if the filter failed to build.
fn build_tracing_filter(log_levels: &str) -> EnvFilter {
    // Prefer RUST_LOG as the default setting.
    let mut directive = EnvFilter::from_default_env();

    if !log_levels.is_empty() {
        for log_level in log_levels.split(',') {
            // app_log_level: no target means only the application log should be targeted
            // https://github.com/informalsystems/malachite/pull/287#discussion_r1684212675
            let app_log_level = if !log_level.contains('=') {
                default_directive(log_level)
            } else {
                log_level.to_string()
            }
            .parse()
            .unwrap_or_else(|e| panic!("Invalid log level '{log_level}': {e}"));

            directive = directive.add_directive(app_log_level)
        }
    }

    directive
}

```
---
### `test/cli/src/metrics.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::io;

use axum::routing::get;
use axum::Router;
use tokio::net::{TcpListener, ToSocketAddrs};
use tracing::{error, info};

use malachitebft_app::metrics::export;

#[tracing::instrument(name = "metrics", skip_all)]
pub async fn serve(listen_addr: impl ToSocketAddrs) {
    if let Err(e) = inner(listen_addr).await {
        error!("Metrics server failed: {e}");
    }
}

async fn inner(listen_addr: impl ToSocketAddrs) -> io::Result<()> {
    let app = Router::new().route("/metrics", get(get_metrics));
    let listener = TcpListener::bind(listen_addr).await?;
    let local_addr = listener.local_addr()?;

    info!(address = %local_addr, "Serving metrics");
    axum::serve(listener, app).await?;

    Ok(())
}

async fn get_metrics() -> String {
    let mut buf = String::new();
    export(&mut buf);
    buf
}

```
---
### `test/cli/src/new.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
//! key and configuration generation

use rand::prelude::StdRng;
use rand::rngs::OsRng;
use rand::{Rng, SeedableRng};

use malachitebft_app::node::{CanGeneratePrivateKey, CanMakeGenesis, Node};
use malachitebft_core_types::{PrivateKey, PublicKey};

const MIN_VOTING_POWER: u64 = 1;
const MAX_VOTING_POWER: u64 = 1;

/// Generate private keys. Random or deterministic for different use-cases.
pub fn generate_private_keys<N>(
    node: &N,
    size: usize,
    deterministic: bool,
) -> Vec<PrivateKey<N::Context>>
where
    N: Node + CanGeneratePrivateKey,
{
    if deterministic {
        let mut rng = StdRng::seed_from_u64(0x42);
        (0..size)
            .map(|_| node.generate_private_key(&mut rng))
            .collect()
    } else {
        (0..size)
            .map(|_| node.generate_private_key(OsRng))
            .collect()
    }
}

/// Generate a Genesis file from the public keys and voting power.
/// Voting power can be random or deterministically pseudo-random.
pub fn generate_genesis<N>(
    node: &N,
    pks: Vec<PublicKey<N::Context>>,
    deterministic: bool,
) -> N::Genesis
where
    N: Node + CanMakeGenesis,
{
    let validators: Vec<_> = if deterministic {
        let mut rng = StdRng::seed_from_u64(0x42);
        pks.into_iter()
            .map(|pk| (pk, rng.gen_range(MIN_VOTING_POWER..=MAX_VOTING_POWER)))
            .collect()
    } else {
        pks.into_iter()
            .map(|pk| (pk, OsRng.gen_range(MIN_VOTING_POWER..=MAX_VOTING_POWER)))
            .collect()
    };

    node.make_genesis(validators)
}

```
---
### `test/cli/src/runtime.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Multithreaded runtime builder.

use malachitebft_config::RuntimeConfig;
use std::io::Result;
use tokio::runtime::{Builder as RtBuilder, Runtime};

pub fn build_runtime(cfg: RuntimeConfig) -> Result<Runtime> {
    let mut builder = match cfg {
        RuntimeConfig::SingleThreaded => RtBuilder::new_current_thread(),
        RuntimeConfig::MultiThreaded { worker_threads } => {
            let mut builder = RtBuilder::new_multi_thread();
            if worker_threads > 0 {
                builder.worker_threads(worker_threads);
            }
            builder
        }
    };

    builder.enable_all().build()
}

```
---
### `test/framework/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-test-framework"
publish = false

version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
malachitebft-app.workspace = true
malachitebft-engine.workspace = true
malachitebft-core-types.workspace = true
malachitebft-config.workspace = true
malachitebft-core-consensus.workspace = true
malachitebft-metrics.workspace = true
malachitebft-test.workspace = true
malachitebft-test-app.workspace = true

axum.workspace = true
bytesize.workspace = true
derive-where.workspace = true
eyre.workspace = true
rand.workspace = true
ractor.workspace = true
tokio.workspace = true
tracing.workspace = true
tracing-subscriber.workspace = true
tempfile.workspace = true

[lints]
workspace = true

```
---
### `test/framework/src/expected.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Expected {
    Exactly(usize),
    AtLeast(usize),
    AtMost(usize),
    LessThan(usize),
    GreaterThan(usize),
}

impl Expected {
    pub fn check(&self, actual: usize) -> bool {
        match self {
            Expected::Exactly(expected) => actual == *expected,
            Expected::AtLeast(expected) => actual >= *expected,
            Expected::AtMost(expected) => actual <= *expected,
            Expected::LessThan(expected) => actual < *expected,
            Expected::GreaterThan(expected) => actual > *expected,
        }
    }
}

impl fmt::Display for Expected {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Expected::Exactly(n) => write!(f, "exactly {n}"),
            Expected::AtLeast(n) => write!(f, "at least {n}"),
            Expected::AtMost(n) => write!(f, "at most {n}"),
            Expected::LessThan(n) => write!(f, "less than {n}"),
            Expected::GreaterThan(n) => write!(f, "greater than {n}"),
        }
    }
}

```
---
### `test/framework/src/lib.rs`
*2025-05-18 23:58:49 | 12 KB*
```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::Duration;

use axum::async_trait;
use tokio::sync::Mutex;
use tokio::task::JoinSet;
use tokio::time::error::Elapsed;
use tokio::time::sleep;
use tracing::{debug, error, error_span, info, Instrument};

use malachitebft_core_types::{Context, Height};

pub use malachitebft_app::node::{
    CanGeneratePrivateKey, CanMakeConfig, CanMakeGenesis, CanMakePrivateKeyFile, EngineHandle,
    Node, NodeHandle,
};
pub use malachitebft_engine::util::events::{Event, RxEvent, TxEvent};

mod logging;
use logging::init_logging;

mod node;
pub use node::{HandlerResult, NodeId, TestNode};

mod params;
pub use params::TestParams;

mod expected;
pub use expected::Expected;

use node::Step;

fn unique_id() -> usize {
    use std::sync::atomic::{AtomicUsize, Ordering};
    static ID: AtomicUsize = AtomicUsize::new(1);
    ID.fetch_add(1, Ordering::SeqCst)
}

pub struct TestBuilder<Ctx, S>
where
    Ctx: Context,
{
    nodes: Vec<TestNode<Ctx, S>>,
}

impl<Ctx, S> Default for TestBuilder<Ctx, S>
where
    Ctx: Context,
{
    fn default() -> Self {
        Self { nodes: Vec::new() }
    }
}

impl<Ctx, S> TestBuilder<Ctx, S>
where
    Ctx: Context,
    S: Send + Sync + 'static,
{
    pub fn new() -> Self {
        Self::default()
    }

    pub fn add_node(&mut self) -> &mut TestNode<Ctx, S>
    where
        S: Default,
    {
        let node = TestNode::new(self.nodes.len() + 1);
        self.nodes.push(node);
        self.nodes.last_mut().unwrap()
    }

    pub fn build(self) -> Test<Ctx, S> {
        Test::new(self.nodes)
    }
}

/// In order to work around orphan rules, `R` must be a type
/// defined in the same crate where this trait is implemented.
/// It does not matter what the type is, as long as it is local.
/// You can use the same type as for the `Runner` type member.
pub trait HasTestRunner<R>: Context {
    type Runner: NodeRunner<Self>;
}

pub struct Test<Ctx, S>
where
    Ctx: Context,
{
    pub id: usize,
    pub nodes: Vec<TestNode<Ctx, S>>,
}

impl<Ctx, S> Test<Ctx, S>
where
    Ctx: Context,
{
    pub fn new(nodes: Vec<TestNode<Ctx, S>>) -> Self {
        Self {
            id: unique_id(),
            nodes,
        }
    }

    pub async fn run<R>(self, timeout: Duration)
    where
        Ctx: HasTestRunner<R>,
        S: Send + Sync + 'static,
    {
        self.run_with_params(timeout, TestParams::default()).await
    }

    pub async fn run_with_params<R>(self, timeout: Duration, params: TestParams)
    where
        Ctx: HasTestRunner<R>,
        S: Send + Sync + 'static,
    {
        run_test::<Ctx::Runner, Ctx, S>(self, timeout, params).await
    }
}

fn check_results(results: Vec<(NodeId, Result<TestResult, Elapsed>)>) {
    let mut errors = 0;

    for (id, result) in results {
        let _span = tracing::error_span!("node", %id).entered();

        match result {
            Ok(TestResult::Success(reason)) => {
                info!("Test succeeded: {reason}");
            }
            Ok(TestResult::Failure(reason)) => {
                errors += 1;
                error!("Test failed: {reason}");
            }
            Err(_) => {
                errors += 1;
                error!("Test timed out");
            }
        }
    }

    if errors > 0 {
        error!("Test failed with {errors} errors");
        std::process::exit(1);
    }
}

#[derive(Debug)]
pub enum TestResult {
    Success(String),
    Failure(String),
}

pub async fn run_test<R, Ctx, S>(test: Test<Ctx, S>, timeout: Duration, params: TestParams)
where
    Ctx: Context,
    R: NodeRunner<Ctx>,
    S: Send + Sync + 'static,
{
    init_logging();

    let span = error_span!("test", id = %test.id);

    let mut set = JoinSet::new();

    let runner = R::new(test.id, &test.nodes, params);

    for node in test.nodes {
        let runner = runner.clone();

        set.spawn(
            async move {
                let id = node.id;
                let result = tokio::time::timeout(timeout, run_node(runner, node)).await;
                (id, result)
            }
            .instrument(span.clone()),
        );
    }

    let results = set.join_all().await;
    check_results(results);
}

#[async_trait]
pub trait NodeRunner<Ctx>
where
    Self: Clone + Send + Sync + 'static,
    Ctx: Context,
{
    type NodeHandle: NodeHandle<Ctx>;

    fn new<S>(id: usize, nodes: &[TestNode<Ctx, S>], params: TestParams) -> Self;

    async fn spawn(&self, id: NodeId) -> eyre::Result<Self::NodeHandle>;
    async fn reset_db(&self, id: NodeId) -> eyre::Result<()>;
}

#[tracing::instrument("node", skip_all, fields(id = %node.id))]
pub async fn run_node<Ctx, R, S>(runner: R, mut node: TestNode<Ctx, S>) -> TestResult
where
    Ctx: Context,
    R: NodeRunner<Ctx>,
    S: Send + Sync + 'static,
{
    sleep(node.start_delay).await;

    info!(%node.voting_power, "Spawning node");

    let mut handle = runner.spawn(node.id).await.unwrap();

    let mut rx_event = handle.subscribe();
    let rx_event_monitor = handle.subscribe();

    let decisions = Arc::new(AtomicUsize::new(0));
    let current_height = Arc::new(AtomicUsize::new(0));
    let failure = Arc::new(Mutex::new(None));
    let is_full_node = node.is_full_node();

    let spawn_event_monitor = |mut rx: RxEvent<Ctx>| {
        tokio::spawn({
            let decisions = Arc::clone(&decisions);
            let current_height = Arc::clone(&current_height);
            let failure = Arc::clone(&failure);

            async move {
                while let Ok(event) = rx.recv().await {
                    match &event {
                        Event::StartedHeight(height, _is_restart) => {
                            current_height.store(height.as_u64() as usize, Ordering::SeqCst);
                        }
                        Event::Decided(_) => {
                            decisions.fetch_add(1, Ordering::SeqCst);
                        }
                        Event::Published(msg) if is_full_node => {
                            error!("Full node unexpectedly published a consensus message: {msg:?}");
                            *failure.lock().await = Some(format!(
                                "Full node unexpectedly published a consensus message: {msg:?}"
                            ));
                        }
                        Event::WalReplayError(e) => {
                            error!("WAL replay error: {e}");
                            *failure.lock().await = Some(format!("WAL replay error: {e}"));
                        }
                        _ => (),
                    }

                    debug!("Event: {event}");
                }
            }
            .in_current_span()
        })
    };

    let mut event_monitor = spawn_event_monitor(rx_event_monitor);

    for step in node.steps {
        if let Some(failure) = failure.lock().await.take() {
            return TestResult::Failure(failure);
        }

        match step {
            Step::WaitUntil(target_height) => {
                info!("Waiting until node reaches height {target_height}");

                'inner: while let Ok(event) = rx_event.recv().await {
                    if let Some(failure) = failure.lock().await.take() {
                        return TestResult::Failure(failure);
                    }

                    let Event::StartedHeight(height, _is_restart) = event else {
                        continue 'inner;
                    };

                    info!("Node started height {height}");

                    current_height.store(height.as_u64() as usize, Ordering::SeqCst);

                    if height.as_u64() == target_height {
                        break 'inner;
                    }
                }
            }

            Step::WaitUntilRound(target_round) => {
                info!("Waiting until node reaches round {target_round}");

                'inner: while let Ok(event) = rx_event.recv().await {
                    if let Some(failure) = failure.lock().await.take() {
                        return TestResult::Failure(failure);
                    }

                    let Event::StartedRound(_, round) = event else {
                        continue 'inner;
                    };

                    info!("Node started round {round}");

                    if round.as_u32() == Some(target_round) {
                        break 'inner;
                    }
                }
            }

            Step::Crash(after) => {
                let height = current_height.load(Ordering::SeqCst);

                info!("Node will crash at height {height}");
                sleep(after).await;

                event_monitor.abort();

                handle
                    .kill(Some("Test framework has crashed the node".to_string()))
                    .await
                    .expect("Node must stop");
            }

            Step::ResetDb => {
                info!("Resetting database");
                runner.reset_db(node.id).await.unwrap();
            }

            Step::Restart(after) => {
                info!("Node will restart in {after:?}");

                sleep(after).await;

                info!("Spawning node");
                let new_handle = runner.spawn(node.id).await.unwrap();
                info!("Spawned");

                let new_rx_event = new_handle.subscribe();
                let new_rx_event_bg = new_handle.subscribe();

                event_monitor = spawn_event_monitor(new_rx_event_bg);
                handle = new_handle;
                rx_event = new_rx_event;
            }

            Step::OnEvent(on_event) => {
                'inner: while let Ok(event) = rx_event.recv().await {
                    match on_event(event, &mut node.state) {
                        Ok(HandlerResult::WaitForNextEvent) => {
                            continue 'inner;
                        }
                        Ok(HandlerResult::ContinueTest) => {
                            break 'inner;
                        }
                        Err(e) => {
                            error!("Event handler returned an error: {e}");

                            event_monitor.abort();
                            handle.kill(Some("Test failed".to_string())).await.unwrap();

                            return TestResult::Failure(e.to_string());
                        }
                    }
                }
            }

            Step::Expect(expected) => {
                let actual = decisions.load(Ordering::SeqCst);

                event_monitor.abort();
                handle.kill(Some("Test failed".to_string())).await.unwrap();

                if expected.check(actual) {
                    break;
                } else {
                    return TestResult::Failure(format!(
                        "Incorrect number of decisions: got {actual}, expected: {expected}"
                    ));
                }
            }

            Step::Success => {
                break;
            }

            Step::Fail(reason) => {
                event_monitor.abort();
                handle.kill(Some("Test failed".to_string())).await.unwrap();

                return TestResult::Failure(reason);
            }
        }
    }

    let failure = failure.lock().await.take();
    if let Some(failure) = failure {
        TestResult::Failure(failure)
    } else {
        TestResult::Success("OK".to_string())
    }
}

```
---
### `test/framework/src/logging.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
pub fn init_logging() {
    use tracing_subscriber::util::SubscriberInitExt;
    use tracing_subscriber::{EnvFilter, FmtSubscriber};

    let debug_vars = &[("ACTIONS_RUNNER_DEBUG", "true"), ("MALACHITE_DEBUG", "1")];
    let enable_debug = debug_vars
        .iter()
        .any(|(k, v)| std::env::var(k).as_deref() == Ok(v));

    let trace_level = if enable_debug { "debug" } else { "info" };

    let directives = &[
        ("informalsystems_malachitebft", trace_level),
        (env!("CARGO_CRATE_NAME"), "debug"),
        ("it", "debug"), // Name of the integration test crate
        ("informalsystems_malachitebft_test", "debug"),
        ("informalsystems_malachitebft_test_app", "debug"),
        ("informalsystems_malachitebft_discovery", "error"),
        ("libp2p", "warn"),
        ("ractor", "warn"),
    ];

    let directive = directives
        .iter()
        .map(|(target, level)| format!("{target}={level}"))
        .collect::<Vec<_>>()
        .join(",");

    let filter = EnvFilter::builder().parse(directive).unwrap();

    pub fn enable_ansi() -> bool {
        use std::io::IsTerminal;
        std::io::stdout().is_terminal() && std::io::stderr().is_terminal()
    }

    // Construct a tracing subscriber with the supplied filter and enable reloading.
    let builder = FmtSubscriber::builder()
        .with_target(false)
        .with_env_filter(filter)
        .with_test_writer()
        .with_ansi(enable_ansi())
        .with_thread_ids(false);

    let subscriber = builder.finish();

    if let Err(e) = subscriber.try_init() {
        eprintln!("Failed to initialize logging: {e}");
    }
}

```
---
### `test/framework/src/node.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use std::sync::Arc;
use std::time::Duration;

use eyre::bail;
use tracing::info;

use malachitebft_core_consensus::{LocallyProposedValue, SignedConsensusMsg};
use malachitebft_core_types::{Context, Height, SignedVote, Vote, VoteType, VotingPower};
use malachitebft_engine::util::events::Event;
use malachitebft_test::middleware::{DefaultMiddleware, Middleware};

use crate::Expected;

pub type NodeId = usize;

pub enum Step<Ctx, S>
where
    Ctx: Context,
{
    Crash(Duration),
    ResetDb,
    Restart(Duration),
    WaitUntil(u64),
    WaitUntilRound(u32),
    OnEvent(EventHandler<Ctx, S>),
    Expect(Expected),
    Success,
    Fail(String),
}

#[derive(Copy, Clone, Debug)]
pub enum HandlerResult {
    WaitForNextEvent,
    ContinueTest,
}

pub type EventHandler<Ctx, S> =
    Box<dyn Fn(Event<Ctx>, &mut S) -> Result<HandlerResult, eyre::Report> + Send + Sync>;

pub struct TestNode<Ctx, State = ()>
where
    Ctx: Context,
{
    pub id: NodeId,
    pub voting_power: VotingPower,
    pub start_height: Ctx::Height,
    pub start_delay: Duration,
    pub steps: Vec<Step<Ctx, State>>,
    pub state: State,
    pub middleware: Arc<dyn Middleware>,
}

impl<Ctx, State> TestNode<Ctx, State>
where
    Ctx: Context,
{
    pub fn new(id: usize) -> Self
    where
        State: Default,
    {
        Self::new_with_state(id, State::default())
    }

    pub fn new_with_state(id: usize, state: State) -> Self {
        Self {
            id,
            voting_power: 1,
            start_height: Ctx::Height::INITIAL,
            start_delay: Duration::from_secs(0),
            steps: vec![],
            state,
            middleware: Arc::new(DefaultMiddleware),
        }
    }

    pub fn with_middleware(&mut self, middleware: impl Middleware + 'static) -> &mut Self {
        self.middleware = Arc::new(middleware);
        self
    }

    pub fn with_state(&mut self, state: State) -> &mut Self {
        self.state = state;
        self
    }

    pub fn with_voting_power(&mut self, power: VotingPower) -> &mut Self {
        self.voting_power = power;
        self
    }

    pub fn start(&mut self) -> &mut Self {
        self.start_height = <Ctx::Height>::INITIAL;
        self
    }

    pub fn start_at(&mut self, height: u64) -> &mut Self {
        self.start_after(height, Duration::from_secs(0))
    }

    pub fn start_after(&mut self, height: u64, delay: Duration) -> &mut Self {
        self.start_height = Ctx::Height::ZERO.increment_by(height);
        self.start_delay = delay;
        self
    }

    pub fn crash(&mut self) -> &mut Self {
        self.steps.push(Step::Crash(Duration::from_secs(0)));
        self
    }

    pub fn crash_after(&mut self, duration: Duration) -> &mut Self {
        self.steps.push(Step::Crash(duration));
        self
    }

    pub fn reset_db(&mut self) -> &mut Self {
        self.steps.push(Step::ResetDb);
        self
    }

    pub fn restart_after(&mut self, delay: Duration) -> &mut Self {
        self.steps.push(Step::Restart(delay));
        self
    }

    pub fn wait_until(&mut self, height: u64) -> &mut Self {
        self.steps.push(Step::WaitUntil(height));
        self
    }

    pub fn wait_until_round(&mut self, round: u32) -> &mut Self {
        self.steps.push(Step::WaitUntilRound(round));
        self
    }

    pub fn on_event<F>(&mut self, on_event: F) -> &mut Self
    where
        F: Fn(Event<Ctx>, &mut State) -> Result<HandlerResult, eyre::Report>
            + Send
            + Sync
            + 'static,
    {
        self.steps.push(Step::OnEvent(Box::new(on_event)));
        self
    }

    pub fn expect_wal_replay(&mut self, at_height: u64) -> &mut Self {
        self.on_event(move |event, _| {
            let Event::WalReplayBegin(height, count) = event else {
                return Ok(HandlerResult::WaitForNextEvent);
            };

            info!("Replaying WAL at height {height} with {count} messages");

            if height.as_u64() != at_height {
                bail!("Unexpected WAL replay at height {height}, expected {at_height}")
            }

            Ok(HandlerResult::ContinueTest)
        })
    }

    pub fn expect_vote_rebroadcast(
        &mut self,
        at_height: u64,
        at_round: u32,
        vote_type: VoteType,
    ) -> &mut Self {
        self.on_event(move |event, _| {
            let Event::RebroadcastVote(msg) = event else {
                return Ok(HandlerResult::WaitForNextEvent);
            };

            let (height, round) = (msg.height(), msg.round());

            if height.as_u64() != at_height {
                bail!("Unexpected vote rebroadcast for height {height}, expected {at_height}")
            }

            if round.as_u32() != Some(at_round) {
                bail!("Unexpected vote rebroadcast for round {round}, expected {at_round}")
            }

            if vote_type != msg.vote_type() {
                bail!(
                    "Unexpected vote type {vote_type:?}, expected {:?}",
                    msg.vote_type()
                )
            }

            info!(%height, %round, ?vote_type, "Rebroadcasted vote");

            Ok(HandlerResult::ContinueTest)
        })
    }

    pub fn expect_round_certificate_rebroadcast(
        &mut self,
        at_height: u64,
        at_round: u32,
    ) -> &mut Self {
        self.on_event(move |event, _| {
            let Event::RebroadcastRoundCertificate(msg) = event else {
                return Ok(HandlerResult::WaitForNextEvent);
            };

            let (height, round) = (msg.height, msg.round);

            if height.as_u64() != at_height {
                bail!("Unexpected round certificate rebroadcast for height {height}, expected {at_height}")
            }

            if round.as_u32() != Some(at_round) {
                bail!("Unexpected round certificate rebroadcast for round {round}, expected {at_round}")
            }

            info!(%height, %round, "Rebroadcasted round certificate");

            Ok(HandlerResult::ContinueTest)
        })
    }

    pub fn expect_skip_round_certificate(&mut self, at_height: u64, at_round: u32) -> &mut Self {
        self.on_event(move |event, _| {
            let Event::SkipRoundCertificate(msg) = event else {
                return Ok(HandlerResult::WaitForNextEvent);
            };

            let (height, round) = (msg.height, msg.round);

            if height.as_u64() != at_height {
                bail!("Unexpected round certificate broadcast for height {height}, expected {at_height}")
            }

            if round.as_u32() != Some(at_round) {
                bail!("Unexpected round certificate broadcast for round {round}, expected {at_round}")
            }

            info!(%height, %round, "Broadcasted skip round certificate");

            Ok(HandlerResult::ContinueTest)
        })
    }

    pub fn expect_polka_certificate(&mut self, at_height: u64, at_round: u32) -> &mut Self {
        self.on_event(move |event, _| {
            let Event::PolkaCertificate(msg) = event else {
                return Ok(HandlerResult::WaitForNextEvent);
            };

            let (height, round) = (msg.height, msg.round);

            if height.as_u64() != at_height {
                bail!("Unexpected round certificate rebroadcast for height {height}, expected {at_height}")
            }

            if round.as_u32() != Some(at_round) {
                bail!("Unexpected round certificate rebroadcast for round {round}, expected {at_round}")
            }

            info!(%height, %round, "Broadcasted round certificate");

            Ok(HandlerResult::ContinueTest)
        })
    }

    pub fn on_proposed_value<F>(&mut self, f: F) -> &mut Self
    where
        F: Fn(LocallyProposedValue<Ctx>, &mut State) -> Result<HandlerResult, eyre::Report>
            + Send
            + Sync
            + 'static,
    {
        self.on_event(move |event, state| {
            if let Event::ProposedValue(value) = event {
                f(value, state)
            } else {
                Ok(HandlerResult::WaitForNextEvent)
            }
        })
    }

    pub fn on_vote<F>(&mut self, f: F) -> &mut Self
    where
        F: Fn(SignedVote<Ctx>, &mut State) -> Result<HandlerResult, eyre::Report>
            + Send
            + Sync
            + 'static,
    {
        self.on_event(move |event, state| {
            if let Event::Published(SignedConsensusMsg::Vote(vote)) = event {
                f(vote, state)
            } else {
                Ok(HandlerResult::WaitForNextEvent)
            }
        })
    }

    pub fn expect_decisions(&mut self, expected: Expected) -> &mut Self {
        self.steps.push(Step::Expect(expected));
        self
    }

    pub fn success(&mut self) -> &mut Self {
        self.steps.push(Step::Success);
        self
    }

    pub fn full_node(&mut self) -> &mut Self {
        self.voting_power = 0;
        self
    }

    pub fn is_full_node(&self) -> bool {
        self.voting_power == 0
    }

    pub fn with(&mut self, f: impl FnOnce(&mut Self)) -> &mut Self {
        f(self);
        self
    }
}

```
---
### `test/framework/src/params.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use bytesize::ByteSize;

use malachitebft_config::{PubSubProtocol, ValuePayload};
use malachitebft_test_app::config::Config;

#[derive(Copy, Clone, Debug)]
pub struct TestParams {
    pub enable_value_sync: bool,
    pub protocol: PubSubProtocol,
    pub block_size: ByteSize,
    pub tx_size: ByteSize,
    pub txs_per_part: usize,
    pub vote_extensions: Option<ByteSize>,
    pub value_payload: ValuePayload,
    pub max_retain_blocks: usize,
    pub stable_block_times: bool,
}

impl Default for TestParams {
    fn default() -> Self {
        Self {
            enable_value_sync: false,
            protocol: PubSubProtocol::default(),
            block_size: ByteSize::mib(1),
            tx_size: ByteSize::kib(1),
            txs_per_part: 256,
            vote_extensions: None,
            value_payload: ValuePayload::ProposalAndParts,
            max_retain_blocks: 50,
            stable_block_times: true,
        }
    }
}

impl TestParams {
    pub fn apply_to_config(&self, config: &mut Config) {
        config.value_sync.enabled = self.enable_value_sync;
        config.consensus.p2p.protocol = self.protocol;
        config.consensus.value_payload = self.value_payload;
        config.test.max_block_size = self.block_size;
        config.test.txs_per_part = self.txs_per_part;
        config.test.vote_extensions.enabled = self.vote_extensions.is_some();
        config.test.vote_extensions.size = self.vote_extensions.unwrap_or_default();
        config.test.max_retain_blocks = self.max_retain_blocks;
        config.test.stable_block_times = self.stable_block_times;
    }
}

```
---
### `test/mbt/Cargo.toml`
*2025-05-18 23:58:49 | 2 KB*
```toml
[package]
name = "informalsystems-malachitebft-test-mbt"
description = "Library for model-based testing of the Malachite consensus engine"
publish = false

version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true

[dependencies]
malachitebft-core-types = { workspace = true }
malachitebft-core-votekeeper = { workspace = true }
malachitebft-core-state-machine = { workspace = true }
malachitebft-test = { workspace = true }
malachitebft-starknet-host = { workspace = true }
malachitebft-engine = { workspace = true }
malachitebft-peer = { workspace = true }

itf = { workspace = true }
rand = { workspace = true }
num-bigint = { workspace = true, features = ["serde"] }
num-traits = { workspace = true }
serde = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }
serde_with = { workspace = true }
glob = { workspace = true }
pretty_assertions = { workspace = true }
multihash = { workspace = true }

[dev-dependencies]
tempfile = { version = "3.19.1" }

```
---
### `test/mbt/src/consensus.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use itf::de::{As, Integer, Same};
use serde::Deserialize;

use crate::deserializers as de;
use crate::types::{Address, Height, NonNilValue, Proposal, Round, Step, Timeout, Value, Vote};

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
pub struct State {
    pub state: ConsensusState,
    pub input: Input,
    pub output: Output,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename = "ConsensusInput")]
#[serde(tag = "tag", content = "value")]
pub enum Input {
    #[serde(rename = "NoConsensusInput")]
    NoInput,

    #[serde(rename = "NewRoundCInput")]
    #[serde(with = "As::<Integer>")]
    NewRound(Round),

    #[serde(rename = "NewRoundProposerCInput")]
    #[serde(with = "As::<Integer>")]
    NewRoundProposer(Round),

    #[serde(rename = "ProposeValueCInput")]
    ProposeValue(NonNilValue),

    #[serde(rename = "ProposalCInput")]
    #[serde(with = "As::<(Integer, Same)>")]
    Proposal(Round, Value),

    #[serde(rename = "ProposalAndPolkaPreviousAndValidCInput")]
    #[serde(with = "As::<(Same, Integer)>")]
    ProposalAndPolkaPreviousAndValid(Value, Round),

    #[serde(rename = "ProposalInvalidCInput")]
    ProposalInvalid,

    #[serde(rename = "PolkaNilCInput")]
    PolkaNil,

    #[serde(rename = "PolkaAnyCInput")]
    PolkaAny,

    #[serde(rename = "ProposalAndPolkaAndValidCInput")]
    ProposalAndPolkaAndValid(Value),

    #[serde(rename = "ProposalAndPolkaAndInvalidCInput")]
    ProposalAndPolkaAndInvalid(Value),

    #[serde(rename = "PrecommitAnyCInput")]
    PrecommitAny,

    #[serde(rename = "ProposalAndCommitAndValidCInput")]
    #[serde(with = "As::<(Integer, Same)>")]
    ProposalAndCommitAndValid(Round, NonNilValue),

    #[serde(rename = "RoundSkipCInput")]
    #[serde(with = "As::<Integer>")]
    RoundSkip(Round),

    #[serde(rename = "TimeoutProposeCInput")]
    #[serde(with = "As::<(Integer, Integer)>")]
    TimeoutPropose(Height, Round),

    #[serde(rename = "TimeoutPrevoteCInput")]
    #[serde(with = "As::<(Integer, Integer)>")]
    TimeoutPrevote(Height, Round),

    #[serde(rename = "TimeoutPrecommitCInput")]
    #[serde(with = "As::<(Integer, Integer)>")]
    TimeoutPrecommit(Height, Round),
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename = "ConsensusOutput")]
#[serde(tag = "tag", content = "value")]
pub enum Output {
    #[serde(rename = "NoConsensusOutput")]
    NoOutput,

    #[serde(rename = "ProposalOutput")]
    Proposal(Proposal),

    #[serde(rename = "GetValueAndScheduleTimeoutOutput")]
    #[serde(with = "As::<(Integer, Integer, Same)>")]
    GetValueAndScheduleTimeout(Height, Round, Timeout),

    #[serde(rename = "VoteOutput")]
    Vote(Vote),

    #[serde(rename = "TimeoutOutput")]
    #[serde(with = "As::<(Integer, Same)>")]
    Timeout(Round, Timeout),

    #[serde(rename = "DecidedOutput")]
    #[serde(with = "As::<(Integer, Same)>")]
    Decided(Round, NonNilValue),

    #[serde(rename = "SkipRoundOutput")]
    #[serde(with = "As::<Integer>")]
    SkipRound(Round),

    #[serde(rename = "ErrorOutput")]
    Error(String),
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ConsensusState {
    #[serde(rename = "p")]
    pub process: Address,
    #[serde(with = "As::<Integer>")]
    pub height: Height,
    #[serde(with = "As::<Integer>")]
    pub round: Round,
    pub step: Step,
    #[serde(deserialize_with = "de::minus_one_as_none")]
    pub locked_round: Option<Round>,
    pub locked_value: Value,
    #[serde(deserialize_with = "de::minus_one_as_none")]
    pub valid_round: Option<Round>,
    pub valid_value: Value,
}

```
---
### `test/mbt/src/deserializers.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use num_bigint::BigInt;
use num_traits::cast::ToPrimitive;
use serde::Deserialize;

pub(crate) fn minus_one_as_none<'de, D>(de: D) -> Result<Option<i64>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let opt = Option::<BigInt>::deserialize(de).unwrap();
    match opt {
        None => Ok(None),
        Some(i) if i == BigInt::from(-1) => Ok(None),
        Some(i) => Ok(i.to_i64()),
    }
}

```
---
### `test/mbt/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod consensus;
pub mod deserializers;
pub mod types;
pub mod utils;
pub mod votekeeper;

#[cfg(test)]
pub mod tests;

```
---
### `test/mbt/src/tests/consensus/runner.rs`
*2025-05-18 23:58:49 | 14 KB*
```rust
use std::collections::BTreeMap;

use pretty_assertions::assert_eq;

use malachitebft_core_state_machine::input::Input;
use malachitebft_core_state_machine::output::Output;
use malachitebft_core_state_machine::{state::State as RoundState, state_machine::Info};
use malachitebft_core_types::{Context, NilOrVal, Round};
use malachitebft_test::{Address, Height, TestContext};

use itf::Runner as ItfRunner;

use crate::consensus::{Input as ModelInput, Output as ModelOutput, State};
use crate::types::Step;

use super::utils::{
    value_from_model, value_from_string, value_id_from_model, value_id_from_string, OTHER_PROCESS,
};

pub struct ConsensusRunner {
    pub ctx: TestContext,
    pub address_map: BTreeMap<String, Address>,
    pub last_state: Option<State>,
    pub skip_step: bool,
}

impl ConsensusRunner {
    pub fn new(address_map: BTreeMap<String, Address>) -> Self {
        Self {
            ctx: TestContext::new(),
            address_map,
            last_state: None,
            skip_step: false,
        }
    }
}

impl ItfRunner for ConsensusRunner {
    type ActualState = RoundState<TestContext>;
    type Result = Option<Output<TestContext>>;
    type ExpectedState = State;
    type Error = ();

    fn init(&mut self, expected: &Self::ExpectedState) -> Result<Self::ActualState, Self::Error> {
        println!(" init: expected state={:?}", expected.state);

        let height = Height::new(expected.state.height as u64);
        let round = expected.state.round;

        let round = Round::from(round);
        let init_state = RoundState::new(height, round);

        Ok(init_state)
    }

    fn step(
        &mut self,
        actual: &mut Self::ActualState,
        expected: &Self::ExpectedState,
    ) -> Result<Self::Result, Self::Error> {
        self.skip_step = false;

        if let Some(last_state) = self.last_state.replace(expected.clone()) {
            if &last_state == expected {
                println!(" Skipping duplicate step");
                self.skip_step = true;
                return Ok(None);
            }
        }

        println!(" step: actual state={:?}", actual);
        println!(" step: model input={:?}", expected.input);
        println!(" step: model state={:?}", expected.state);

        let address = self.address_map.get(&expected.state.process).unwrap();
        let some_other_node = self.address_map.get(OTHER_PROCESS).unwrap();

        let (data, input) = match &expected.input {
            ModelInput::NoInput => unreachable!(),

            ModelInput::NewRound(round) => {
                let round = Round::from(*round);

                (
                    Info::new(round, address, some_other_node),
                    Input::NewRound(round),
                )
            }

            ModelInput::NewRoundProposer(round) => {
                let round = Round::from(*round);
                (Info::new_proposer(round, address), Input::NewRound(round))
            }

            ModelInput::ProposeValue(non_nil_value) => {
                let value = value_from_string(non_nil_value).unwrap();
                let data = Info::new_proposer(actual.round, address);
                (data, Input::ProposeValue(value))
            }

            ModelInput::Proposal(round, value) => {
                let input_round = Round::from(*round);
                let data = Info::new(input_round, address, some_other_node);
                let proposal = self.ctx.new_proposal(
                    actual.height,
                    input_round,
                    value_from_model(value).unwrap(),
                    Round::Nil,
                    *some_other_node,
                );
                (data, Input::Proposal(proposal))
            }

            ModelInput::ProposalAndPolkaPreviousAndValid(value, valid_round) => {
                let data = Info::new(actual.round, address, some_other_node);
                let proposal = self.ctx.new_proposal(
                    actual.height,
                    actual.round,
                    value_from_model(value).unwrap(),
                    Round::from(*valid_round),
                    *some_other_node,
                );
                (data, Input::ProposalAndPolkaPrevious(proposal))
            }

            ModelInput::ProposalAndPolkaAndValid(value) => {
                let data = Info::new(actual.round, address, some_other_node);
                let proposal = self.ctx.new_proposal(
                    actual.height,
                    actual.round,
                    value_from_model(value).unwrap(),
                    Round::Nil,
                    *some_other_node,
                );
                (data, Input::ProposalAndPolkaCurrent(proposal))
            }

            ModelInput::ProposalAndPolkaAndInvalid(value) => {
                let data = Info::new(actual.round, address, some_other_node);
                let proposal = self.ctx.new_proposal(
                    actual.height,
                    actual.round,
                    value_from_model(value).unwrap(),
                    Round::Nil,
                    *some_other_node,
                );
                (data, Input::InvalidProposalAndPolkaPrevious(proposal))
            }

            ModelInput::ProposalAndCommitAndValid(round, value) => {
                let input_round = Round::from(*round);
                let data = Info::new(input_round, address, some_other_node);
                let proposal = self.ctx.new_proposal(
                    actual.height,
                    input_round,
                    value_from_string(value).unwrap(),
                    Round::Nil,
                    *some_other_node,
                );
                (data, Input::ProposalAndPrecommitValue(proposal))
            }

            ModelInput::ProposalInvalid => (
                Info::new(actual.round, address, some_other_node),
                Input::InvalidProposal,
            ),

            ModelInput::PolkaNil => (
                Info::new(actual.round, address, some_other_node),
                Input::PolkaNil,
            ),

            ModelInput::PolkaAny => (
                Info::new(actual.round, address, some_other_node),
                Input::PolkaAny,
            ),

            ModelInput::PrecommitAny => (
                Info::new(actual.round, address, some_other_node),
                Input::PrecommitAny,
            ),

            ModelInput::RoundSkip(round) => {
                let input_round = Round::from(*round);
                (
                    Info::new(input_round, address, some_other_node),
                    Input::SkipRound(input_round),
                )
            }

            ModelInput::TimeoutPropose(_height, round) => (
                Info::new(Round::from(*round), address, some_other_node),
                Input::TimeoutPropose,
            ),

            ModelInput::TimeoutPrevote(_height, round) => (
                Info::new(Round::from(*round), address, some_other_node),
                Input::TimeoutPrevote,
            ),

            ModelInput::TimeoutPrecommit(_height, round) => (
                Info::new(Round::from(*round), address, some_other_node),
                Input::TimeoutPrecommit,
            ),
        };

        let round_state = core::mem::take(actual);
        let transition = round_state.apply(&self.ctx, &data, input);

        println!(" transition: next state={:?}", transition.next_state);
        println!(" transition: output={:?}", transition.output);

        *actual = transition.next_state;

        Ok(transition.output)
    }

    fn result_invariant(
        &self,
        result: &Self::Result,
        expected: &Self::ExpectedState,
    ) -> Result<bool, Self::Error> {
        if self.skip_step {
            return Ok(true);
        }

        // Get expected result.
        let expected_result = &expected.output;

        println!(" result invariant:   actual output={:?}", result);
        println!(" result invariant: expected output={:?}", expected_result);

        // Check result against expected result.
        match result {
            Some(result) => match (result, expected_result) {
                (Output::NewRound(round), ModelOutput::SkipRound(expected_round)) => {
                    assert_eq!(round.as_i64(), *expected_round);
                }

                (Output::Proposal(proposal), ModelOutput::Proposal(expected_proposal)) => {
                    // TODO: check expected_proposal.src_address
                    assert_eq!(proposal.height.as_u64() as i64, expected_proposal.height);
                    assert_eq!(proposal.round.as_i64(), expected_proposal.round);
                    assert_eq!(proposal.pol_round.as_i64(), expected_proposal.valid_round);
                    assert_eq!(
                        Some(&proposal.value),
                        value_from_string(&expected_proposal.proposal).as_ref(),
                        "unexpected proposal value"
                    );
                }

                (Output::Vote(vote), ModelOutput::Vote(expected_vote)) => {
                    let expected_src_address = self
                        .address_map
                        .get(expected_vote.src_address.as_str())
                        .unwrap();

                    assert_eq!(vote.validator_address, *expected_src_address);
                    assert_eq!(vote.typ, expected_vote.vote_type.to_common());
                    assert_eq!(vote.height.as_u64() as i64, expected_vote.height);
                    assert_eq!(vote.round.as_i64(), expected_vote.round);

                    let expected_value = expected_vote.value_id.fold(NilOrVal::Nil, |value| {
                        NilOrVal::Val(value_id_from_string(value).unwrap())
                    });
                    assert_eq!(vote.value, expected_value);
                }

                (
                    Output::ScheduleTimeout(timeout),
                    ModelOutput::Timeout(expected_round, expected_timeout),
                ) => {
                    assert_eq!(timeout.round.as_i64(), *expected_round);
                    assert_eq!(timeout.kind, expected_timeout.to_common());
                }

                (
                    Output::GetValueAndScheduleTimeout(output_height, output_round, output_timeout),
                    ModelOutput::GetValueAndScheduleTimeout(
                        model_height,
                        model_round,
                        model_timeout,
                    ),
                ) => {
                    assert_eq!(output_height.as_u64(), *model_height as u64);
                    assert_eq!(output_round.as_i64(), *model_round);
                    assert_eq!(output_timeout.kind, model_timeout.to_common());
                }

                (
                    Output::Decision(round, proposal),
                    ModelOutput::Decided(expected_round, expected_decided_value),
                ) => {
                    assert_eq!(round.as_i64(), *expected_round, "unexpected decided round");

                    assert_eq!(
                        Some(&proposal.value),
                        value_from_string(expected_decided_value).as_ref(),
                        "unexpected decided value"
                    );
                }

                _ => panic!("actual: {result:?}\nexpected: {expected:?}"),
            },

            None => panic!("no actual result; expected result: {expected_result:?}"),
        }

        Ok(true)
    }

    fn state_invariant(
        &self,
        actual: &Self::ActualState,
        expected: &Self::ExpectedState,
    ) -> Result<bool, Self::Error> {
        if self.skip_step {
            return Ok(true);
        }

        // TODO: What to do with actual.height? There is no height in the spec.

        println!(" state invariant: actual state={:?}", actual);
        println!(" state invariant: expected state={:?}", expected.state);

        if expected.state.step == Step::None {
            // This is the initial state.
            assert_eq!(actual.round, Round::Nil, "unexpected round");
        } else {
            assert_eq!(Some(actual.step), expected.state.step.to_round_step());

            if expected.state.step == Step::Unstarted {
                // In the spec, the new round comes from the input, it's not in the state.
                assert_eq!(
                    actual.round.as_i64(),
                    expected.state.round + 1,
                    "unexpected round"
                );
            } else {
                assert_eq!(
                    actual.round.as_i64(),
                    expected.state.round,
                    "unexpected round"
                );
            }
        }
        assert_eq!(
            actual.valid.as_ref().map(|v| v.round.as_i64()),
            expected.state.valid_round,
            "unexpected valid round"
        );
        assert_eq!(
            actual.valid.as_ref().map(|v| v.value.id()),
            value_id_from_model(&expected.state.valid_value),
            "unexpected valid value"
        );
        assert_eq!(
            actual.locked.as_ref().map(|v| v.round.as_i64()),
            expected.state.locked_round,
            "unexpected locked round"
        );
        assert_eq!(
            actual.locked.as_ref().map(|v| v.value.id()),
            value_id_from_model(&expected.state.locked_value),
            "unexpected locked value"
        );

        Ok(true)
    }
}

```
---
### `test/mbt/src/tests/consensus/utils.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::collections::BTreeMap;

use rand::rngs::StdRng;

use malachitebft_test::{Address, PrivateKey, Value, ValueId};

use crate::consensus::State;
use crate::types::{NonNilValue, Value as ModelValue};

pub const OTHER_PROCESS: &str = "Other";

/// Build mapping from model addresses to real addresses
pub fn build_address_map(trace: &itf::Trace<State>, rng: &mut StdRng) -> BTreeMap<String, Address> {
    trace
        .states
        .iter()
        .map(|state| state.value.state.process.clone())
        .chain(std::iter::once(OTHER_PROCESS.to_string()))
        .map(|name| {
            let pk = PrivateKey::generate(&mut *rng).public_key();
            (name, Address::from_public_key(&pk))
        })
        .collect()
}

pub fn value_from_string(v: &NonNilValue) -> Option<Value> {
    match v.as_str() {
        "block" => Some(Value::new(1)),
        "nextBlock" => Some(Value::new(2)),
        _ => panic!("unknown value {v:?}"),
    }
}

pub fn value_from_model(value: &ModelValue) -> Option<Value> {
    match value {
        ModelValue::Nil => None,
        ModelValue::Val(v) => value_from_string(v),
    }
}

pub fn value_id_from_model(value: &ModelValue) -> Option<ValueId> {
    value_from_model(value).map(|v| v.id())
}

pub fn value_id_from_string(v: &NonNilValue) -> Option<ValueId> {
    value_from_string(v).map(|v| v.id())
}

```
---
### `test/mbt/src/tests/consensus.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use glob::glob;
use rand::rngs::StdRng;
use rand::SeedableRng;

use crate::consensus::State;
use crate::utils::{generate_test_traces, quint_seed};

pub mod runner;
pub mod utils;

use runner::ConsensusRunner;

const RANDOM_SEED: u64 = 0x42;

#[test]
fn test_itf() {
    let temp_dir = tempfile::TempDir::with_prefix("informalsystems-malachitebft-core-consensus-")
        .expect("Failed to create temp dir");
    let temp_path = temp_dir.path().to_owned();

    if std::env::var("KEEP_TEMP").is_ok() {
        std::mem::forget(temp_dir);
    }

    let quint_seed = quint_seed();

    generate_test_traces(
        "consensus/quint/tests/consensus/consensusTest.qnt",
        &temp_path.to_string_lossy(),
        quint_seed,
    );

    for json_fixture in glob(&format!("{}/*.itf.json", temp_path.display()))
        .expect("Failed to read glob pattern")
        .flatten()
    {
        println!(
            " Running trace {:?}",
            json_fixture.file_name().unwrap().to_str().unwrap()
        );

        let json = std::fs::read_to_string(&json_fixture).unwrap();
        let trace = itf::trace_from_str::<State>(&json).unwrap();

        let mut rng = StdRng::seed_from_u64(RANDOM_SEED);

        // Build mapping from model addresses to real addresses
        let address_map = utils::build_address_map(&trace, &mut rng);

        let consensus_runner = ConsensusRunner::new(address_map);
        trace.run_on(consensus_runner).unwrap();
    }
}

```
---
### `test/mbt/src/tests/votekeeper/runner.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use std::collections::HashMap;

use malachitebft_core_types::{Context, NilOrVal, Round, SignedVote, Value};
use malachitebft_core_votekeeper::keeper::{Output, VoteKeeper};
use malachitebft_core_votekeeper::ThresholdParams;
use malachitebft_test::{Address, Height, Signature, TestContext, Vote};

use itf::Runner as ItfRunner;
use rand::rngs::StdRng;

use crate::types::{Value as ModelValue, VoteType};
use crate::votekeeper::VoteKeeperOutput::*;
use crate::votekeeper::{State, WeightedVote};

use super::utils::{build_address_map, build_validator_set, check_votes, value_from_model};

#[derive(Debug)]
pub struct VoteKeeperRunner {
    rng: StdRng,
    addresses: HashMap<String, Address>,
    last_state: Option<State>,
    skip_step: bool,
}

impl VoteKeeperRunner {
    pub fn new(rng: StdRng) -> Self {
        Self {
            rng,
            addresses: HashMap::new(),
            last_state: None,
            skip_step: false,
        }
    }
}

impl ItfRunner for VoteKeeperRunner {
    type ActualState = VoteKeeper<TestContext>;
    type Result = Option<Output<<<TestContext as Context>::Value as Value>::Id>>;
    type ExpectedState = State;
    type Error = ();

    fn init(&mut self, expected: &Self::ExpectedState) -> Result<Self::ActualState, Self::Error> {
        let height = expected.bookkeeper.height as u64;
        let total_weight = expected.bookkeeper.total_weight() as u64;
        let validator_weights = &expected.bookkeeper.validator_set;

        println!(" init: height={height}, total_weight={total_weight}");

        let validator_set = build_validator_set(validator_weights.iter(), &mut self.rng);

        let public_keys = validator_weights
            .keys()
            .zip(validator_set.validators.iter())
            .map(|(name, val)| (name, &val.public_key));

        self.addresses = build_address_map(public_keys);

        Ok(VoteKeeper::new(validator_set, ThresholdParams::default()))
    }

    fn step(
        &mut self,
        actual: &mut Self::ActualState,
        expected: &Self::ExpectedState,
    ) -> Result<Self::Result, Self::Error> {
        self.skip_step = false;

        if let Some(last_state) = self.last_state.replace(expected.clone()) {
            if &last_state == expected {
                println!(" Skipping duplicate step");
                self.skip_step = true;
                return Ok(None);
            }
        }

        match &expected.weighted_vote {
            WeightedVote::NoVote => Err(()),

            WeightedVote::Vote(input_vote, weight, current_round) => {
                // Build step to execute.
                let round = Round::from(input_vote.round);
                let height = Height::new(input_vote.height as u64);
                let value = value_from_model(&input_vote.value_id);
                let address = self.addresses.get(input_vote.src_address.as_str()).unwrap();
                let validator = actual.validator_set().get_by_address(address).unwrap();
                let vote = match &input_vote.vote_type {
                    VoteType::Prevote => Vote::new_prevote(height, round, value, *address),
                    VoteType::Precommit => Vote::new_precommit(height, round, value, *address),
                };

                println!(
                    " step: vote={:?}, round={:?}, value={:?}, validator={:?}, weight={:?}, current_round={:?}",
                    input_vote.vote_type, round, value, input_vote.src_address, weight, current_round
                );

                debug_assert_eq!(*weight as u64, validator.voting_power);

                // Execute step.
                Ok(actual.apply_vote(
                    SignedVote::new(vote, Signature::test()),
                    Round::from(*current_round),
                ))
            }
        }
    }

    fn result_invariant(
        &self,
        result: &Self::Result,
        expected: &Self::ExpectedState,
    ) -> Result<bool, Self::Error> {
        if self.skip_step {
            return Ok(true);
        }

        let expected_result = &expected.last_emitted;

        match result {
            Some(result) => match (result, expected_result) {
                // TODO: check expected_round
                (Output::PolkaNil, PolkaNil(_expected_round)) => (),
                (Output::PolkaAny, PolkaAny(_expected_round)) => (),
                (Output::PolkaValue(value), PolkaValue(_expected_round, expected_value)) => {
                    assert_eq!(
                        NilOrVal::Val(value),
                        value_from_model(&ModelValue::Val(expected_value.to_string())).as_ref()
                    );
                }
                (Output::PrecommitAny, PrecommitAny(_expected_round)) => (),
                (
                    Output::PrecommitValue(value),
                    PrecommitValue(_expected_round, expected_value),
                ) => {
                    assert_eq!(
                        NilOrVal::Val(value),
                        value_from_model(&ModelValue::Val(expected_value.to_string())).as_ref()
                    );
                }
                (Output::SkipRound(round), Skip(expected_round)) => {
                    assert_eq!(round, &Round::from(*expected_round));
                }
                (actual, expected) => {
                    panic!("actual: {:?}, expected: {:?}", actual, expected)
                }
            },
            None => assert_eq!(*expected_result, NoOutput),
        }
        Ok(true)
    }

    fn state_invariant(
        &self,
        actual: &Self::ActualState,
        expected: &Self::ExpectedState,
    ) -> Result<bool, Self::Error> {
        if self.skip_step {
            return Ok(true);
        }

        // doesn't check for current Height and Round

        let actual_state = actual;
        let expected_state = &expected.bookkeeper;

        assert_eq!(
            actual_state.total_weight(),
            expected_state.total_weight() as u64,
            "total_weight for the current height"
        );

        assert_eq!(actual_state.rounds(), expected_state.rounds.len());

        for (&round, expected_round) in &expected_state.rounds {
            // doesn't check for current Height and Round

            let actual_round = actual_state.per_round(Round::from(round)).unwrap();

            let expected_outputs = &expected_round.emitted_outputs;
            let actual_outputs = actual_round.emitted_outputs();

            assert_eq!(
                actual_outputs.len(),
                expected_outputs.len(),
                "number of emitted events"
            );

            let mut event_count = HashMap::new();

            for event in expected_outputs {
                let event_name = match event {
                    PolkaAny(_) => "PolkaAny".to_string(),
                    PolkaNil(_) => "PolkaNil".to_string(),
                    PolkaValue(_, _) => "PolkaValue".to_string(),
                    PrecommitAny(_) => "PrecommitAny".to_string(),
                    PrecommitValue(_, _) => "PrecommitValue".to_string(),
                    Skip(_) => "Skip".to_string(),
                    _ => format!("{event:?}"),
                };

                let count = event_count.entry(event_name).or_insert(0);
                *count += 1;
            }

            for event in actual_outputs {
                let event_name = match event {
                    Output::PolkaValue(_) => "PolkaValue".to_string(),
                    Output::PrecommitValue(_) => "PrecommitValue".to_string(),
                    Output::SkipRound(_) => "Skip".to_string(),
                    _ => format!("{event:?}"),
                };

                let count = event_count.entry(event_name).or_insert(0);
                *count -= 1;
            }

            for (event_name, count) in event_count {
                assert_eq!(count, 0, "event {event_name:?} not matched");
            }

            let expected_addresses_weights = &expected_round.votes_addresses_weights;
            let actual_addresses_weights = &actual_round.addresses_weights().get_inner();
            for (address, expected_weight) in expected_addresses_weights {
                assert_eq!(
                    actual_addresses_weights.get(self.addresses.get(address).unwrap()),
                    Some(&(*expected_weight as u64)),
                    "weight for address {address:?}"
                );
            }

            let actual_votes = &actual_round.votes();

            let expected_prevotes = &expected_round.prevotes;
            let actual_prevotes = actual_votes.prevotes();
            check_votes(expected_prevotes, actual_prevotes, &self.addresses);

            let expected_precommits = &expected_round.precommits;
            let actual_precommits = actual_votes.precommits();
            check_votes(expected_precommits, actual_precommits, &self.addresses);
        }

        Ok(true)
    }
}

```
---
### `test/mbt/src/tests/votekeeper/utils.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::collections::HashMap;

use rand::{CryptoRng, RngCore};

use malachitebft_core_types::NilOrVal;
use malachitebft_core_votekeeper as core;
use malachitebft_test::{
    Address, PrivateKey, PublicKey, TestContext, Validator, ValidatorSet, ValueId,
};

use crate::types::Value;

pub const VALIDATORS: [&str; 3] = ["alice", "bob", "john"];

pub fn build_address_map<'a>(
    public_keys: impl Iterator<Item = (&'a String, &'a PublicKey)>,
) -> HashMap<String, Address> {
    public_keys
        .map(|(name, pk)| (name.clone(), Address::from_public_key(pk)))
        .collect()
}

pub fn build_validator_set<'a, R>(
    weights: impl Iterator<Item = (&'a String, &'a i64)>,
    mut rng: R,
) -> ValidatorSet
where
    R: RngCore + CryptoRng,
{
    let validators = weights.map(|(_name, weight)| {
        let public_key = PrivateKey::generate(&mut rng).public_key();
        Validator::new(public_key, *weight as u64)
    });

    ValidatorSet::new(validators)
}

pub fn value_from_model(value: &Value) -> NilOrVal<ValueId> {
    match value {
        Value::Nil => NilOrVal::Nil,
        Value::Val(v) => match v.as_str() {
            "v1" => NilOrVal::Val(1.into()),
            "v2" => NilOrVal::Val(2.into()),
            "v3" => NilOrVal::Val(3.into()),
            _ => unimplemented!("unknown value {value:?}"),
        },
    }
}

pub fn check_votes(
    expected: &crate::votekeeper::VoteCount,
    actual: &core::count::VoteCount<TestContext>,
    address_map: &HashMap<String, Address>,
) {
    // expected has `total_weight` which is not present in actual

    let expected_values_weights = &expected.values_weights;
    let actual_values_weights = &actual.values_weights;

    // should check length too

    for value in expected_values_weights.keys() {
        assert_eq!(
            actual_values_weights.get(&value_from_model(value)),
            *expected_values_weights.get(value).unwrap() as u64,
            "weight for value {value:?}"
        );
    }

    let expected_votes_addresses = &expected.votes_addresses;
    let actual_votes_addresses = &actual.validator_addresses;

    assert_eq!(
        actual_votes_addresses.len(),
        expected_votes_addresses.len(),
        "number of voted addresses"
    );

    for address in expected_votes_addresses {
        assert!(
            actual_votes_addresses.contains(address_map.get(address).unwrap()),
            "address {address:?} not voted"
        );
    }
}

```
---
### `test/mbt/src/tests/votekeeper.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use glob::glob;

use rand::rngs::StdRng;
use rand::SeedableRng;

use crate::utils::generate_test_traces;
use crate::votekeeper::State;

pub mod runner;
pub mod utils;

use runner::VoteKeeperRunner;

const RANDOM_SEED: u64 = 0x42;

#[test]
fn test_itf() {
    let temp_dir =
        tempfile::TempDir::with_prefix("informalsystems-malachitebft-core-votekeeperkeeper-")
            .expect("Failed to create temp dir");
    let temp_path = temp_dir.path().to_owned();

    if std::env::var("KEEP_TEMP").is_ok() {
        std::mem::forget(temp_dir);
    }

    let quint_seed = option_env!("QUINT_SEED")
        .inspect(|x| {
            println!("using QUINT_SEED={}", x);
        })
        .or(Some("118"))
        .and_then(|x| x.parse::<u64>().ok())
        .filter(|&x| x != 0)
        .expect("invalid random seed for quint");

    generate_test_traces(
        "consensus/quint/tests/votekeeper/votekeeperTest.qnt",
        &temp_path.to_string_lossy(),
        quint_seed,
    );

    for json_fixture in glob(&format!("{}/*.itf.json", temp_path.display()))
        .expect("Failed to read glob pattern")
        .flatten()
    {
        println!(" Running trace {json_fixture:?}");

        let json = std::fs::read_to_string(&json_fixture).unwrap();
        let trace = itf::trace_from_str::<State>(&json).unwrap();

        let rng = StdRng::seed_from_u64(RANDOM_SEED);
        let vote_keeper_runner = VoteKeeperRunner::new(rng);

        trace.run_on(vote_keeper_runner).unwrap();
    }
}

```
---
### `test/mbt/src/tests.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod consensus;
pub mod votekeeper;

```
---
### `test/mbt/src/types.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use itf::de::{As, Integer};
use malachitebft_core_state_machine::state::Step as RoundStep;
use serde::Deserialize;

pub type Height = i64;
pub type Weight = i64;
pub type Round = i64;
pub type Address = String;
pub type NonNilValue = String;

#[derive(Clone, Debug, PartialEq, Eq, Hash, Deserialize)]
#[serde(tag = "tag", content = "value")]
pub enum Value {
    Nil,
    Val(NonNilValue),
}

impl Value {
    pub fn fold<A>(&self, nil: A, val: impl FnOnce(&NonNilValue) -> A) -> A {
        match self {
            Value::Nil => nil,
            Value::Val(value) => val(value),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Proposal {
    pub src_address: Address,
    #[serde(with = "As::<Integer>")]
    pub height: Height,
    #[serde(with = "As::<Integer>")]
    pub round: Round,
    pub proposal: NonNilValue,
    #[serde(with = "As::<Integer>")]
    pub valid_round: Round,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(tag = "tag", content = "value")]
pub enum VoteType {
    Prevote,
    Precommit,
}

impl VoteType {
    pub fn to_common(&self) -> malachitebft_core_types::VoteType {
        match self {
            VoteType::Prevote => malachitebft_core_types::VoteType::Prevote,
            VoteType::Precommit => malachitebft_core_types::VoteType::Precommit,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Vote {
    pub vote_type: VoteType,
    #[serde(with = "As::<Integer>")]
    pub height: Height,
    #[serde(with = "As::<Integer>")]
    pub round: Round,
    pub value_id: Value,
    pub src_address: Address,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(tag = "tag", content = "value")]
pub enum Step {
    #[serde(rename = "NoStep")]
    None,
    #[serde(rename = "UnstartedStep")]
    Unstarted,
    #[serde(rename = "ProposeStep")]
    Propose,
    #[serde(rename = "PrevoteStep")]
    Prevote,
    #[serde(rename = "PrecommitStep")]
    Precommit,
    #[serde(rename = "CommitStep")]
    Commit,
}

impl Step {
    pub fn to_round_step(&self) -> Option<RoundStep> {
        match self {
            Step::None => None,
            Step::Unstarted => Some(RoundStep::Unstarted),
            Step::Propose => Some(RoundStep::Propose),
            Step::Prevote => Some(RoundStep::Prevote),
            Step::Precommit => Some(RoundStep::Precommit),
            Step::Commit => Some(RoundStep::Commit),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(tag = "tag", content = "value")]
pub enum Timeout {
    #[serde(rename = "ProposeTimeout")]
    Propose,

    #[serde(rename = "PrevoteTimeout")]
    Prevote,

    #[serde(rename = "PrecommitTimeout")]
    Precommit,
}

impl Timeout {
    pub fn to_common(&self) -> malachitebft_core_types::TimeoutKind {
        match self {
            Timeout::Propose => malachitebft_core_types::TimeoutKind::Propose,
            Timeout::Prevote => malachitebft_core_types::TimeoutKind::Prevote,
            Timeout::Precommit => malachitebft_core_types::TimeoutKind::Precommit,
        }
    }
}

```
---
### `test/mbt/src/utils.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::path::Path;

pub fn generate_test_traces(spec_rel_path: &str, gen_dir: &str, quint_seed: u64) {
    println!(" Generating test traces for {spec_rel_path:?}...");

    let spec_abs_path = format!("{}/specs/{spec_rel_path}", env!("CARGO_MANIFEST_DIR"),);
    let spec_path = Path::new(&spec_abs_path);

    std::process::Command::new("quint")
        .arg("test")
        .arg("--out-itf")
        .arg(format!("{gen_dir}/test_{{test}}_{{seq}}.itf.json"))
        .arg("--seed")
        .arg(quint_seed.to_string())
        .arg(spec_path)
        .current_dir(spec_path.parent().unwrap())
        .output()
        .expect("Failed to run quint test");

    println!(" Generated traces in {gen_dir:?}");
}

// pub fn generate_random_traces(
//     spec_rel_path: &str,
//     gen_dir: &str,
//     quint_seed: u64,
//     num_traces: u64,
// ) {
//     println!(" Generating random traces for {spec_rel_path:?}...");

//     let spec_abs_path = format!("{}/specs/{spec_rel_path}", env!("CARGO_MANIFEST_DIR"),);
//     let spec_path = Path::new(&spec_abs_path);

//     std::process::Command::new("quint")
//         .arg("run")
//         .arg("--n-traces")
//         .arg(num_traces.to_string())
//         .arg("--max-samples")
//         .arg("1000")
//         .arg("--out-itf")
//         .arg(format!("{gen_dir}/random_{{seq}}.itf.json"))
//         .arg("--seed")
//         .arg(quint_seed.to_string())
//         .arg(spec_path)
//         .current_dir(spec_path.parent().unwrap())
//         .output()
//         .expect("Failed to run quint test");

//     println!(" Generated traces in {gen_dir:?}");
// }

const DEFAULT_QUINT_SEED: u64 = 118;

pub fn quint_seed() -> u64 {
    let seed = std::env::var("QUINT_SEED")
        .ok()
        .and_then(|x| x.parse::<u64>().ok())
        .unwrap_or(DEFAULT_QUINT_SEED);

    println!("Using QUINT_SEED={seed}");

    seed
}

```
---
### `test/mbt/src/votekeeper.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use itf::de::{As, Integer, Same};
use std::collections::{HashMap, HashSet};

use serde::Deserialize;

use crate::types::{Address, Height, NonNilValue, Round, Value, Vote, Weight};

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(tag = "tag", content = "value")]
pub enum WeightedVote {
    #[serde(rename = "NoWeightedVote")]
    NoVote,

    #[serde(rename = "WV")]
    #[serde(with = "As::<(Same, Integer, Integer)>")]
    Vote(Vote, Weight, Round),
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, Deserialize)]
#[serde(tag = "tag", content = "value")]
pub enum VoteKeeperOutput {
    #[serde(rename = "NoVKOutput")]
    NoOutput,

    #[serde(rename = "PolkaAnyVKOutput")]
    #[serde(with = "As::<Integer>")]
    PolkaAny(Round),

    #[serde(rename = "PolkaNilVKOutput")]
    #[serde(with = "As::<Integer>")]
    PolkaNil(Round),

    #[serde(rename = "PolkaValueVKOutput")]
    #[serde(with = "As::<(Integer, Same)>")]
    PolkaValue(Round, NonNilValue),

    #[serde(rename = "PrecommitAnyVKOutput")]
    #[serde(with = "As::<Integer>")]
    PrecommitAny(Round),

    #[serde(rename = "PrecommitValueVKOutput")]
    #[serde(with = "As::<(Integer, Same)>")]
    PrecommitValue(Round, NonNilValue),

    #[serde(rename = "SkipVKOutput")]
    #[serde(with = "As::<Integer>")]
    Skip(Round),
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Bookkeeper {
    #[serde(with = "As::<Integer>")]
    pub height: Height,
    #[serde(with = "As::<HashMap<Same, Integer>>")]
    pub validator_set: HashMap<Address, Weight>,
    #[serde(with = "As::<HashMap<Integer, Same>>")]
    pub rounds: HashMap<Round, RoundVotes>,
}

impl Bookkeeper {
    pub fn total_weight(&self) -> Weight {
        self.validator_set.values().sum()
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RoundVotes {
    #[serde(with = "As::<Integer>")]
    pub height: Height,
    #[serde(with = "As::<Integer>")]
    pub round: Round,
    pub prevotes: VoteCount,
    pub precommits: VoteCount,
    pub emitted_outputs: HashSet<VoteKeeperOutput>,
    #[serde(with = "As::<HashMap<Same, Integer>>")]
    pub votes_addresses_weights: HashMap<Address, Weight>,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VoteCount {
    #[serde(with = "As::<Integer>")]
    pub total_weight: Weight,
    #[serde(with = "As::<HashMap<Same, Integer>>")]
    pub values_weights: HashMap<Value, Weight>,
    pub votes_addresses: HashSet<Address>,
}

#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct State {
    pub bookkeeper: Bookkeeper,
    pub last_emitted: VoteKeeperOutput,
    pub weighted_vote: WeightedVote,
}

```
---
### `test/mempool/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-test-mempool"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
publish = false

[lints]
workspace = true

[dependencies]
malachitebft-metrics = { workspace = true }
malachitebft-proto = { workspace = true }

eyre = { workspace = true }
futures = { workspace = true }
libp2p = { workspace = true }
prost = { workspace = true }
prost-types = { workspace = true }
seahash = { workspace = true }
tokio = { workspace = true, features = ["macros"] }
tracing = { workspace = true }

[build-dependencies]
prost-build.workspace = true
protox.workspace = true

```
---
### `test/mempool/build.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let protos = &["proto/malachite.mempool.proto"];

    for proto in protos {
        println!("cargo:rerun-if-changed={proto}");
    }

    let fds = protox::compile(protos, ["proto"])?;

    let mut config = prost_build::Config::new();
    config.enable_type_names();
    config.compile_fds(fds)?;

    Ok(())
}

```
---
### `test/mempool/src/behaviour.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::time::Duration;

use libp2p::swarm::NetworkBehaviour;
use libp2p::{gossipsub, identify, ping};

pub use libp2p::identity::Keypair;
pub use libp2p::{Multiaddr, PeerId};

use malachitebft_metrics::Registry;

use crate::PROTOCOL;

const MAX_TRANSMIT_SIZE: usize = 4 * 1024 * 1024; // 4 MiB

#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "NetworkEvent")]
pub struct Behaviour {
    pub identify: identify::Behaviour,
    pub ping: ping::Behaviour,
    pub gossipsub: gossipsub::Behaviour,
}

fn message_id(message: &gossipsub::Message) -> gossipsub::MessageId {
    use seahash::SeaHasher;
    use std::hash::{Hash, Hasher};

    let mut hasher = SeaHasher::new();
    message.hash(&mut hasher);
    gossipsub::MessageId::new(hasher.finish().to_be_bytes().as_slice())
}

fn gossipsub_config() -> gossipsub::Config {
    gossipsub::ConfigBuilder::default()
        .max_transmit_size(MAX_TRANSMIT_SIZE)
        .opportunistic_graft_ticks(3)
        .heartbeat_interval(Duration::from_secs(1))
        .validation_mode(gossipsub::ValidationMode::Strict)
        .history_gossip(3)
        .history_length(5)
        .mesh_n_high(4)
        .mesh_n_low(1)
        .mesh_outbound_min(1)
        .mesh_n(3)
        .message_id_fn(message_id)
        .build()
        .unwrap()
}

impl Behaviour {
    pub fn new(keypair: &Keypair) -> Self {
        Self {
            identify: identify::Behaviour::new(identify::Config::new(
                PROTOCOL.to_string(),
                keypair.public(),
            )),
            ping: ping::Behaviour::new(ping::Config::new().with_interval(Duration::from_secs(5))),
            gossipsub: gossipsub::Behaviour::new(
                gossipsub::MessageAuthenticity::Signed(keypair.clone()),
                gossipsub_config(),
            )
            .unwrap(),
        }
    }

    pub fn new_with_metrics(keypair: &Keypair, registry: &mut Registry) -> Self {
        Self {
            identify: identify::Behaviour::new(identify::Config::new(
                PROTOCOL.to_string(),
                keypair.public(),
            )),
            ping: ping::Behaviour::new(ping::Config::new().with_interval(Duration::from_secs(5))),
            gossipsub: gossipsub::Behaviour::new_with_metrics(
                gossipsub::MessageAuthenticity::Signed(keypair.clone()),
                gossipsub_config(),
                registry,
                Default::default(),
            )
            .unwrap(),
        }
    }
}

#[derive(Debug)]
pub enum NetworkEvent {
    Identify(identify::Event),
    Ping(ping::Event),
    GossipSub(gossipsub::Event),
}

impl From<identify::Event> for NetworkEvent {
    fn from(event: identify::Event) -> Self {
        Self::Identify(event)
    }
}

impl From<ping::Event> for NetworkEvent {
    fn from(event: ping::Event) -> Self {
        Self::Ping(event)
    }
}

impl From<gossipsub::Event> for NetworkEvent {
    fn from(event: gossipsub::Event) -> Self {
        Self::GossipSub(event)
    }
}

```
---
### `test/mempool/src/handle.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use prost::bytes::Bytes;
use tokio::sync::mpsc;
use tokio::task;

use crate::{BoxError, Channel, CtrlMsg, Event};

pub struct RecvHandle {
    rx_event: mpsc::Receiver<Event>,
}

impl RecvHandle {
    pub async fn recv(&mut self) -> Option<Event> {
        self.rx_event.recv().await
    }
}

pub struct CtrlHandle {
    tx_ctrl: mpsc::Sender<CtrlMsg>,
    task_handle: task::JoinHandle<()>,
}

impl CtrlHandle {
    pub async fn broadcast(&self, channel: Channel, data: Bytes) -> Result<(), BoxError> {
        self.tx_ctrl
            .send(CtrlMsg::BroadcastMsg(channel, data))
            .await?;
        Ok(())
    }

    pub async fn wait_shutdown(self) -> Result<(), BoxError> {
        self.shutdown().await?;
        self.join().await?;
        Ok(())
    }

    pub async fn shutdown(&self) -> Result<(), BoxError> {
        self.tx_ctrl.send(CtrlMsg::Shutdown).await?;
        Ok(())
    }

    pub async fn join(self) -> Result<(), BoxError> {
        self.task_handle.await?;
        Ok(())
    }
}

pub struct Handle {
    recv: RecvHandle,
    ctrl: CtrlHandle,
}

impl Handle {
    pub fn new(
        tx_ctrl: mpsc::Sender<CtrlMsg>,
        rx_event: mpsc::Receiver<Event>,
        task_handle: task::JoinHandle<()>,
    ) -> Self {
        Self {
            recv: RecvHandle { rx_event },
            ctrl: CtrlHandle {
                tx_ctrl,
                task_handle,
            },
        }
    }

    pub fn split(self) -> (RecvHandle, CtrlHandle) {
        (self.recv, self.ctrl)
    }

    pub async fn recv(&mut self) -> Option<Event> {
        self.recv.recv().await
    }

    pub async fn broadcast(&self, channel: Channel, data: Bytes) -> Result<(), BoxError> {
        self.ctrl.broadcast(channel, data).await
    }

    pub async fn wait_shutdown(self) -> Result<(), BoxError> {
        self.ctrl.wait_shutdown().await
    }

    pub async fn shutdown(&self) -> Result<(), BoxError> {
        self.ctrl.shutdown().await
    }

    pub async fn join(self) -> Result<(), BoxError> {
        self.ctrl.join().await
    }
}

```
---
### `test/mempool/src/lib.rs`
*2025-05-18 23:58:49 | 12 KB*
```rust
#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

use core::fmt;
use std::collections::HashMap;
use std::error::Error;
use std::ops::ControlFlow;
use std::time::Duration;

use eyre::eyre;
use futures::StreamExt;
use libp2p::metrics::{Metrics, Recorder};
use libp2p::swarm::{self, SwarmEvent};
use libp2p::{gossipsub, identify, SwarmBuilder};
use prost::bytes::Bytes;
use tokio::sync::mpsc;
use tracing::{debug, error, error_span, trace, Instrument};

use malachitebft_metrics::SharedRegistry;

pub use libp2p::gossipsub::MessageId;
pub use libp2p::identity::Keypair;
pub use libp2p::{Multiaddr, PeerId};

pub mod behaviour;
pub mod handle;
pub mod proto;
pub mod types;

mod msg;
pub use msg::NetworkMsg;

use behaviour::{Behaviour, NetworkEvent};
use handle::Handle;

const METRICS_PREFIX: &str = "malachitebft_test_mempool";

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Channel {
    Mempool,
}

impl Channel {
    pub fn all() -> &'static [Channel] {
        &[Channel::Mempool]
    }

    pub fn to_topic(self) -> gossipsub::IdentTopic {
        gossipsub::IdentTopic::new(self.as_str())
    }

    pub fn topic_hash(&self) -> gossipsub::TopicHash {
        self.to_topic().hash()
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            Channel::Mempool => "/mempool",
        }
    }

    pub fn has_topic(topic_hash: &gossipsub::TopicHash) -> bool {
        Self::all()
            .iter()
            .any(|channel| &channel.topic_hash() == topic_hash)
    }

    pub fn from_topic_hash(topic: &gossipsub::TopicHash) -> Option<Self> {
        match topic.as_str() {
            "/mempool" => Some(Channel::Mempool),
            _ => None,
        }
    }
}

impl fmt::Display for Channel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.as_str().fmt(f)
    }
}

const PROTOCOL: &str = "/malachitebft-test-mempool/v1beta1";

pub type BoxError = Box<dyn Error + Send + Sync + 'static>;

#[derive(Clone, Debug)]
pub struct Config {
    pub listen_addr: Multiaddr,
    pub persistent_peers: Vec<Multiaddr>,
    pub idle_connection_timeout: Duration,
}

impl Config {
    fn apply(&self, cfg: swarm::Config) -> swarm::Config {
        cfg.with_idle_connection_timeout(self.idle_connection_timeout)
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum TransportProtocol {
    Tcp,
    Quic,
}

impl TransportProtocol {
    pub fn from_multiaddr(multiaddr: &Multiaddr) -> Option<TransportProtocol> {
        for protocol in multiaddr.protocol_stack() {
            match protocol {
                "tcp" => return Some(TransportProtocol::Tcp),
                "quic" | "quic-v1" => return Some(TransportProtocol::Quic),
                _ => {}
            }
        }
        None
    }
}

/// An event that can be emitted by the gossip layer
#[derive(Clone, Debug)]
pub enum Event {
    Listening(Multiaddr),
    Message(Channel, PeerId, MessageId, NetworkMsg),
    PeerConnected(PeerId),
    PeerDisconnected(PeerId),
}

#[derive(Debug)]
pub enum CtrlMsg {
    BroadcastMsg(Channel, Bytes),
    Shutdown,
}

#[derive(Debug, Default)]
pub struct State {
    pub peers: HashMap<PeerId, identify::Info>,
}

pub async fn spawn(
    keypair: Keypair,
    config: Config,
    registry: SharedRegistry,
) -> Result<Handle, BoxError> {
    let mut swarm = registry.with_prefix(METRICS_PREFIX, |registry| -> Result<_, BoxError> {
        let builder = SwarmBuilder::with_existing_identity(keypair).with_tokio();
        match TransportProtocol::from_multiaddr(&config.listen_addr) {
            Some(TransportProtocol::Tcp) => Ok(builder
                .with_tcp(
                    libp2p::tcp::Config::new().nodelay(true), // Disable Nagle's algorithm
                    libp2p::noise::Config::new,
                    libp2p::yamux::Config::default,
                )?
                .with_dns()?
                .with_bandwidth_metrics(registry)
                .with_behaviour(|kp| Behaviour::new_with_metrics(kp, registry))?
                .with_swarm_config(|cfg| config.apply(cfg))
                .build()),
            Some(TransportProtocol::Quic) => Ok(builder
                .with_quic()
                .with_dns()?
                .with_bandwidth_metrics(registry)
                .with_behaviour(|kp| Behaviour::new_with_metrics(kp, registry))?
                .with_swarm_config(|cfg| config.apply(cfg))
                .build()),

            None => Err(eyre!(
                "No valid transport protocol found in listen address: {}",
                config.listen_addr
            )
            .into()),
        }
    })?;

    for channel in Channel::all() {
        swarm
            .behaviour_mut()
            .gossipsub
            .subscribe(&channel.to_topic())?;
    }

    let metrics = registry.with_prefix(METRICS_PREFIX, Metrics::new);

    let (tx_event, rx_event) = mpsc::channel(32);
    let (tx_ctrl, rx_ctrl) = mpsc::channel(32);

    let peer_id = swarm.local_peer_id();
    let span = error_span!("mempool.network", peer = %peer_id);
    let task_handle =
        tokio::task::spawn(run(config, metrics, swarm, rx_ctrl, tx_event).instrument(span));

    Ok(Handle::new(tx_ctrl, rx_event, task_handle))
}

async fn run(
    config: Config,
    metrics: Metrics,
    mut swarm: swarm::Swarm<Behaviour>,
    mut rx_ctrl: mpsc::Receiver<CtrlMsg>,
    tx_event: mpsc::Sender<Event>,
) {
    if let Err(e) = swarm.listen_on(config.listen_addr.clone()) {
        error!("Error listening on {}: {e}", config.listen_addr);
        return;
    };

    for persistent_peer in config.persistent_peers {
        trace!("Dialing persistent peer: {persistent_peer}");

        match swarm.dial(persistent_peer.clone()) {
            Ok(()) => (),
            Err(e) => error!("Error dialing persistent peer {persistent_peer}: {e}"),
        }
    }

    let mut state = State::default();

    loop {
        let result = tokio::select! {
            event = swarm.select_next_some() => {
                handle_swarm_event(event, &metrics, &mut swarm, &mut state, &tx_event).await
            }

            Some(ctrl) = rx_ctrl.recv() => {
                handle_ctrl_msg(ctrl, &mut swarm).await
            }
        };

        match result {
            ControlFlow::Continue(()) => continue,
            ControlFlow::Break(()) => break,
        }
    }
}

async fn handle_ctrl_msg(msg: CtrlMsg, swarm: &mut swarm::Swarm<Behaviour>) -> ControlFlow<()> {
    match msg {
        CtrlMsg::BroadcastMsg(channel, data) => {
            let msg_size = data.len();

            let result = swarm
                .behaviour_mut()
                .gossipsub
                .publish(channel.topic_hash(), data);

            match result {
                Ok(message_id) => {
                    debug!(
                        %channel,
                        id = %message_id,
                        size = %msg_size,
                        "Broadcasted message"
                    );
                }
                Err(e) => {
                    error!(%channel, "Error broadcasting message: {e}");
                }
            }

            ControlFlow::Continue(())
        }

        CtrlMsg::Shutdown => ControlFlow::Break(()),
    }
}

async fn handle_swarm_event(
    event: SwarmEvent<NetworkEvent>,
    metrics: &Metrics,
    _swarm: &mut swarm::Swarm<Behaviour>,
    state: &mut State,
    tx_event: &mpsc::Sender<Event>,
) -> ControlFlow<()> {
    if let SwarmEvent::Behaviour(NetworkEvent::GossipSub(e)) = &event {
        metrics.record(e);
    } else if let SwarmEvent::Behaviour(NetworkEvent::Identify(e)) = &event {
        metrics.record(e);
    }

    match event {
        SwarmEvent::NewListenAddr { address, .. } => {
            debug!(%address, "Node is listening");

            if let Err(e) = tx_event.send(Event::Listening(address)).await {
                error!("Error sending listening event to handle: {e}");
                return ControlFlow::Break(());
            }
        }

        SwarmEvent::Behaviour(NetworkEvent::Identify(identify::Event::Sent {
            peer_id, ..
        })) => {
            trace!("Sent identity to {peer_id}");
        }

        SwarmEvent::Behaviour(NetworkEvent::Identify(identify::Event::Received {
            peer_id,
            info,
            ..
        })) => {
            trace!(
                "Received identity from {peer_id}: protocol={:?}",
                info.protocol_version
            );

            if info.protocol_version == PROTOCOL {
                trace!(
                    "Peer {peer_id} is using compatible protocol version: {:?}",
                    info.protocol_version
                );

                state.peers.insert(peer_id, info);
            } else {
                trace!(
                    "Peer {peer_id} is using incompatible protocol version: {:?}",
                    info.protocol_version
                );
            }
        }

        SwarmEvent::Behaviour(NetworkEvent::GossipSub(gossipsub::Event::Subscribed {
            peer_id,
            topic,
        })) => {
            if !Channel::has_topic(&topic) {
                trace!("Peer {peer_id} tried to subscribe to unknown topic: {topic}");
                return ControlFlow::Continue(());
            }

            trace!("Peer {peer_id} subscribed to {topic}");
        }

        SwarmEvent::Behaviour(NetworkEvent::GossipSub(gossipsub::Event::Unsubscribed {
            peer_id,
            topic,
        })) => {
            if !Channel::has_topic(&topic) {
                trace!("Peer {peer_id} tried to unsubscribe from unknown topic: {topic}");
                return ControlFlow::Continue(());
            }

            trace!("Peer {peer_id} unsubscribed from {topic}");

            if let Err(e) = tx_event.send(Event::PeerDisconnected(peer_id)).await {
                error!("Error sending peer disconnected event to handle: {e}");
                return ControlFlow::Break(());
            }
        }

        SwarmEvent::Behaviour(NetworkEvent::GossipSub(gossipsub::Event::Message {
            message_id,
            message,
            ..
        })) => {
            let Some(peer_id) = message.source else {
                return ControlFlow::Continue(());
            };

            let Some(channel) = Channel::from_topic_hash(&message.topic) else {
                trace!(
                    "Received message {message_id} from {peer_id} on different channel: {}",
                    message.topic
                );

                return ControlFlow::Continue(());
            };

            trace!(
                "Received message {message_id} from {peer_id} on channel {} of {} bytes",
                channel,
                message.data.len()
            );

            let Ok(network_msg) = NetworkMsg::from_network_bytes(&message.data) else {
                error!("Error decoding message {message_id} from {peer_id}: invalid format");
                return ControlFlow::Continue(());
            };

            let event = Event::Message(channel, peer_id, message_id, network_msg);

            if let Err(e) = tx_event.send(event).await {
                error!("Error sending message to handle: {e}");
                return ControlFlow::Break(());
            }
        }

        SwarmEvent::Behaviour(NetworkEvent::Ping(event)) => {
            match &event.result {
                Ok(rtt) => {
                    trace!("Received pong from {} in {rtt:?}", event.peer);
                }
                Err(e) => {
                    trace!("Received pong from {} with error: {e}", event.peer);
                }
            }

            // Record metric for round-trip time sending a ping and receiving a pong
            metrics.record(&event);
        }

        swarm_event => {
            metrics.record(&swarm_event);
        }
    }

    ControlFlow::Continue(())
}

```
---
### `test/mempool/src/msg.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use prost::bytes::Bytes;
use prost::{Message, Name};
use prost_types::Any;

use malachitebft_proto::{Error as ProtoError, Protobuf};

use crate::types::MempoolTransactionBatch;
use crate::Channel;

#[derive(Clone, Debug, PartialEq)]
pub enum NetworkMsg {
    TransactionBatch(MempoolTransactionBatch),
}

impl NetworkMsg {
    pub fn channel(&self) -> Channel {
        Channel::Mempool
    }

    pub fn from_network_bytes(bytes: &[u8]) -> Result<Self, ProtoError> {
        Protobuf::from_bytes(bytes).map(NetworkMsg::TransactionBatch)
    }

    pub fn to_network_bytes(&self) -> Result<Bytes, ProtoError> {
        match self {
            NetworkMsg::TransactionBatch(batch) => batch.to_bytes(),
        }
    }

    pub fn size_bytes(&self) -> usize {
        match self {
            NetworkMsg::TransactionBatch(batch) => batch.transaction_batch.encoded_len(),
        }
    }
}

impl Protobuf for NetworkMsg {
    type Proto = Any;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        if proto.type_url == crate::proto::MempoolTransactionBatch::type_url() {
            Ok(NetworkMsg::TransactionBatch(MempoolTransactionBatch {
                transaction_batch: proto,
            }))
        } else {
            Err(ProtoError::Other(format!(
                "Unknown type URL: {}",
                proto.type_url
            )))
        }
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        match self {
            NetworkMsg::TransactionBatch(batch) => Ok(batch.transaction_batch.clone()),
        }
    }
}

```
---
### `test/mempool/src/proto.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
//! Protobuf instances for mempool types

#![allow(missing_docs)]

pub use malachitebft_proto::{Error, Protobuf};

include!(concat!(env!("OUT_DIR"), "/malachite.mempool.rs"));

impl Protobuf for crate::types::MempoolTransactionBatch {
    type Proto = MempoolTransactionBatch;

    fn from_proto(proto: Self::Proto) -> Result<Self, Error> {
        Ok(Self::new(proto.transaction_batch.ok_or_else(|| {
            Error::missing_field::<Self::Proto>("content")
        })?))
    }

    fn to_proto(&self) -> Result<Self::Proto, Error> {
        Ok(MempoolTransactionBatch {
            transaction_batch: Some(self.transaction_batch.clone()),
        })
    }
}

```
---
### `test/mempool/src/types.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use core::fmt::Debug;

/// Mempool transaction batch
#[derive(Clone, Debug, PartialEq)]
pub struct MempoolTransactionBatch {
    /// The batch of transactions
    pub transaction_batch: prost_types::Any,
    // May add more fields to this structure
}

impl MempoolTransactionBatch {
    /// Create a new transaction batch
    pub fn new(transaction_batch: prost_types::Any) -> Self {
        Self { transaction_batch }
    }
}

```
---
### `test/src/address.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use core::fmt;
use serde::{Deserialize, Serialize};

use malachitebft_proto::{Error as ProtoError, Protobuf};

use crate::signing::PublicKey;
use crate::{proto, Hashable};

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct Address(
    #[serde(
        serialize_with = "hex::serde::serialize_upper",
        deserialize_with = "hex::serde::deserialize"
    )]
    [u8; Self::LENGTH],
);

impl Address {
    const LENGTH: usize = 20;

    #[cfg_attr(coverage_nightly, coverage(off))]
    pub const fn new(value: [u8; Self::LENGTH]) -> Self {
        Self(value)
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn from_public_key(public_key: &PublicKey) -> Self {
        let hash = public_key.hash();
        let mut address = [0; Self::LENGTH];
        address.copy_from_slice(&hash[..Self::LENGTH]);
        Self(address)
    }

    pub fn into_inner(self) -> [u8; Self::LENGTH] {
        self.0
    }
}

impl fmt::Display for Address {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for byte in self.0.iter() {
            write!(f, "{:02X}", byte)?;
        }
        Ok(())
    }
}

impl fmt::Debug for Address {
    #[cfg_attr(coverage_nightly, coverage(off))]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Address({})", self)
    }
}

impl malachitebft_core_types::Address for Address {}

impl Protobuf for Address {
    type Proto = proto::Address;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        if proto.value.len() != Self::LENGTH {
            return Err(ProtoError::Other(format!(
                "Invalid address length: expected {}, got {}",
                Self::LENGTH,
                proto.value.len()
            )));
        }

        let mut address = [0; Self::LENGTH];
        address.copy_from_slice(&proto.value);
        Ok(Self(address))
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(proto::Address {
            value: self.0.to_vec().into(),
        })
    }
}

```
---
### `test/src/codec/json/mod.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use bytes::Bytes;
use malachitebft_codec::Codec;

use malachitebft_core_consensus::SignedConsensusMsg;
use malachitebft_engine::util::streaming::StreamMessage;
use malachitebft_sync::{Request, Response, Status};

mod raw;
use raw::{RawRequest, RawResponse, RawSignedConsensusMsg, RawStatus, RawStreamMessage};

use crate::{ProposalPart, TestContext, Value};

#[derive(Copy, Clone, Debug)]
pub struct JsonCodec;

impl Codec<Value> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<Value, Self::Error> {
        serde_json::from_slice(&bytes)
    }

    fn encode(&self, msg: &Value) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&msg).map(Bytes::from)
    }
}

impl Codec<ProposalPart> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<ProposalPart, Self::Error> {
        serde_json::from_slice(&bytes)
    }

    fn encode(&self, msg: &ProposalPart) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&msg).map(Bytes::from)
    }
}

impl Codec<SignedConsensusMsg<TestContext>> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<SignedConsensusMsg<TestContext>, Self::Error> {
        serde_json::from_slice::<RawSignedConsensusMsg>(&bytes).map(Into::into)
    }

    fn encode(&self, msg: &SignedConsensusMsg<TestContext>) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&RawSignedConsensusMsg::from(msg.clone())).map(Bytes::from)
    }
}

impl Codec<StreamMessage<ProposalPart>> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<StreamMessage<ProposalPart>, Self::Error> {
        serde_json::from_slice::<RawStreamMessage>(&bytes).map(Into::into)
    }

    fn encode(&self, msg: &StreamMessage<ProposalPart>) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&RawStreamMessage::from(msg.clone())).map(Bytes::from)
    }
}

impl Codec<Status<TestContext>> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<Status<TestContext>, Self::Error> {
        serde_json::from_slice::<RawStatus>(&bytes).map(Into::into)
    }

    fn encode(&self, msg: &Status<TestContext>) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&RawStatus::from(msg.clone())).map(Bytes::from)
    }
}

impl Codec<Request<TestContext>> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<Request<TestContext>, Self::Error> {
        serde_json::from_slice::<RawRequest>(&bytes).map(Into::into)
    }

    fn encode(&self, msg: &Request<TestContext>) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&RawRequest::from(msg.clone())).map(Bytes::from)
    }
}

impl Codec<Response<TestContext>> for JsonCodec {
    type Error = serde_json::Error;

    fn decode(&self, bytes: Bytes) -> Result<Response<TestContext>, Self::Error> {
        serde_json::from_slice::<RawResponse>(&bytes).map(Into::into)
    }

    fn encode(&self, msg: &Response<TestContext>) -> Result<Bytes, Self::Error> {
        serde_json::to_vec(&RawResponse::from(msg.clone())).map(Bytes::from)
    }
}

```
---
### `test/src/codec/json/raw.rs`
*2025-05-18 23:58:49 | 10 KB*
```rust
use crate::{Address, Height, Proposal, ProposalPart, RoundDef, TestContext, ValueId, Vote};
use bytes::Bytes;
use ed25519_consensus::Signature;
use malachitebft_core_consensus::SignedConsensusMsg;
use malachitebft_core_types::{
    AggregatedSignature, CommitCertificate, CommitSignature, Extension, Round, SignedExtension,
    SignedProposal, SignedVote,
};
use malachitebft_engine::util::streaming::{StreamContent, StreamMessage};
use malachitebft_proto::Protobuf;
use malachitebft_sync::{
    DecidedValue, PeerId, Request, Response, Status, ValueRequest, ValueResponse,
};
use serde::{Deserialize, Serialize};

/// todo
#[derive(Serialize, Deserialize)]
pub struct RawSignedMessage {
    message: Bytes,
    signature: Signature,
}

#[derive(Serialize, Deserialize)]
pub enum RawSignedConsensusMsg {
    Vote(RawSignedMessage),
    Proposal(RawSignedMessage),
}

impl From<SignedConsensusMsg<TestContext>> for RawSignedConsensusMsg {
    fn from(value: SignedConsensusMsg<TestContext>) -> Self {
        match value {
            SignedConsensusMsg::Vote(vote) => Self::Vote(RawSignedMessage {
                message: vote.message.to_bytes(),
                signature: *vote.signature.inner(),
            }),
            SignedConsensusMsg::Proposal(proposal) => Self::Proposal(RawSignedMessage {
                message: proposal.message.to_bytes(),
                signature: *proposal.signature.inner(),
            }),
        }
    }
}

impl From<RawSignedConsensusMsg> for SignedConsensusMsg<TestContext> {
    fn from(value: RawSignedConsensusMsg) -> Self {
        match value {
            RawSignedConsensusMsg::Vote(vote) => SignedConsensusMsg::Vote(SignedVote {
                message: Vote::from_bytes(&vote.message).unwrap(),
                signature: vote.signature.into(),
            }),
            RawSignedConsensusMsg::Proposal(proposal) => {
                SignedConsensusMsg::Proposal(SignedProposal {
                    message: Proposal::from_bytes(&proposal.message).unwrap(),
                    signature: proposal.signature.into(),
                })
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct RawStreamMessage {
    pub stream_id: u64,
    pub sequence: u64,
    pub content: RawStreamContent,
}

#[derive(Serialize, Deserialize)]
pub enum RawStreamContent {
    Data(ProposalPart),
    Fin(bool),
}

impl From<StreamMessage<ProposalPart>> for RawStreamMessage {
    fn from(value: StreamMessage<ProposalPart>) -> Self {
        Self {
            stream_id: value.stream_id,
            sequence: value.sequence,
            content: match value.content {
                StreamContent::Data(proposal_part) => RawStreamContent::Data(proposal_part),
                StreamContent::Fin(fin) => RawStreamContent::Fin(fin),
            },
        }
    }
}

impl From<RawStreamMessage> for StreamMessage<ProposalPart> {
    fn from(value: RawStreamMessage) -> Self {
        Self {
            stream_id: value.stream_id,
            sequence: value.sequence,
            content: match value.content {
                RawStreamContent::Data(proposal_part) => StreamContent::Data(proposal_part),
                RawStreamContent::Fin(fin) => StreamContent::Fin(fin),
            },
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct RawStatus {
    pub peer_id: Vec<u8>,
    pub height: Height,
    pub history_min_height: Height,
}

impl From<Status<TestContext>> for RawStatus {
    fn from(value: Status<TestContext>) -> Self {
        Self {
            peer_id: value.peer_id.to_bytes(),
            height: value.height,
            history_min_height: value.history_min_height,
        }
    }
}

impl From<RawStatus> for Status<TestContext> {
    fn from(value: RawStatus) -> Self {
        Self {
            peer_id: PeerId::from_bytes(&value.peer_id).unwrap(),
            height: value.height,
            history_min_height: value.history_min_height,
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct ValueRawRequest {
    pub height: Height,
}

#[derive(Serialize, Deserialize)]
pub enum RawRequest {
    SyncRequest(ValueRawRequest),
}

impl From<Request<TestContext>> for RawRequest {
    fn from(value: Request<TestContext>) -> Self {
        match value {
            Request::ValueRequest(block_request) => Self::SyncRequest(ValueRawRequest {
                height: block_request.height,
            }),
        }
    }
}

impl From<RawRequest> for Request<TestContext> {
    fn from(value: RawRequest) -> Self {
        match value {
            RawRequest::SyncRequest(block_raw_request) => Self::ValueRequest(ValueRequest {
                height: block_raw_request.height,
            }),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct RawExtension {
    pub data: Bytes,
}

#[derive(Serialize, Deserialize)]
pub struct RawSignedExtension {
    pub extension: RawExtension,
    pub signature: Signature,
}

#[derive(Serialize, Deserialize)]
pub struct RawCommitSignature {
    pub address: Address,
    pub signature: Signature,
    pub extension: Option<RawSignedExtension>,
}

#[derive(Serialize, Deserialize)]
pub struct RawAggregatedSignature {
    pub signatures: Vec<RawCommitSignature>,
}

#[derive(Serialize, Deserialize)]
pub struct RawCommitCertificate {
    pub height: Height,
    #[serde(with = "RoundDef")]
    pub round: Round,
    pub value_id: ValueId,
    pub aggregated_signature: RawAggregatedSignature,
}

#[derive(Serialize, Deserialize)]
pub struct RawSyncedValue {
    pub value_bytes: Bytes,
    pub certificate: RawCommitCertificate,
}

#[derive(Serialize, Deserialize)]
pub struct ValueRawResponse {
    pub height: Height,
    pub block: Option<RawSyncedValue>,
}

impl From<ValueResponse<TestContext>> for ValueRawResponse {
    fn from(value: ValueResponse<TestContext>) -> Self {
        Self {
            height: value.height,
            block: value.value.map(|block| RawSyncedValue {
                value_bytes: block.value_bytes,
                certificate: RawCommitCertificate {
                    height: block.certificate.height,
                    round: block.certificate.round,
                    value_id: block.certificate.value_id,
                    aggregated_signature: RawAggregatedSignature {
                        signatures: block
                            .certificate
                            .aggregated_signature
                            .signatures
                            .iter()
                            .map(|sig| RawCommitSignature {
                                address: sig.address,
                                signature: *sig.signature.inner(),
                                extension: sig.extension.as_ref().map(|ext| RawSignedExtension {
                                    extension: RawExtension {
                                        data: ext.message.data.clone(),
                                    },
                                    signature: *ext.signature.inner(),
                                }),
                            })
                            .collect(),
                    },
                },
            }),
        }
    }
}

impl From<ValueRawResponse> for ValueResponse<TestContext> {
    fn from(value: ValueRawResponse) -> Self {
        Self {
            height: value.height,
            value: value.block.map(|block| DecidedValue {
                value_bytes: block.value_bytes,
                certificate: CommitCertificate {
                    height: block.certificate.height,
                    round: block.certificate.round,
                    value_id: block.certificate.value_id,
                    aggregated_signature: AggregatedSignature {
                        signatures: block
                            .certificate
                            .aggregated_signature
                            .signatures
                            .iter()
                            .map(|sig| CommitSignature {
                                address: sig.address,
                                signature: sig.signature.into(),
                                extension: sig.extension.as_ref().map(|ext| SignedExtension {
                                    message: Extension {
                                        data: ext.extension.data.clone(),
                                    },
                                    signature: ext.signature.into(),
                                }),
                            })
                            .collect(),
                    },
                },
            }),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub enum RawResponse {
    ValueResponse(ValueRawResponse),
}

impl From<Response<TestContext>> for RawResponse {
    fn from(value: Response<TestContext>) -> Self {
        match value {
            Response::ValueResponse(block_response) => Self::ValueResponse(block_response.into()),
        }
    }
}

impl From<RawResponse> for Response<TestContext> {
    fn from(value: RawResponse) -> Self {
        match value {
            RawResponse::ValueResponse(block_raw_response) => {
                Self::ValueResponse(block_raw_response.into())
            }
        }
    }
}

```
---
### `test/src/codec/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
// pub mod json;
pub mod proto;

```
---
### `test/src/codec/proto/mod.rs`
*2025-05-18 23:58:49 | 24 KB*
```rust
use bytes::Bytes;
use prost::Message;

use malachitebft_app::engine::util::streaming::{StreamContent, StreamId, StreamMessage};
use malachitebft_codec::Codec;
use malachitebft_core_consensus::{LivenessMsg, ProposedValue, SignedConsensusMsg};
use malachitebft_core_types::{
    CommitCertificate, CommitSignature, NilOrVal, PolkaCertificate, PolkaSignature, Round,
    RoundCertificate, RoundSignature, SignedExtension, SignedProposal, SignedVote, Validity,
};
use malachitebft_proto::{Error as ProtoError, Protobuf};
use malachitebft_signing_ed25519::Signature;
use malachitebft_sync::{self as sync, PeerId};

use crate::{decode_votetype, encode_votetype, proto};
use crate::{Address, Height, Proposal, ProposalPart, TestContext, Value, ValueId, Vote};

#[derive(Copy, Clone, Debug)]
pub struct ProtobufCodec;

impl Codec<Value> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<Value, Self::Error> {
        Protobuf::from_bytes(&bytes)
    }

    fn encode(&self, msg: &Value) -> Result<Bytes, Self::Error> {
        Protobuf::to_bytes(msg)
    }
}

impl Codec<ProposalPart> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<ProposalPart, Self::Error> {
        Protobuf::from_bytes(&bytes)
    }

    fn encode(&self, msg: &ProposalPart) -> Result<Bytes, Self::Error> {
        Protobuf::to_bytes(msg)
    }
}

impl Codec<Signature> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<Signature, Self::Error> {
        let proto = proto::Signature::decode(bytes.as_ref())?;
        decode_signature(proto)
    }

    fn encode(&self, msg: &Signature) -> Result<Bytes, Self::Error> {
        Ok(Bytes::from(
            proto::Signature {
                bytes: Bytes::copy_from_slice(msg.to_bytes().as_ref()),
            }
            .encode_to_vec(),
        ))
    }
}

impl Codec<SignedConsensusMsg<TestContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<SignedConsensusMsg<TestContext>, Self::Error> {
        let proto = proto::SignedMessage::decode(bytes.as_ref())?;

        let signature = proto
            .signature
            .ok_or_else(|| ProtoError::missing_field::<proto::SignedMessage>("signature"))
            .and_then(decode_signature)?;

        let proto_message = proto
            .message
            .ok_or_else(|| ProtoError::missing_field::<proto::SignedMessage>("message"))?;

        match proto_message {
            proto::signed_message::Message::Proposal(proto) => {
                let proposal = Proposal::from_proto(proto)?;
                Ok(SignedConsensusMsg::Proposal(SignedProposal::new(
                    proposal, signature,
                )))
            }
            proto::signed_message::Message::Vote(vote) => {
                let vote = Vote::from_proto(vote)?;
                Ok(SignedConsensusMsg::Vote(SignedVote::new(vote, signature)))
            }
        }
    }

    fn encode(&self, msg: &SignedConsensusMsg<TestContext>) -> Result<Bytes, Self::Error> {
        match msg {
            SignedConsensusMsg::Vote(vote) => {
                let proto = proto::SignedMessage {
                    message: Some(proto::signed_message::Message::Vote(
                        vote.message.to_proto()?,
                    )),
                    signature: Some(encode_signature(&vote.signature)),
                };
                Ok(Bytes::from(proto.encode_to_vec()))
            }
            SignedConsensusMsg::Proposal(proposal) => {
                let proto = proto::SignedMessage {
                    message: Some(proto::signed_message::Message::Proposal(
                        proposal.message.to_proto()?,
                    )),
                    signature: Some(encode_signature(&proposal.signature)),
                };
                Ok(Bytes::from(proto.encode_to_vec()))
            }
        }
    }
}

pub fn encode_round_certificate(
    certificate: &RoundCertificate<TestContext>,
) -> Result<proto::RoundCertificate, ProtoError> {
    Ok(proto::RoundCertificate {
        height: certificate.height.as_u64(),
        round: certificate.round.as_u32().expect("round should not be nil"),
        signatures: certificate
            .round_signatures
            .iter()
            .map(|sig| -> Result<proto::RoundSignature, ProtoError> {
                let value_id = match sig.value_id {
                    NilOrVal::Nil => None,
                    NilOrVal::Val(value_id) => Some(value_id.to_proto()?),
                };
                Ok(proto::RoundSignature {
                    vote_type: encode_votetype(sig.vote_type).into(),
                    validator_address: Some(sig.address.to_proto()?),
                    signature: Some(encode_signature(&sig.signature)),
                    value_id,
                })
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

pub fn decode_round_certificate(
    certificate: proto::RoundCertificate,
) -> Result<RoundCertificate<TestContext>, ProtoError> {
    Ok(RoundCertificate {
        height: Height::new(certificate.height),
        round: Round::new(certificate.round),
        round_signatures: certificate
            .signatures
            .into_iter()
            .map(|sig| -> Result<RoundSignature<TestContext>, ProtoError> {
                let vote_type = decode_votetype(sig.vote_type());
                let address = sig.validator_address.ok_or_else(|| {
                    ProtoError::missing_field::<proto::RoundCertificate>("validator_address")
                })?;

                let signature = sig.signature.ok_or_else(|| {
                    ProtoError::missing_field::<proto::RoundCertificate>("signature")
                })?;

                let value_id = match sig.value_id {
                    None => NilOrVal::Nil,
                    Some(value_id) => NilOrVal::Val(ValueId::from_proto(value_id)?),
                };

                let signature = decode_signature(signature)?;
                let address = Address::from_proto(address)?;
                Ok(RoundSignature::new(vote_type, value_id, address, signature))
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

impl Codec<LivenessMsg<TestContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<LivenessMsg<TestContext>, Self::Error> {
        let msg = proto::LivenessMessage::decode(bytes.as_ref())?;
        match msg.message {
            Some(proto::liveness_message::Message::Vote(vote)) => {
                Ok(LivenessMsg::Vote(decode_vote(vote)?))
            }
            Some(proto::liveness_message::Message::PolkaCertificate(cert)) => Ok(
                LivenessMsg::PolkaCertificate(decode_polka_certificate(cert)?),
            ),
            Some(proto::liveness_message::Message::RoundCertificate(cert)) => Ok(
                LivenessMsg::SkipRoundCertificate(decode_round_certificate(cert)?),
            ),
            None => Err(ProtoError::missing_field::<proto::LivenessMessage>(
                "message",
            )),
        }
    }

    fn encode(&self, msg: &LivenessMsg<TestContext>) -> Result<Bytes, Self::Error> {
        match msg {
            LivenessMsg::Vote(vote) => {
                let message = encode_vote(vote)?;
                Ok(Bytes::from(
                    proto::LivenessMessage {
                        message: Some(proto::liveness_message::Message::Vote(message)),
                    }
                    .encode_to_vec(),
                ))
            }
            LivenessMsg::PolkaCertificate(cert) => {
                let message = encode_polka_certificate(cert)?;
                Ok(Bytes::from(
                    proto::LivenessMessage {
                        message: Some(proto::liveness_message::Message::PolkaCertificate(message)),
                    }
                    .encode_to_vec(),
                ))
            }
            LivenessMsg::SkipRoundCertificate(cert) => {
                let message = encode_round_certificate(cert)?;
                Ok(Bytes::from(
                    proto::LivenessMessage {
                        message: Some(proto::liveness_message::Message::RoundCertificate(message)),
                    }
                    .encode_to_vec(),
                ))
            }
        }
    }
}

impl Codec<StreamMessage<ProposalPart>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<StreamMessage<ProposalPart>, Self::Error> {
        let proto = proto::StreamMessage::decode(bytes.as_ref())?;

        let proto_content = proto
            .content
            .ok_or_else(|| ProtoError::missing_field::<proto::StreamMessage>("content"))?;

        let content = match proto_content {
            proto::stream_message::Content::Data(data) => {
                StreamContent::Data(ProposalPart::from_bytes(&data)?)
            }
            proto::stream_message::Content::Fin(_) => StreamContent::Fin,
        };

        Ok(StreamMessage {
            stream_id: StreamId::new(proto.stream_id),
            sequence: proto.sequence,
            content,
        })
    }

    fn encode(&self, msg: &StreamMessage<ProposalPart>) -> Result<Bytes, Self::Error> {
        let proto = proto::StreamMessage {
            stream_id: msg.stream_id.to_bytes(),
            sequence: msg.sequence,
            content: match &msg.content {
                StreamContent::Data(data) => {
                    Some(proto::stream_message::Content::Data(data.to_bytes()?))
                }
                StreamContent::Fin => Some(proto::stream_message::Content::Fin(true)),
            },
        };

        Ok(Bytes::from(proto.encode_to_vec()))
    }
}

impl Codec<ProposedValue<TestContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<ProposedValue<TestContext>, Self::Error> {
        let proto = proto::ProposedValue::decode(bytes.as_ref())?;

        let proposer = proto
            .proposer
            .ok_or_else(|| ProtoError::missing_field::<proto::ProposedValue>("proposer"))?;

        let value = proto
            .value
            .ok_or_else(|| ProtoError::missing_field::<proto::ProposedValue>("value"))?;

        Ok(ProposedValue {
            height: Height::new(proto.height),
            round: Round::new(proto.round),
            valid_round: proto.valid_round.map(Round::new).unwrap_or(Round::Nil),
            proposer: Address::from_proto(proposer)?,
            value: Value::from_proto(value)?,
            validity: Validity::from_bool(proto.validity),
        })
    }

    fn encode(&self, msg: &ProposedValue<TestContext>) -> Result<Bytes, Self::Error> {
        let proto = proto::ProposedValue {
            height: msg.height.as_u64(),
            round: msg.round.as_u32().unwrap(),
            valid_round: msg.valid_round.as_u32(),
            proposer: Some(msg.proposer.to_proto()?),
            value: Some(msg.value.to_proto()?),
            validity: msg.validity.to_bool(),
        };

        Ok(Bytes::from(proto.encode_to_vec()))
    }
}

impl Codec<sync::Status<TestContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::Status<TestContext>, Self::Error> {
        let proto = proto::Status::decode(bytes.as_ref())?;

        let proto_peer_id = proto
            .peer_id
            .ok_or_else(|| ProtoError::missing_field::<proto::Status>("peer_id"))?;

        Ok(sync::Status {
            peer_id: PeerId::from_bytes(proto_peer_id.id.as_ref()).unwrap(),
            tip_height: Height::new(proto.height),
            history_min_height: Height::new(proto.earliest_height),
        })
    }

    fn encode(&self, msg: &sync::Status<TestContext>) -> Result<Bytes, Self::Error> {
        let proto = proto::Status {
            peer_id: Some(proto::PeerId {
                id: Bytes::from(msg.peer_id.to_bytes()),
            }),
            height: msg.tip_height.as_u64(),
            earliest_height: msg.history_min_height.as_u64(),
        };

        Ok(Bytes::from(proto.encode_to_vec()))
    }
}

impl Codec<sync::Request<TestContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::Request<TestContext>, Self::Error> {
        let proto = proto::SyncRequest::decode(bytes.as_ref())?;
        let request = proto
            .request
            .ok_or_else(|| ProtoError::missing_field::<proto::SyncRequest>("request"))?;

        match request {
            proto::sync_request::Request::ValueRequest(req) => Ok(sync::Request::ValueRequest(
                sync::ValueRequest::new(Height::new(req.height)),
            )),
        }
    }

    fn encode(&self, msg: &sync::Request<TestContext>) -> Result<Bytes, Self::Error> {
        let proto = match msg {
            sync::Request::ValueRequest(req) => proto::SyncRequest {
                request: Some(proto::sync_request::Request::ValueRequest(
                    proto::ValueRequest {
                        height: req.height.as_u64(),
                    },
                )),
            },
        };

        Ok(Bytes::from(proto.encode_to_vec()))
    }
}

impl Codec<sync::Response<TestContext>> for ProtobufCodec {
    type Error = ProtoError;

    fn decode(&self, bytes: Bytes) -> Result<sync::Response<TestContext>, Self::Error> {
        decode_sync_response(proto::SyncResponse::decode(bytes)?)
    }

    fn encode(&self, response: &sync::Response<TestContext>) -> Result<Bytes, Self::Error> {
        encode_sync_response(response).map(|proto| proto.encode_to_vec().into())
    }
}

pub fn decode_sync_response(
    proto_response: proto::SyncResponse,
) -> Result<sync::Response<TestContext>, ProtoError> {
    let response = proto_response
        .response
        .ok_or_else(|| ProtoError::missing_field::<proto::SyncResponse>("messages"))?;

    let response = match response {
        proto::sync_response::Response::ValueResponse(value_response) => {
            sync::Response::ValueResponse(sync::ValueResponse::new(
                Height::new(value_response.height),
                value_response.value.map(decode_synced_value).transpose()?,
            ))
        }
    };

    Ok(response)
}

pub fn encode_sync_response(
    response: &sync::Response<TestContext>,
) -> Result<proto::SyncResponse, ProtoError> {
    let proto = match response {
        sync::Response::ValueResponse(value_response) => proto::SyncResponse {
            response: Some(proto::sync_response::Response::ValueResponse(
                proto::ValueResponse {
                    height: value_response.height.as_u64(),
                    value: value_response
                        .value
                        .as_ref()
                        .map(encode_synced_value)
                        .transpose()?,
                },
            )),
        },
    };

    Ok(proto)
}

pub fn encode_synced_value(
    synced_value: &sync::RawDecidedValue<TestContext>,
) -> Result<proto::SyncedValue, ProtoError> {
    Ok(proto::SyncedValue {
        value_bytes: synced_value.value_bytes.clone(),
        certificate: Some(encode_commit_certificate(&synced_value.certificate)?),
    })
}

pub fn decode_synced_value(
    proto: proto::SyncedValue,
) -> Result<sync::RawDecidedValue<TestContext>, ProtoError> {
    let certificate = proto
        .certificate
        .ok_or_else(|| ProtoError::missing_field::<proto::SyncedValue>("certificate"))?;

    Ok(sync::RawDecidedValue {
        value_bytes: proto.value_bytes,
        certificate: decode_commit_certificate(certificate)?,
    })
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub(crate) fn encode_polka_certificate(
    polka_certificate: &PolkaCertificate<TestContext>,
) -> Result<proto::PolkaCertificate, ProtoError> {
    Ok(proto::PolkaCertificate {
        height: polka_certificate.height.as_u64(),
        round: polka_certificate
            .round
            .as_u32()
            .expect("round should not be nil"),
        value_id: Some(polka_certificate.value_id.to_proto()?),
        signatures: polka_certificate
            .polka_signatures
            .iter()
            .map(|sig| -> Result<proto::PolkaSignature, ProtoError> {
                let address = sig.address.to_proto()?;
                let signature = encode_signature(&sig.signature);
                Ok(proto::PolkaSignature {
                    validator_address: Some(address),
                    signature: Some(signature),
                })
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

// NOTE: Will be used again in #997
#[allow(dead_code)]
pub(crate) fn decode_polka_certificate(
    certificate: proto::PolkaCertificate,
) -> Result<PolkaCertificate<TestContext>, ProtoError> {
    let value_id = certificate
        .value_id
        .ok_or_else(|| ProtoError::missing_field::<proto::PolkaCertificate>("value_id"))
        .and_then(ValueId::from_proto)?;

    Ok(PolkaCertificate {
        height: Height::new(certificate.height),
        round: Round::new(certificate.round),
        value_id,
        polka_signatures: certificate
            .signatures
            .into_iter()
            .map(|sig| -> Result<PolkaSignature<TestContext>, ProtoError> {
                let address = sig.validator_address.ok_or_else(|| {
                    ProtoError::missing_field::<proto::PolkaCertificate>("validator_address")
                })?;
                let signature = sig.signature.ok_or_else(|| {
                    ProtoError::missing_field::<proto::PolkaCertificate>("signature")
                })?;
                let signature = decode_signature(signature)?;
                let address = Address::from_proto(address)?;
                Ok(PolkaSignature::new(address, signature))
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

pub fn decode_commit_certificate(
    certificate: proto::CommitCertificate,
) -> Result<CommitCertificate<TestContext>, ProtoError> {
    let value_id = certificate
        .value_id
        .ok_or_else(|| ProtoError::missing_field::<proto::CommitCertificate>("value_id"))
        .and_then(ValueId::from_proto)?;

    let commit_signatures = certificate
        .signatures
        .into_iter()
        .map(|sig| -> Result<CommitSignature<TestContext>, ProtoError> {
            let address = sig.validator_address.ok_or_else(|| {
                ProtoError::missing_field::<proto::CommitCertificate>("validator_address")
            })?;
            let signature = sig.signature.ok_or_else(|| {
                ProtoError::missing_field::<proto::CommitCertificate>("signature")
            })?;
            let signature = decode_signature(signature)?;
            let address = Address::from_proto(address)?;
            Ok(CommitSignature::new(address, signature))
        })
        .collect::<Result<Vec<_>, _>>()?;

    let certificate = CommitCertificate {
        height: Height::new(certificate.height),
        round: Round::new(certificate.round),
        value_id,
        commit_signatures,
    };

    Ok(certificate)
}

pub fn encode_commit_certificate(
    certificate: &CommitCertificate<TestContext>,
) -> Result<proto::CommitCertificate, ProtoError> {
    Ok(proto::CommitCertificate {
        height: certificate.height.as_u64(),
        round: certificate.round.as_u32().expect("round should not be nil"),
        value_id: Some(certificate.value_id.to_proto()?),
        signatures: certificate
            .commit_signatures
            .iter()
            .map(|sig| -> Result<proto::CommitSignature, ProtoError> {
                let address = sig.address.to_proto()?;
                let signature = encode_signature(&sig.signature);
                Ok(proto::CommitSignature {
                    validator_address: Some(address),
                    signature: Some(signature),
                })
            })
            .collect::<Result<Vec<_>, _>>()?,
    })
}

pub fn decode_extension(ext: proto::Extension) -> Result<SignedExtension<TestContext>, ProtoError> {
    let signature = ext
        .signature
        .ok_or_else(|| ProtoError::missing_field::<proto::Extension>("signature"))
        .and_then(decode_signature)?;

    Ok(SignedExtension::new(ext.data, signature))
}

pub fn encode_extension(
    ext: &SignedExtension<TestContext>,
) -> Result<proto::Extension, ProtoError> {
    Ok(proto::Extension {
        data: ext.message.clone(),
        signature: Some(encode_signature(&ext.signature)),
    })
}

pub fn encode_vote(vote: &SignedVote<TestContext>) -> Result<proto::SignedMessage, ProtoError> {
    Ok(proto::SignedMessage {
        message: Some(proto::signed_message::Message::Vote(
            vote.message.to_proto()?,
        )),
        signature: Some(encode_signature(&vote.signature)),
    })
}

pub fn decode_vote(msg: proto::SignedMessage) -> Result<SignedVote<TestContext>, ProtoError> {
    let signature = msg
        .signature
        .ok_or_else(|| ProtoError::missing_field::<proto::SignedMessage>("signature"))?;

    let vote = match msg.message {
        Some(proto::signed_message::Message::Vote(v)) => Ok(v),
        _ => Err(ProtoError::Other(
            "Invalid message type: not a vote".to_string(),
        )),
    }?;

    let signature = decode_signature(signature)?;
    let vote = Vote::from_proto(vote)?;
    Ok(SignedVote::new(vote, signature))
}

pub fn encode_signature(signature: &Signature) -> proto::Signature {
    proto::Signature {
        bytes: Bytes::copy_from_slice(signature.to_bytes().as_ref()),
    }
}

pub fn decode_signature(signature: proto::Signature) -> Result<Signature, ProtoError> {
    let bytes = <[u8; 64]>::try_from(signature.bytes.as_ref())
        .map_err(|_| ProtoError::Other("Invalid signature length".to_string()))?;
    Ok(Signature::from_bytes(bytes))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Address, Height};
    use malachitebft_core_types::{NilOrVal, Round, RoundSignature, VoteType};
    use malachitebft_signing_ed25519::Signature;

    #[test]
    fn test_round_certificate_encode_decode() {
        // Create test data
        let height = Height::new(1);
        let round = Round::new(2);
        let address = Address::new([1; 20]);
        let signature = Signature::from_bytes([2; 64]);

        // Create a round signature
        let round_sig = RoundSignature::new(VoteType::Prevote, NilOrVal::Nil, address, signature);

        // Create the round certificate
        let certificate = RoundCertificate {
            height,
            round,
            round_signatures: vec![round_sig],
        };

        // Encode the certificate
        let encoded = encode_round_certificate(&certificate).unwrap();

        // Decode the certificate
        let decoded = decode_round_certificate(encoded).unwrap();

        // Verify the decoded data matches the original
        assert_eq!(decoded.height, certificate.height);
        assert_eq!(decoded.round, certificate.round);
        assert_eq!(
            decoded.round_signatures.len(),
            certificate.round_signatures.len()
        );

        // Verify the signature details
        let decoded_sig = &decoded.round_signatures[0];
        let original_sig = &certificate.round_signatures[0];
        assert_eq!(decoded_sig.vote_type, original_sig.vote_type);
        assert_eq!(decoded_sig.value_id, original_sig.value_id);
        assert_eq!(decoded_sig.address, original_sig.address);
        assert_eq!(
            decoded_sig.signature.to_bytes(),
            original_sig.signature.to_bytes()
        );
    }
}

```
---
### `test/src/context.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::sync::Arc;

use bytes::Bytes;

use malachitebft_core_types::{Context, NilOrVal, Round, ValidatorSet as _};

use crate::address::*;
use crate::height::*;
use crate::middleware;
use crate::middleware::Middleware;
use crate::proposal::*;
use crate::proposal_part::*;
use crate::signing::*;
use crate::validator_set::*;
use crate::value::*;
use crate::vote::*;

#[derive(Clone, Debug)]
pub struct TestContext {
    middleware: Arc<dyn Middleware>,
}

impl Default for TestContext {
    fn default() -> Self {
        Self::new()
    }
}

impl TestContext {
    pub fn new() -> Self {
        Self::with_middleware(Arc::new(middleware::DefaultMiddleware))
    }

    pub fn with_middleware(middleware: Arc<dyn Middleware>) -> Self {
        Self { middleware }
    }

    pub fn middleware(&self) -> &Arc<dyn Middleware> {
        &self.middleware
    }

    pub fn select_proposer<'a>(
        &self,
        validator_set: &'a ValidatorSet,
        height: Height,
        round: Round,
    ) -> &'a Validator {
        assert!(validator_set.count() > 0);
        assert!(round != Round::Nil && round.as_i64() >= 0);

        let proposer_index = {
            let height = height.as_u64() as usize;
            let round = round.as_i64() as usize;

            (height - 1 + round) % validator_set.count()
        };

        validator_set
            .get_by_index(proposer_index)
            .expect("proposer_index is valid")
    }
}

impl Context for TestContext {
    type Address = Address;
    type ProposalPart = ProposalPart;
    type Height = Height;
    type Proposal = Proposal;
    type ValidatorSet = ValidatorSet;
    type Validator = Validator;
    type Value = Value;
    type Vote = Vote;
    type Extension = Bytes;
    type SigningScheme = Ed25519;

    fn select_proposer<'a>(
        &self,
        validator_set: &'a Self::ValidatorSet,
        height: Self::Height,
        round: Round,
    ) -> &'a Self::Validator {
        self.select_proposer(validator_set, height, round)
    }

    fn new_proposal(
        &self,
        height: Height,
        round: Round,
        value: Value,
        pol_round: Round,
        address: Address,
    ) -> Proposal {
        self.middleware
            .new_proposal(self, height, round, value, pol_round, address)
    }

    fn new_prevote(
        &self,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        address: Address,
    ) -> Vote {
        self.middleware
            .new_prevote(self, height, round, value_id, address)
    }

    fn new_precommit(
        &self,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        address: Address,
    ) -> Vote {
        self.middleware
            .new_precommit(self, height, round, value_id, address)
    }
}

```
---
### `test/src/genesis.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use crate::ValidatorSet;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Genesis {
    pub validator_set: ValidatorSet,
}

```
---
### `test/src/height.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use core::fmt;
use malachitebft_proto::{Error as ProtoError, Protobuf};
use serde::{Deserialize, Serialize};

/// A blockchain height
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Height(u64);

impl Height {
    pub const fn new(height: u64) -> Self {
        Self(height)
    }

    pub const fn as_u64(&self) -> u64 {
        self.0
    }

    pub fn increment(&self) -> Self {
        Self(self.0 + 1)
    }

    pub fn decrement(&self) -> Option<Self> {
        self.0.checked_sub(1).map(Self)
    }
}

impl Default for Height {
    fn default() -> Self {
        malachitebft_core_types::Height::ZERO
    }
}

impl fmt::Display for Height {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl fmt::Debug for Height {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Height({})", self.0)
    }
}

impl malachitebft_core_types::Height for Height {
    const ZERO: Self = Self(0);
    const INITIAL: Self = Self(1);

    fn increment_by(&self, n: u64) -> Self {
        Self(self.0 + n)
    }

    fn decrement_by(&self, n: u64) -> Option<Self> {
        Some(Self(self.0.saturating_sub(n)))
    }

    fn as_u64(&self) -> u64 {
        self.0
    }
}

impl Protobuf for Height {
    type Proto = u64;

    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        Ok(Self(proto))
    }

    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(self.0)
    }
}

```
---
### `test/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
#![forbid(unsafe_code)]
#![deny(trivial_casts, trivial_numeric_casts)]
#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

mod address;
mod context;
mod genesis;
mod height;
mod proposal;
mod proposal_part;
mod signing;
mod validator_set;
mod value;
mod vote;

pub mod codec;
pub mod middleware;
pub mod proposer_selector;
pub mod proto;
pub mod utils;

pub use crate::address::*;
pub use crate::context::*;
pub use crate::genesis::*;
pub use crate::height::*;
pub use crate::proposal::*;
pub use crate::proposal_part::*;
pub use crate::signing::*;
pub use crate::validator_set::*;
pub use crate::value::*;
pub use crate::vote::*;

```
---
### `test/src/middleware.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use core::fmt;

use malachitebft_core_consensus::{LocallyProposedValue, ProposedValue};
use malachitebft_core_types::{CommitCertificate, NilOrVal, Round};

use crate::{Address, Genesis, Height, Proposal, TestContext, ValidatorSet, Value, ValueId, Vote};

pub trait Middleware: fmt::Debug + Send + Sync {
    fn get_validator_set(
        &self,
        _ctx: &TestContext,
        _current_height: Height,
        _height: Height,
        genesis: &Genesis,
    ) -> Option<ValidatorSet> {
        Some(genesis.validator_set.clone())
    }

    fn new_proposal(
        &self,
        _ctx: &TestContext,
        height: Height,
        round: Round,
        value: Value,
        pol_round: Round,
        address: Address,
    ) -> Proposal {
        Proposal::new(height, round, value, pol_round, address)
    }

    fn new_prevote(
        &self,
        _ctx: &TestContext,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        address: Address,
    ) -> Vote {
        Vote::new_prevote(height, round, value_id, address)
    }

    fn new_precommit(
        &self,
        _ctx: &TestContext,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        address: Address,
    ) -> Vote {
        Vote::new_precommit(height, round, value_id, address)
    }

    fn on_propose_value(
        &self,
        _ctx: &TestContext,
        _proposed_value: &mut LocallyProposedValue<TestContext>,
        _reproposal: bool,
    ) {
    }

    fn on_commit(
        &self,
        _ctx: &TestContext,
        _certificate: &CommitCertificate<TestContext>,
        _proposal: &ProposedValue<TestContext>,
    ) -> Result<(), eyre::Report> {
        Ok(())
    }
}

#[derive(Copy, Clone, Debug)]
pub struct DefaultMiddleware;

impl Middleware for DefaultMiddleware {}

fn select_validators(genesis: &Genesis, height: Height, selection_size: usize) -> ValidatorSet {
    let num_validators = genesis.validator_set.len();

    if num_validators <= selection_size {
        return genesis.validator_set.clone();
    }

    ValidatorSet::new(
        genesis
            .validator_set
            .iter()
            .cycle()
            .skip(height.as_u64() as usize % num_validators)
            .take(selection_size)
            .cloned()
            .collect::<Vec<_>>(),
    )
}

#[derive(Copy, Clone, Debug)]
pub struct RotateValidators {
    pub selection_size: usize,
}

impl Middleware for RotateValidators {
    // Selects N validators from index height % num_validators (circularly).
    // Example:
    //   - N = 3, num_validators = 5, height = 0 -> [0, 1, 2]
    //   - N = 3, num_validators = 5, height = 3 -> [3, 4, 0]
    fn get_validator_set(
        &self,
        _ctx: &TestContext,
        _current_height: Height,
        height: Height,
        genesis: &Genesis,
    ) -> Option<ValidatorSet> {
        let num_validators = genesis.validator_set.len();

        if num_validators <= self.selection_size {
            return Some(genesis.validator_set.clone());
        }

        Some(select_validators(genesis, height, self.selection_size))
    }
}

#[derive(Copy, Clone, Debug)]
pub struct EpochValidators {
    pub epochs_limit: usize,
}

impl Middleware for EpochValidators {
    fn get_validator_set(
        &self,
        _ctx: &TestContext,
        current_height: Height,
        height: Height,
        genesis: &Genesis,
    ) -> Option<ValidatorSet> {
        if height.as_u64() > current_height.as_u64() + self.epochs_limit as u64 {
            return None;
        }

        Some(genesis.validator_set.clone())
    }
}

#[derive(Copy, Clone, Debug)]
pub struct RotateEpochValidators {
    pub selection_size: usize,
    pub epochs_limit: usize,
}

impl Middleware for RotateEpochValidators {
    fn get_validator_set(
        &self,
        _ctx: &TestContext,
        current_height: Height,
        height: Height,
        genesis: &Genesis,
    ) -> Option<ValidatorSet> {
        if height.as_u64() > current_height.as_u64() + self.epochs_limit as u64 {
            return None;
        }

        let num_validators = genesis.validator_set.len();

        if num_validators <= self.selection_size {
            return Some(genesis.validator_set.clone());
        }

        Some(select_validators(genesis, height, self.selection_size))
    }
}

```
---
### `test/src/proposal.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use bytes::Bytes;
use malachitebft_core_types::Round;
use malachitebft_proto::{Error as ProtoError, Protobuf};

use crate::{Address, Height, TestContext, Value};

/// A proposal for a value in a round
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Proposal {
    pub height: Height,
    pub round: Round,
    pub value: Value,
    pub pol_round: Round,
    pub validator_address: Address,
}

impl Proposal {
    pub fn new(
        height: Height,
        round: Round,
        value: Value,
        pol_round: Round,
        validator_address: Address,
    ) -> Self {
        Self {
            height,
            round,
            value,
            pol_round,
            validator_address,
        }
    }

    pub fn to_bytes(&self) -> Bytes {
        Protobuf::to_bytes(self).unwrap()
    }

    pub fn to_sign_bytes(&self) -> Bytes {
        Protobuf::to_bytes(self).unwrap()
    }
}

impl malachitebft_core_types::Proposal<TestContext> for Proposal {
    fn height(&self) -> Height {
        self.height
    }

    fn round(&self) -> Round {
        self.round
    }

    fn value(&self) -> &Value {
        &self.value
    }

    fn take_value(self) -> Value {
        self.value
    }

    fn pol_round(&self) -> Round {
        self.pol_round
    }

    fn validator_address(&self) -> &Address {
        &self.validator_address
    }
}

impl Protobuf for Proposal {
    type Proto = crate::proto::Proposal;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(Self::Proto {
            height: self.height.to_proto()?,
            round: self.round.as_u32().expect("round should not be nil"),
            value: Some(self.value.to_proto()?),
            pol_round: self.pol_round.as_u32(),
            validator_address: Some(self.validator_address.to_proto()?),
        })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        Ok(Self {
            height: Height::from_proto(proto.height)?,
            round: Round::new(proto.round),
            value: Value::from_proto(
                proto
                    .value
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("value"))?,
            )?,
            pol_round: Round::from(proto.pol_round),
            validator_address: Address::from_proto(
                proto
                    .validator_address
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("validator_address"))?,
            )?,
        })
    }
}

```
---
### `test/src/proposal_part.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use bytes::Bytes;
use malachitebft_signing_ed25519::Signature;
use serde::{Deserialize, Serialize};

use malachitebft_core_types::Round;
use malachitebft_proto::{self as proto, Error as ProtoError, Protobuf};

use crate::codec::proto::{decode_signature, encode_signature};
use crate::{Address, Height, TestContext};

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ProposalData {
    pub factor: u64,
}

impl ProposalData {
    pub fn new(factor: u64) -> Self {
        Self { factor }
    }

    pub fn size_bytes(&self) -> usize {
        std::mem::size_of::<u64>()
    }
}

#[derive(Serialize, Deserialize)]
#[serde(remote = "Round")]
enum RoundDef {
    Nil,
    Some(u32),
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProposalPart {
    Init(ProposalInit),
    Data(ProposalData),
    Fin(ProposalFin),
}

impl ProposalPart {
    pub fn get_type(&self) -> &'static str {
        match self {
            Self::Init(_) => "init",
            Self::Data(_) => "data",
            Self::Fin(_) => "fin",
        }
    }

    pub fn as_init(&self) -> Option<&ProposalInit> {
        match self {
            Self::Init(init) => Some(init),
            _ => None,
        }
    }

    pub fn as_data(&self) -> Option<&ProposalData> {
        match self {
            Self::Data(data) => Some(data),
            _ => None,
        }
    }

    pub fn as_fin(&self) -> Option<&ProposalFin> {
        match self {
            Self::Fin(fin) => Some(fin),
            _ => None,
        }
    }

    pub fn to_sign_bytes(&self) -> Bytes {
        proto::Protobuf::to_bytes(self).unwrap()
    }
}

/// A part of a value for a height, round. Identified in this scope by the sequence.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ProposalInit {
    pub height: Height,
    #[serde(with = "RoundDef")]
    pub round: Round,
    #[serde(with = "RoundDef")]
    pub pol_round: Round,
    pub proposer: Address,
}

impl ProposalInit {
    pub fn new(height: Height, round: Round, pol_round: Round, proposer: Address) -> Self {
        Self {
            height,
            round,
            pol_round,
            proposer,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ProposalFin {
    pub signature: Signature,
}

impl ProposalFin {
    pub fn new(signature: Signature) -> Self {
        Self { signature }
    }
}

impl malachitebft_core_types::ProposalPart<TestContext> for ProposalPart {
    fn is_first(&self) -> bool {
        matches!(self, Self::Init(_))
    }

    fn is_last(&self) -> bool {
        matches!(self, Self::Fin(_))
    }
}

impl Protobuf for ProposalPart {
    type Proto = crate::proto::ProposalPart;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        use crate::proto::proposal_part::Part;

        let part = proto
            .part
            .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("part"))?;

        match part {
            Part::Init(init) => Ok(Self::Init(ProposalInit {
                height: Height::new(init.height),
                round: Round::new(init.round),
                pol_round: Round::from(init.pol_round),
                proposer: init
                    .proposer
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("proposer"))
                    .and_then(Address::from_proto)?,
            })),
            Part::Data(data) => Ok(Self::Data(ProposalData::new(data.factor))),
            Part::Fin(fin) => Ok(Self::Fin(ProposalFin {
                signature: fin
                    .signature
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("signature"))
                    .and_then(decode_signature)?,
            })),
        }
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        use crate::proto;
        use crate::proto::proposal_part::Part;

        match self {
            Self::Init(init) => Ok(Self::Proto {
                part: Some(Part::Init(proto::ProposalInit {
                    height: init.height.as_u64(),
                    round: init.round.as_u32().unwrap(),
                    pol_round: init.pol_round.as_u32(),
                    proposer: Some(init.proposer.to_proto()?),
                })),
            }),
            Self::Data(data) => Ok(Self::Proto {
                part: Some(Part::Data(proto::ProposalData {
                    factor: data.factor,
                })),
            }),
            Self::Fin(fin) => Ok(Self::Proto {
                part: Some(Part::Fin(proto::ProposalFin {
                    signature: Some(encode_signature(&fin.signature)),
                })),
            }),
        }
    }
}

```
---
### `test/src/proposer_selector.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use malachitebft_core_types::{Context, Round};

use crate::{Address, Height, TestContext, ValidatorSet};

/// Defines how to select a proposer amongst a validator set for a given round.
pub trait ProposerSelector<Ctx>
where
    Self: Send + Sync,
    Ctx: Context,
{
    /// Select a proposer from the given validator set for the given round.
    ///
    /// This function is called at the beginning of each round to select the proposer for that
    /// round. The proposer is responsible for proposing a value for the round.
    ///
    /// # Important
    /// This function must be deterministic!
    /// For a given round and validator set, it must always return the same proposer.
    fn select_proposer(
        &self,
        height: Ctx::Height,
        round: Round,
        validator_set: &Ctx::ValidatorSet,
    ) -> Ctx::Address;
}

#[derive(Copy, Clone, Debug, Default)]
pub struct RotateProposer;

impl ProposerSelector<TestContext> for RotateProposer {
    fn select_proposer(
        &self,
        height: Height,
        round: Round,
        validator_set: &ValidatorSet,
    ) -> Address {
        assert!(round != Round::Nil && round.as_i64() >= 0);

        let height = height.as_u64() as usize;
        let round = round.as_i64() as usize;

        let proposer_index = (height - 1 + round) % validator_set.validators.len();
        validator_set.validators[proposer_index].address
    }
}

#[derive(Copy, Clone, Debug)]
pub struct FixedProposer {
    proposer: Address,
}

impl FixedProposer {
    pub fn new(proposer: Address) -> Self {
        Self { proposer }
    }
}

impl ProposerSelector<TestContext> for FixedProposer {
    fn select_proposer(
        &self,
        _height: Height,
        _round: Round,
        _validator_set: &ValidatorSet,
    ) -> Address {
        self.proposer
    }
}

```
---
### `test/src/proto.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
#![allow(missing_docs)]

include!(concat!(env!("OUT_DIR"), "/test.rs"));

```
---
### `test/src/signing.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use bytes::Bytes;

use malachitebft_core_types::{
    SignedExtension, SignedProposal, SignedProposalPart, SignedVote, SigningProvider,
};

use crate::{Proposal, ProposalPart, TestContext, Vote};

pub use malachitebft_signing_ed25519::*;

pub trait Hashable {
    type Output;
    fn hash(&self) -> Self::Output;
}

impl Hashable for PublicKey {
    type Output = [u8; 32];

    fn hash(&self) -> [u8; 32] {
        use sha3::{Digest, Keccak256};
        let mut hasher = Keccak256::new();
        hasher.update(self.as_bytes());
        hasher.finalize().into()
    }
}

#[derive(Debug)]
pub struct Ed25519Provider {
    private_key: PrivateKey,
}

impl Ed25519Provider {
    pub fn new(private_key: PrivateKey) -> Self {
        Self { private_key }
    }

    pub fn private_key(&self) -> &PrivateKey {
        &self.private_key
    }

    pub fn sign(&self, data: &[u8]) -> Signature {
        self.private_key.sign(data)
    }

    pub fn verify(&self, data: &[u8], signature: &Signature, public_key: &PublicKey) -> bool {
        public_key.verify(data, signature).is_ok()
    }
}

impl SigningProvider<TestContext> for Ed25519Provider {
    fn sign_vote(&self, vote: Vote) -> SignedVote<TestContext> {
        let signature = self.sign(&vote.to_sign_bytes());
        SignedVote::new(vote, signature)
    }

    fn verify_signed_vote(
        &self,
        vote: &Vote,
        signature: &Signature,
        public_key: &PublicKey,
    ) -> bool {
        public_key.verify(&vote.to_sign_bytes(), signature).is_ok()
    }

    fn sign_proposal(&self, proposal: Proposal) -> SignedProposal<TestContext> {
        let signature = self.private_key.sign(&proposal.to_sign_bytes());
        SignedProposal::new(proposal, signature)
    }

    fn verify_signed_proposal(
        &self,
        proposal: &Proposal,
        signature: &Signature,
        public_key: &PublicKey,
    ) -> bool {
        public_key
            .verify(&proposal.to_sign_bytes(), signature)
            .is_ok()
    }

    fn sign_proposal_part(&self, proposal_part: ProposalPart) -> SignedProposalPart<TestContext> {
        let signature = self.private_key.sign(&proposal_part.to_sign_bytes());
        SignedProposalPart::new(proposal_part, signature)
    }

    fn verify_signed_proposal_part(
        &self,
        proposal_part: &ProposalPart,
        signature: &Signature,
        public_key: &PublicKey,
    ) -> bool {
        public_key
            .verify(&proposal_part.to_sign_bytes(), signature)
            .is_ok()
    }

    fn sign_vote_extension(&self, extension: Bytes) -> SignedExtension<TestContext> {
        let signature = self.private_key.sign(extension.as_ref());
        malachitebft_core_types::SignedMessage::new(extension, signature)
    }

    fn verify_signed_vote_extension(
        &self,
        extension: &Bytes,
        signature: &Signature,
        public_key: &PublicKey,
    ) -> bool {
        public_key.verify(extension.as_ref(), signature).is_ok()
    }
}

```
---
### `test/src/utils/mod.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod validators;

```
---
### `test/src/utils/validators.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use rand::rngs::StdRng;
use rand::SeedableRng;

use malachitebft_core_types::VotingPower;

use crate::{PrivateKey, Validator};

pub fn make_validators_seeded<const N: usize>(
    voting_powers: [VotingPower; N],
    seed: u64,
) -> [(Validator, PrivateKey); N] {
    let mut rng = StdRng::seed_from_u64(seed);

    let mut validators = Vec::with_capacity(N);

    for vp in voting_powers {
        let sk = PrivateKey::generate(&mut rng);
        let val = Validator::new(sk.public_key(), vp);
        validators.push((val, sk));
    }

    validators.try_into().expect("N validators")
}

pub fn make_validators<const N: usize>(
    voting_powers: [VotingPower; N],
) -> [(Validator, PrivateKey); N] {
    make_validators_seeded(voting_powers, 42)
}

```
---
### `test/src/validator_set.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use core::slice;
use std::sync::Arc;

use malachitebft_core_types::VotingPower;
use serde::{Deserialize, Serialize};

use crate::signing::PublicKey;
use crate::{Address, TestContext};

/// A validator is a public key and voting power
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Validator {
    pub address: Address,
    pub public_key: PublicKey,
    pub voting_power: VotingPower,
}

impl Validator {
    #[cfg_attr(coverage_nightly, coverage(off))]
    pub fn new(public_key: PublicKey, voting_power: VotingPower) -> Self {
        Self {
            address: Address::from_public_key(&public_key),
            public_key,
            voting_power,
        }
    }
}

impl PartialOrd for Validator {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Validator {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.address.cmp(&other.address)
    }
}

impl malachitebft_core_types::Validator<TestContext> for Validator {
    fn address(&self) -> &Address {
        &self.address
    }

    fn public_key(&self) -> &PublicKey {
        &self.public_key
    }

    fn voting_power(&self) -> VotingPower {
        self.voting_power
    }
}

/// A validator set contains a list of validators sorted by address.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ValidatorSet {
    pub validators: Arc<Vec<Validator>>,
}

impl ValidatorSet {
    pub fn new(validators: impl IntoIterator<Item = Validator>) -> Self {
        let mut validators: Vec<_> = validators.into_iter().collect();
        ValidatorSet::sort_validators(&mut validators);

        assert!(!validators.is_empty());

        Self {
            validators: Arc::new(validators),
        }
    }

    /// Get the number of validators in the set
    pub fn len(&self) -> usize {
        self.validators.len()
    }

    /// Check if the set is empty
    pub fn is_empty(&self) -> bool {
        self.validators.is_empty()
    }

    /// Iterate over the validators in the set
    pub fn iter(&self) -> slice::Iter<Validator> {
        self.validators.iter()
    }

    /// The total voting power of the validator set
    pub fn total_voting_power(&self) -> VotingPower {
        self.validators.iter().map(|v| v.voting_power).sum()
    }

    /// Get a validator by its index
    pub fn get_by_index(&self, index: usize) -> Option<&Validator> {
        self.validators.get(index)
    }

    /// Get a validator by its address
    pub fn get_by_address(&self, address: &Address) -> Option<&Validator> {
        self.validators.iter().find(|v| &v.address == address)
    }

    pub fn get_by_public_key(&self, public_key: &PublicKey) -> Option<&Validator> {
        self.validators.iter().find(|v| &v.public_key == public_key)
    }

    /// In place sort and deduplication of a list of validators
    fn sort_validators(vals: &mut Vec<Validator>) {
        // Sort the validators according to the current Tendermint requirements
        //
        // use core::cmp::Reverse;
        //
        // (v. 0.34 -> first by validator power, descending, then by address, ascending)
        // vals.sort_unstable_by(|v1, v2| {
        //     let a = (Reverse(v1.voting_power), &v1.address);
        //     let b = (Reverse(v2.voting_power), &v2.address);
        //     a.cmp(&b)
        // });

        vals.dedup();
    }

    pub fn get_keys(&self) -> Vec<PublicKey> {
        self.validators.iter().map(|v| v.public_key).collect()
    }
}

impl malachitebft_core_types::ValidatorSet<TestContext> for ValidatorSet {
    fn count(&self) -> usize {
        self.validators.len()
    }

    fn total_voting_power(&self) -> VotingPower {
        self.total_voting_power()
    }

    fn get_by_address(&self, address: &Address) -> Option<&Validator> {
        self.get_by_address(address)
    }

    fn get_by_index(&self, index: usize) -> Option<&Validator> {
        self.validators.get(index)
    }
}

#[cfg(test)]
mod tests {
    use rand::rngs::StdRng;
    use rand::SeedableRng;

    use super::*;

    use crate::PrivateKey;

    #[test]
    fn new_validator_set_vp() {
        let mut rng = StdRng::seed_from_u64(0x42);

        let sk1 = PrivateKey::generate(&mut rng);
        let sk2 = PrivateKey::generate(&mut rng);
        let sk3 = PrivateKey::generate(&mut rng);

        let v1 = Validator::new(sk1.public_key(), 1);
        let v2 = Validator::new(sk2.public_key(), 2);
        let v3 = Validator::new(sk3.public_key(), 3);

        let vs = ValidatorSet::new(vec![v1, v2, v3]);
        assert_eq!(vs.total_voting_power(), 6);
    }
}

```
---
### `test/src/value.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use bytes::{Bytes, BytesMut};
use core::fmt;
use malachitebft_proto::{Error as ProtoError, Protobuf};
use serde::{Deserialize, Serialize};

use crate::proto;

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Serialize, Deserialize)]
pub struct ValueId(u64);

impl ValueId {
    pub const fn new(id: u64) -> Self {
        Self(id)
    }

    pub const fn as_u64(&self) -> u64 {
        self.0
    }
}

impl From<u64> for ValueId {
    fn from(value: u64) -> Self {
        Self::new(value)
    }
}

impl fmt::Display for ValueId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:x}", self.0)
    }
}

impl Protobuf for ValueId {
    type Proto = proto::ValueId;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        let bytes = proto
            .value
            .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("value"))?;

        let len = bytes.len();
        let bytes = <[u8; 8]>::try_from(bytes.as_ref()).map_err(|_| {
            ProtoError::Other(format!(
                "Invalid value length, got {len} bytes expected {}",
                u64::BITS / 8
            ))
        })?;

        Ok(ValueId::new(u64::from_be_bytes(bytes)))
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(proto::ValueId {
            value: Some(self.0.to_be_bytes().to_vec().into()),
        })
    }
}

/// The value to decide on
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub struct Value {
    pub value: u64,
    pub extensions: Bytes,
}

impl Value {
    pub fn new(value: u64) -> Self {
        Self {
            value,
            extensions: Bytes::new(),
        }
    }

    pub fn id(&self) -> ValueId {
        ValueId(self.value)
    }

    pub fn size_bytes(&self) -> usize {
        std::mem::size_of_val(&self.value) + self.extensions.len()
    }
}

impl malachitebft_core_types::Value for Value {
    type Id = ValueId;

    fn id(&self) -> ValueId {
        self.id()
    }
}

impl Protobuf for Value {
    type Proto = proto::Value;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        let bytes = proto
            .value
            .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("value"))?;

        let value = bytes[0..8].try_into().map_err(|_| {
            ProtoError::Other(format!(
                "Too few bytes, expected at least {}",
                u64::BITS / 8
            ))
        })?;

        let extensions = bytes.slice(8..);

        Ok(Value {
            value: u64::from_be_bytes(value),
            extensions,
        })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        let mut bytes = BytesMut::new();
        bytes.extend_from_slice(&self.value.to_be_bytes());
        bytes.extend_from_slice(&self.extensions);

        Ok(proto::Value {
            value: Some(bytes.freeze()),
        })
    }
}

```
---
### `test/src/vote.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use bytes::Bytes;
use malachitebft_core_types::{NilOrVal, Round, SignedExtension, VoteType};
use malachitebft_proto::{Error as ProtoError, Protobuf};

use crate::proto;
use crate::{Address, Height, TestContext, ValueId};

pub use malachitebft_core_types::Extension;

/// A vote for a value in a round
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Vote {
    pub typ: VoteType,
    pub height: Height,
    pub round: Round,
    pub value: NilOrVal<ValueId>,
    pub validator_address: Address,
    pub extension: Option<SignedExtension<TestContext>>,
}

impl Vote {
    pub fn new_prevote(
        height: Height,
        round: Round,
        value: NilOrVal<ValueId>,
        validator_address: Address,
    ) -> Self {
        Self {
            typ: VoteType::Prevote,
            height,
            round,
            value,
            validator_address,
            extension: None,
        }
    }

    pub fn new_precommit(
        height: Height,
        round: Round,
        value: NilOrVal<ValueId>,
        address: Address,
    ) -> Self {
        Self {
            typ: VoteType::Precommit,
            height,
            round,
            value,
            validator_address: address,
            extension: None,
        }
    }

    pub fn to_bytes(&self) -> Bytes {
        Protobuf::to_bytes(self).unwrap()
    }

    pub fn to_sign_bytes(&self) -> Bytes {
        let vote = Self {
            extension: None,
            ..self.clone()
        };

        Protobuf::to_bytes(&vote).unwrap()
    }
}

impl malachitebft_core_types::Vote<TestContext> for Vote {
    fn height(&self) -> Height {
        self.height
    }

    fn round(&self) -> Round {
        self.round
    }

    fn value(&self) -> &NilOrVal<ValueId> {
        &self.value
    }

    fn take_value(self) -> NilOrVal<ValueId> {
        self.value
    }

    fn vote_type(&self) -> VoteType {
        self.typ
    }

    fn validator_address(&self) -> &Address {
        &self.validator_address
    }

    fn extension(&self) -> Option<&SignedExtension<TestContext>> {
        self.extension.as_ref()
    }

    fn take_extension(&mut self) -> Option<SignedExtension<TestContext>> {
        self.extension.take()
    }

    fn extend(self, extension: SignedExtension<TestContext>) -> Self {
        Self {
            extension: Some(extension),
            ..self
        }
    }
}

impl Protobuf for Vote {
    type Proto = crate::proto::Vote;

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn from_proto(proto: Self::Proto) -> Result<Self, ProtoError> {
        Ok(Self {
            typ: decode_votetype(proto.vote_type()),
            height: Height::from_proto(proto.height)?,
            round: Round::new(proto.round),
            value: match proto.value {
                Some(value) => NilOrVal::Val(ValueId::from_proto(value)?),
                None => NilOrVal::Nil,
            },
            validator_address: Address::from_proto(
                proto
                    .validator_address
                    .ok_or_else(|| ProtoError::missing_field::<Self::Proto>("validator_address"))?,
            )?,
            extension: Default::default(),
        })
    }

    #[cfg_attr(coverage_nightly, coverage(off))]
    fn to_proto(&self) -> Result<Self::Proto, ProtoError> {
        Ok(Self::Proto {
            vote_type: encode_votetype(self.typ).into(),
            height: self.height.to_proto()?,
            round: self.round.as_u32().expect("round should not be nil"),
            value: match &self.value {
                NilOrVal::Nil => None,
                NilOrVal::Val(v) => Some(v.to_proto()?),
            },
            validator_address: Some(self.validator_address.to_proto()?),
        })
    }
}

#[cfg_attr(coverage_nightly, coverage(off))]
pub fn encode_votetype(vote_type: VoteType) -> proto::VoteType {
    match vote_type {
        VoteType::Prevote => proto::VoteType::Prevote,
        VoteType::Precommit => proto::VoteType::Precommit,
    }
}

#[cfg_attr(coverage_nightly, coverage(off))]
pub fn decode_votetype(vote_type: proto::VoteType) -> VoteType {
    match vote_type {
        proto::VoteType::Prevote => VoteType::Prevote,
        proto::VoteType::Precommit => VoteType::Precommit,
    }
}

```
---
### `test/tests/it/full_nodes.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::time::Duration;

use crate::{TestBuilder, TestParams};

#[tokio::test]
pub async fn basic_full_node() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    // Add 3 validators with different voting powers
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(30)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add 2 full nodes that should follow consensus but not participate
    test.add_node()
        .full_node()
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .full_node()
        .start()
        .wait_until(HEIGHT)
        .success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn full_node_crash_and_sync() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Add validators
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add a full node that crashes and needs to sync
    test.add_node()
        .full_node()
        .start()
        .wait_until(3)
        .crash()
        .reset_db()
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn late_starting_full_node() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Add validators that start immediately
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add a full node that starts late
    test.add_node()
        .full_node()
        .start_after(1, Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn mixed_validator_and_full_node_failures() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    // Add stable validators
    test.add_node()
        .with_voting_power(30)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(30)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add a validator that crashes
    test.add_node()
        .with_voting_power(20)
        .start()
        .wait_until(5)
        .crash()
        .restart_after(Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    // Add full nodes - one stable, one that crashes
    test.add_node()
        .full_node()
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .full_node()
        .start()
        .wait_until(6)
        .crash()
        .restart_after(Duration::from_secs(15))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

```
---
### `test/tests/it/liveness.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::time::Duration;

use informalsystems_malachitebft_test::TestContext;
use malachitebft_core_consensus::HIDDEN_LOCK_ROUND;
use malachitebft_core_types::Round;
use malachitebft_test_framework::TestNode;

use crate::middlewares::PrevoteNil;
use crate::{TestBuilder, TestParams};

fn expect_round_certificate_rebroadcasts(node: &mut TestNode<TestContext>) {
    node.expect_skip_round_certificate(1, 0)
        .expect_skip_round_certificate(1, 1)
        .expect_skip_round_certificate(1, 2);
}

#[tokio::test]
async fn round_certificate_rebroadcast() {
    const FINAL_HEIGHT: u64 = 3;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_middleware(PrevoteNil::when(|height, round, _| {
            height.as_u64() == 1 && round.as_i64() <= 2
        }))
        .start()
        .wait_until(1)
        .with(expect_round_certificate_rebroadcasts)
        .wait_until(FINAL_HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(1)
        .with(expect_round_certificate_rebroadcasts)
        .wait_until(FINAL_HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(1)
        .with(expect_round_certificate_rebroadcasts)
        .wait_until(FINAL_HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(30),
            TestParams {
                enable_value_sync: false,
                ..Default::default()
            },
        )
        .await
}

fn expect_hidden_lock_messages(node: &mut TestNode<TestContext>, round: Round) {
    node.expect_polka_certificate(1, round.as_u32().expect("non-nil round"));
}

#[tokio::test]
async fn polka_certificate_for_hidden_lock() {
    const FINAL_HEIGHT: u64 = 3;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_middleware(PrevoteNil::when(|height, round, _| {
            height.as_u64() == 1 && round < HIDDEN_LOCK_ROUND
        }))
        .start()
        .wait_until(1)
        .with(|node| expect_hidden_lock_messages(node, HIDDEN_LOCK_ROUND))
        .wait_until(FINAL_HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(1)
        .with(|node| expect_hidden_lock_messages(node, HIDDEN_LOCK_ROUND))
        .wait_until(FINAL_HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(1)
        .with(|node| expect_hidden_lock_messages(node, HIDDEN_LOCK_ROUND))
        .wait_until(FINAL_HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(120),
            TestParams {
                enable_value_sync: false,
                ..Default::default()
            },
        )
        .await
}

```
---
### `test/tests/it/main.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
mod full_nodes;
mod liveness;
mod middlewares;
mod n3f0;
mod n3f0_consensus_mode;
mod n3f0_pubsub_protocol;
mod n3f1;
mod reset;
mod validator_set;
mod value_sync;
mod vote_rebroadcast;
mod wal;

use std::collections::HashMap;
use std::path::PathBuf;
use std::str::FromStr;
use std::sync::Arc;
use std::time::Duration;

use async_trait::async_trait;
use informalsystems_malachitebft_test::middleware::Middleware;
use malachitebft_test_app::config::Config;
use rand::rngs::StdRng;
use rand::SeedableRng;
use tempfile::TempDir;

use malachitebft_app::node::Node;
use malachitebft_signing_ed25519::PrivateKey;
use malachitebft_test_app::node::{App, Handle};
use malachitebft_test_framework::HasTestRunner;
use malachitebft_test_framework::{NodeRunner, TestNode};

pub use malachitebft_test_framework::TestBuilder as GenTestBuilder;
pub use malachitebft_test_framework::{HandlerResult, NodeId, TestParams};

use informalsystems_malachitebft_test::{Height, TestContext, Validator, ValidatorSet};

pub type TestBuilder<S> = GenTestBuilder<TestContext, S>;

impl HasTestRunner<TestRunner> for TestContext {
    type Runner = TestRunner;
}

#[derive(Clone)]
pub struct TestRunner {
    pub id: usize,
    pub params: TestParams,
    pub nodes_info: HashMap<NodeId, NodeInfo>,
    pub private_keys: HashMap<NodeId, PrivateKey>,
    pub validator_set: ValidatorSet,
    pub consensus_base_port: usize,
    pub mempool_base_port: usize,
    pub metrics_base_port: usize,
}

fn temp_dir(id: NodeId) -> PathBuf {
    TempDir::with_prefix(format!("malachitebft-test-app-{id}"))
        .unwrap()
        .into_path()
}

#[derive(Clone)]
pub struct NodeInfo {
    start_height: Height,
    home_dir: PathBuf,
    middleware: Arc<dyn Middleware>,
}

#[async_trait]
impl NodeRunner<TestContext> for TestRunner {
    type NodeHandle = Handle;

    fn new<S>(id: usize, nodes: &[TestNode<TestContext, S>], params: TestParams) -> Self {
        let base_port = 20_000 + id * 1000;

        let (validators, private_keys) = make_validators(nodes);
        let validator_set = ValidatorSet::new(validators);

        let nodes_info = nodes
            .iter()
            .map(|node| {
                (
                    node.id,
                    NodeInfo {
                        start_height: node.start_height,
                        home_dir: temp_dir(node.id),
                        middleware: Arc::clone(&node.middleware),
                    },
                )
            })
            .collect();

        Self {
            id,
            params,
            nodes_info,
            private_keys,
            validator_set,
            consensus_base_port: base_port,
            mempool_base_port: base_port + 100,
            metrics_base_port: base_port + 200,
        }
    }

    async fn spawn(&self, id: NodeId) -> eyre::Result<Handle> {
        let app = App {
            config: self.generate_config(id),
            home_dir: self.nodes_info[&id].home_dir.clone(),
            validator_set: self.validator_set.clone(),
            private_key: self.private_keys[&id].clone(),
            start_height: Some(self.nodes_info[&id].start_height),
            middleware: Some(Arc::clone(&self.nodes_info[&id].middleware)),
        };

        app.start().await
    }

    async fn reset_db(&self, id: NodeId) -> eyre::Result<()> {
        let db_dir = self.nodes_info[&id].home_dir.join("db");
        std::fs::remove_dir_all(&db_dir)?;
        std::fs::create_dir_all(&db_dir)?;
        Ok(())
    }
}

impl TestRunner {
    fn generate_config(&self, node: NodeId) -> Config {
        let mut config = self.generate_default_config(node);
        self.params.apply_to_config(&mut config);
        config
    }

    fn generate_default_config(&self, node: NodeId) -> Config {
        use malachitebft_config::*;

        let transport = transport_from_env(TransportProtocol::Tcp);
        let protocol = PubSubProtocol::default();

        let i = node - 1;

        Config {
            moniker: format!("node-{}", node),
            logging: LoggingConfig::default(),
            consensus: ConsensusConfig {
                // Current test app does not support proposal-only value payload properly as Init does not include valid_round
                value_payload: ValuePayload::ProposalAndParts,
                timeouts: TimeoutConfig::default(),
                p2p: P2pConfig {
                    protocol,
                    discovery: DiscoveryConfig::default(),
                    listen_addr: transport.multiaddr("127.0.0.1", self.consensus_base_port + i),
                    persistent_peers: (0..self.nodes_info.len())
                        .filter(|j| i != *j)
                        .map(|j| transport.multiaddr("127.0.0.1", self.consensus_base_port + j))
                        .collect(),
                    ..Default::default()
                },
            },
            value_sync: ValueSyncConfig {
                enabled: true,
                status_update_interval: Duration::from_secs(2),
                request_timeout: Duration::from_secs(5),
            },
            metrics: MetricsConfig {
                enabled: false,
                listen_addr: format!("127.0.0.1:{}", self.metrics_base_port + i)
                    .parse()
                    .unwrap(),
            },
            runtime: RuntimeConfig::single_threaded(),
            test: TestConfig::default(),
        }
    }
}

use malachitebft_config::TransportProtocol;

fn transport_from_env(default: TransportProtocol) -> TransportProtocol {
    if let Ok(protocol) = std::env::var("MALACHITE_TRANSPORT") {
        TransportProtocol::from_str(&protocol).unwrap_or(default)
    } else {
        default
    }
}

fn make_validators<S>(
    nodes: &[TestNode<TestContext, S>],
) -> (Vec<Validator>, HashMap<NodeId, PrivateKey>) {
    let mut rng = StdRng::seed_from_u64(0x42);

    let mut validators = Vec::new();
    let mut private_keys = HashMap::new();

    for node in nodes {
        let sk = PrivateKey::generate(&mut rng);
        let val = Validator::new(sk.public_key(), node.voting_power);

        private_keys.insert(node.id, sk);

        if node.voting_power > 0 {
            validators.push(val);
        }
    }

    (validators, private_keys)
}

```
---
### `test/tests/it/middlewares.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use informalsystems_malachitebft_test::{self as malachitebft_test};

use malachitebft_core_consensus::LocallyProposedValue;
use malachitebft_core_types::{NilOrVal, Round};
use malachitebft_test::middleware::Middleware;
use malachitebft_test::{Address, Height, TestContext, ValueId, Vote};

#[derive(Copy, Clone, Debug)]
pub struct ByzantineProposer;

impl Middleware for ByzantineProposer {
    fn on_propose_value(
        &self,
        _ctx: &TestContext,
        proposal: &mut LocallyProposedValue<TestContext>,
        reproposal: bool,
    ) {
        use informalsystems_malachitebft_test::Value;
        use rand::Rng;

        if !reproposal {
            tracing::warn!(
                "ByzantineProposer: First time proposing value {:}",
                proposal.value.id()
            );

            // Do not change the value if it is the first time we propose it
            return;
        }

        // Make up a new value that is different from the one we are supposed to propose
        let new_value = loop {
            let new_value = Value::new(rand::thread_rng().gen_range(100..=100000));
            if new_value != proposal.value {
                break new_value;
            }
        };

        tracing::warn!(
            "ByzantineProposer: Not re-using previously built value {:} but a new one {:}",
            proposal.value.id(),
            new_value.id()
        );

        proposal.value = new_value;
    }
}

#[derive(Copy, Clone, Debug)]
pub struct PrevoteNil {
    enabled: fn(Height, Round, &NilOrVal<ValueId>) -> bool,
}

impl PrevoteNil {
    pub fn when(enabled: fn(Height, Round, &NilOrVal<ValueId>) -> bool) -> Self {
        Self { enabled }
    }
}

impl Middleware for PrevoteNil {
    fn new_prevote(
        &self,
        _ctx: &TestContext,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        address: Address,
    ) -> Vote {
        if (self.enabled)(height, round, &value_id) {
            Vote::new_prevote(height, round, NilOrVal::Nil, address)
        } else {
            Vote::new_prevote(height, round, value_id, address)
        }
    }
}

```
---
### `test/tests/it/n3f0.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::time::Duration;

use malachitebft_test_framework::TestParams;

use malachitebft_config::ValuePayload;

use crate::TestBuilder;

#[tokio::test]
pub async fn all_correct_nodes() {
    const HEIGHT: u64 = 2;

    let mut test = TestBuilder::<()>::new();

    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();

    test.build()
        .run_with_params(
            Duration::from_secs(50),
            TestParams {
                value_payload: ValuePayload::ProposalAndParts,
                ..TestParams::default()
            },
        )
        .await
}

```
---
### `test/tests/it/n3f0_consensus_mode.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::time::Duration;

use malachitebft_config::ValuePayload;

use crate::{TestBuilder, TestParams};

async fn run_test(params: TestParams) {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();

    test.build()
        .run_with_params(Duration::from_secs(30), params)
        .await
}

#[tokio::test]
pub async fn parts_only() {
    let params = TestParams {
        value_payload: ValuePayload::PartsOnly,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn proposal_and_parts() {
    let params = TestParams {
        value_payload: ValuePayload::ProposalAndParts,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
#[ignore] // Test app does not support proposal-only mode
pub async fn proposal_only() {
    let params = TestParams {
        value_payload: ValuePayload::ProposalOnly,
        ..Default::default()
    };

    run_test(params).await
}

```
---
### `test/tests/it/n3f0_pubsub_protocol.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::time::Duration;

use bytesize::ByteSize;

use malachitebft_config::{GossipSubConfig, PubSubProtocol};

use crate::{TestBuilder, TestParams};

async fn run_test(params: TestParams) {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();
    test.add_node().start().wait_until(HEIGHT).success();

    test.build()
        .run_with_params(Duration::from_secs(30), params)
        .await
}

#[tokio::test]
pub async fn broadcast_custom_config_1ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::Broadcast,
        block_size: ByteSize::kib(1),
        tx_size: ByteSize::kib(1),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn broadcast_custom_config_2ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::Broadcast,
        block_size: ByteSize::kib(2),
        tx_size: ByteSize::kib(2),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn gossip_custom_config_1ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::GossipSub(GossipSubConfig::default()),
        block_size: ByteSize::kib(1),
        tx_size: ByteSize::kib(1),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

#[tokio::test]
pub async fn gossip_custom_config_2ktx() {
    let params = TestParams {
        enable_value_sync: false,
        protocol: PubSubProtocol::GossipSub(GossipSubConfig::default()),
        block_size: ByteSize::kib(2),
        tx_size: ByteSize::kib(2),
        txs_per_part: 1,
        ..Default::default()
    };

    run_test(params).await
}

```
---
### `test/tests/it/n3f1.rs`
*2025-05-18 23:58:49 | 3 KB*
```rust
use std::time::Duration;

use crate::TestBuilder;

#[tokio::test]
pub async fn proposer_fails_to_start() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node().with_voting_power(1).success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn one_node_fails_to_start() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node().with_voting_power(1).success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn proposer_crashes_at_height_2() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(1)
        .start()
        .wait_until(2)
        .crash()
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.build().run(Duration::from_secs(30)).await
}

#[tokio::test]
pub async fn one_node_crashes_at_height_3() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(1)
        .start()
        .wait_until(3)
        .crash()
        .success();

    test.build().run(Duration::from_secs(30)).await
}

```
---
### `test/tests/it/reset.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;

use eyre::bail;
use informalsystems_malachitebft_test::middleware::Middleware;
use informalsystems_malachitebft_test::TestContext;
use malachitebft_core_consensus::ProposedValue;
use malachitebft_core_types::CommitCertificate;
use malachitebft_test_framework::TestParams;

use crate::TestBuilder;

#[tokio::test]
pub async fn reset_height() {
    const RESET_HEIGHT: u64 = 5;
    const FINAL_HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    test.add_node().start().wait_until(FINAL_HEIGHT).success();
    test.add_node().start().wait_until(FINAL_HEIGHT).success();

    test.add_node()
        .with_middleware(ResetHeight::new(RESET_HEIGHT))
        .start()
        .wait_until(RESET_HEIGHT) // First time reaching height
        .wait_until(RESET_HEIGHT) // Will restart height after commit failure
        .wait_until(FINAL_HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..TestParams::default()
            },
        )
        .await
}

#[derive(Debug)]
struct ResetHeight {
    reset_height: u64,
    reset: AtomicBool,
}

impl ResetHeight {
    fn new(reset_height: u64) -> Self {
        Self {
            reset_height,
            reset: AtomicBool::new(false),
        }
    }
}

impl Middleware for ResetHeight {
    fn on_commit(
        &self,
        _ctx: &TestContext,
        certificate: &CommitCertificate<TestContext>,
        proposal: &ProposedValue<TestContext>,
    ) -> Result<(), eyre::Report> {
        assert_eq!(certificate.height, proposal.height);

        if certificate.height.as_u64() == self.reset_height
            && !self.reset.swap(true, Ordering::SeqCst)
        {
            bail!("Simulating commit failure");
        }

        Ok(())
    }
}

```
---
### `test/tests/it/validator_set.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::time::Duration;

use informalsystems_malachitebft_test::middleware::RotateValidators;

use crate::TestBuilder;

#[tokio::test]
async fn rotate_validator_set() {
    const HEIGHT: u64 = 20;
    const NUM_NODES: usize = 5;
    const NUM_VALIDATORS_PER_HEIGHT: usize = 3;

    let mut test = TestBuilder::<()>::new();

    for _ in 0..NUM_NODES {
        test.add_node()
            .with_middleware(RotateValidators {
                selection_size: NUM_VALIDATORS_PER_HEIGHT,
            })
            .start()
            .wait_until(HEIGHT)
            .success();
    }

    test.build().run(Duration::from_secs(50)).await
}

```
---
### `test/tests/it/value_sync.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use std::time::Duration;

use informalsystems_malachitebft_test::middleware::RotateEpochValidators;
use malachitebft_config::ValuePayload;

use crate::{TestBuilder, TestParams};

pub async fn crash_restart_from_start(params: TestParams) {
    const HEIGHT: u64 = 6;
    const CRASH_HEIGHT: u64 = 4;

    let mut test = TestBuilder::<()>::new();

    // Node 1 starts with 10 voting power.
    test.add_node()
        .with_voting_power(10)
        .start()
        // Wait until it reaches height 10
        .wait_until(HEIGHT)
        // Record a successful test for this node
        .success();

    // Node 2 starts with 10 voting power, in parallel with node 1 and with the same behaviour
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();

    // Node 3 starts with 5 voting power, in parallel with node 1 and 2.
    test.add_node()
        .with_voting_power(5)
        .start()
        // Wait until the node reaches height 2...
        .wait_until(CRASH_HEIGHT)
        // ...and then kills it
        .crash()
        // Reset the database so that the node has to do Sync from height 1
        .reset_db()
        // After that, it waits 5 seconds before restarting the node
        .restart_after(Duration::from_secs(5))
        // Wait until the node reached the expected height
        .wait_until(HEIGHT)
        // Record a successful test for this node
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60), // Timeout for the whole test
            TestParams {
                enable_value_sync: true, // Enable Sync
                ..params
            },
        )
        .await
}

#[tokio::test]
pub async fn crash_restart_from_start_parts_only() {
    let params = TestParams {
        value_payload: ValuePayload::PartsOnly,
        ..Default::default()
    };

    crash_restart_from_start(params).await
}

#[tokio::test]
#[ignore]
pub async fn crash_restart_from_start_proposal_only() {
    let params = TestParams {
        value_payload: ValuePayload::ProposalOnly,
        ..Default::default()
    };

    crash_restart_from_start(params).await
}

#[tokio::test]
pub async fn crash_restart_from_start_proposal_and_parts() {
    let params = TestParams {
        value_payload: ValuePayload::ProposalAndParts,
        ..Default::default()
    };

    crash_restart_from_start(params).await
}

#[tokio::test]
pub async fn crash_restart_from_latest() {
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(2)
        .crash()
        // We do not reset the database so that the node can restart from the latest height
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn aggressive_pruning() {
    const HEIGHT: u64 = 15;

    let mut test = TestBuilder::<()>::new();

    // Node 1 starts with 10 voting power.
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start()
        .wait_until(2)
        .crash()
        .reset_db()
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60), // Timeout for the whole test
            TestParams {
                enable_value_sync: true, // Enable Sync
                max_retain_blocks: 10,   // Prune blocks older than 10
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn start_late() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT * 2)
        .success();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(HEIGHT * 2)
        .success();

    test.add_node()
        .with_voting_power(5)
        .start_after(1, Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(30),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn start_late_rotate_epoch_validator_set() {
    const HEIGHT: u64 = 20;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_voting_power(10)
        .with_middleware(RotateEpochValidators {
            selection_size: 2,
            epochs_limit: 5,
        })
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(10)
        .with_middleware(RotateEpochValidators {
            selection_size: 2,
            epochs_limit: 5,
        })
        .start()
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .with_voting_power(10)
        .with_middleware(RotateEpochValidators {
            selection_size: 2,
            epochs_limit: 5,
        })
        .start()
        .wait_until(HEIGHT)
        .success();

    // Add 2 full nodes with one starting late
    test.add_node()
        .full_node()
        .with_middleware(RotateEpochValidators {
            selection_size: 2,
            epochs_limit: 5,
        })
        .start()
        .wait_until(HEIGHT)
        .success();
    test.add_node()
        .full_node()
        .with_middleware(RotateEpochValidators {
            selection_size: 2,
            epochs_limit: 5,
        })
        .start_after(1, Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(30),
            TestParams {
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

```
---
### `test/tests/it/vote_rebroadcast.rs`
*2025-05-18 23:58:49 | 4 KB*
```rust
use std::time::Duration;

use malachitebft_config::ValuePayload;
use malachitebft_core_types::VoteType;

use crate::{TestBuilder, TestParams};

// NOTE: These tests are very similar to the Sync tests, with the difference that
//       all nodes have the same voting power and therefore get stuck when one of them dies.

#[tokio::test]
pub async fn crash_restart_from_start() {
    const CRASH_HEIGHT: u64 = 4;
    const HEIGHT: u64 = 10;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        // Wait until the node reaches height 4...
        .wait_until(4)
        // ...then kill it
        .crash()
        // Reset the database so that the node has to do Sync from height 1
        .reset_db()
        // After that, it waits 5 seconds before restarting the node
        .restart_after(Duration::from_secs(5))
        // Wait until the node reached the expected height
        .wait_until(HEIGHT)
        // Record a successful test for this node
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                // Enable ValueSync to allow the node to catch up to the latest height
                enable_value_sync: true,
                value_payload: ValuePayload::PartsOnly,
                ..TestParams::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn crash_restart_from_latest() {
    const HEIGHT: u64 = 10;
    const CRASH_HEIGHT: u64 = 4;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .expect_vote_rebroadcast(CRASH_HEIGHT, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT)
        .crash()
        // We do not reset the database so that the node can restart from the latest height
        .restart_after(Duration::from_secs(5))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..Default::default()
            },
        )
        .await
}

#[tokio::test]
pub async fn start_late() {
    const HEIGHT: u64 = 5;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .start()
        .wait_until(1)
        .expect_vote_rebroadcast(1, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start()
        .wait_until(1)
        .expect_vote_rebroadcast(1, 0, VoteType::Prevote)
        .wait_until(HEIGHT)
        .success();

    test.add_node()
        .start_after(1, Duration::from_secs(10))
        .wait_until(HEIGHT)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                // Enable ValueSync to allow the node to catch up to the latest height
                enable_value_sync: true,
                ..Default::default()
            },
        )
        .await
}

```
---
### `test/tests/it/wal.rs`
*2025-05-18 23:58:49 | 13 KB*
```rust
use std::time::Duration;

use eyre::bail;
use tracing::info;

use informalsystems_malachitebft_test::{self as malachitebft_test};

use malachitebft_config::ValuePayload;
use malachitebft_core_consensus::LocallyProposedValue;
use malachitebft_core_types::SignedVote;
use malachitebft_engine::util::events::Event;
use malachitebft_test::TestContext;

use crate::middlewares::{ByzantineProposer, PrevoteNil};
use crate::{HandlerResult, TestBuilder, TestParams};

#[tokio::test]
async fn proposer_crashes_after_proposing_parts_only() {
    proposer_crashes_after_proposing(TestParams {
        value_payload: ValuePayload::PartsOnly,
        ..TestParams::default()
    })
    .await
}

#[tokio::test]
async fn proposer_crashes_after_proposing_proposal_and_parts() {
    proposer_crashes_after_proposing(TestParams {
        value_payload: ValuePayload::ProposalAndParts,
        ..TestParams::default()
    })
    .await
}

#[tokio::test]
#[ignore]
async fn proposer_crashes_after_proposing_proposal_only() {
    proposer_crashes_after_proposing(TestParams {
        value_payload: ValuePayload::ProposalOnly,
        ..TestParams::default()
    })
    .await
}

async fn proposer_crashes_after_proposing(params: TestParams) {
    #[derive(Clone, Debug, Default)]
    struct State {
        first_proposed_value: Option<LocallyProposedValue<TestContext>>,
    }

    const CRASH_HEIGHT: u64 = 3;

    let mut test = TestBuilder::<State>::new();

    test.add_node().with_voting_power(10).start().success();
    test.add_node().with_voting_power(10).start().success();

    test.add_node()
        .with_voting_power(40)
        .start()
        .wait_until(CRASH_HEIGHT)
        // Wait until this node proposes a value
        .on_event(|event, state| match event {
            Event::ProposedValue(value) => {
                info!("Proposer proposed block: {:?}", value.value);
                state.first_proposed_value = Some(value);
                Ok(HandlerResult::ContinueTest)
            }
            _ => Ok(HandlerResult::WaitForNextEvent),
        })
        // Crash right after
        .crash()
        // Restart after 5 seconds
        .restart_after(Duration::from_secs(5))
        // Check that we replay messages from the WAL
        .expect_wal_replay(CRASH_HEIGHT)
        // Wait until it proposes a value again, while replaying WAL
        // Check that it is the same value as the first time
        .on_proposed_value(|value, state| {
            let Some(first_value) = state.first_proposed_value.as_ref() else {
                bail!("Proposer did not propose a block");
            };

            if first_value.value == value.value {
                info!("Proposer re-proposed the same block: {:?}", value.value);
                Ok(HandlerResult::ContinueTest)
            } else {
                bail!(
                    "Proposer just equivocated: expected {:?}, got {:?}",
                    first_value.value,
                    value.value
                )
            }
        })
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..params
            },
        )
        .await
}

#[tokio::test]
#[ignore] // NOTE: To re-enable once #997 is merged
async fn non_proposer_crashes_after_voting_parts_only() {
    non_proposer_crashes_after_voting(TestParams {
        value_payload: ValuePayload::PartsOnly,
        ..TestParams::default()
    })
    .await
}

#[tokio::test]
#[ignore] // NOTE: To re-enable once #997 is merged
async fn non_proposer_crashes_after_voting_proposal_and_parts() {
    non_proposer_crashes_after_voting(TestParams {
        value_payload: ValuePayload::ProposalAndParts,
        ..TestParams::default()
    })
    .await
}

#[tokio::test]
#[ignore] // NOTE: The test application does not support proposal-only mode yet
async fn non_proposer_crashes_after_voting_proposal_only() {
    non_proposer_crashes_after_voting(TestParams {
        value_payload: ValuePayload::ProposalOnly,
        ..TestParams::default()
    })
    .await
}

async fn non_proposer_crashes_after_voting(params: TestParams) {
    #[derive(Clone, Debug, Default)]
    struct State {
        first_vote: Option<SignedVote<TestContext>>,
    }

    const CRASH_HEIGHT: u64 = 2;

    let mut test = TestBuilder::<State>::new();

    test.add_node()
        .with_voting_power(40)
        .start()
        .wait_until(CRASH_HEIGHT)
        // Wait until this node proposes a value
        .on_vote(|vote, state| {
            info!("Non-proposer voted");
            state.first_vote = Some(vote);

            Ok(HandlerResult::ContinueTest)
        })
        // Crash right after
        .crash()
        // Restart after 5 seconds
        .restart_after(Duration::from_secs(5))
        // Check that we replay messages from the WAL
        .expect_wal_replay(CRASH_HEIGHT)
        // Wait until the previous vote is replayed
        // Check that it is the for the same value as the first time
        .on_vote(|vote, state| {
            let Some(first_vote) = state.first_vote.as_ref() else {
                bail!("Non-proposer did not vote")
            };

            if first_vote.value == vote.value {
                info!("Non-proposer voted the same way: {first_vote:?}");
                Ok(HandlerResult::ContinueTest)
            } else {
                bail!(
                    "Non-proposer just equivocated: expected {:?}, got {:?}",
                    first_vote.value,
                    vote.value
                )
            }
        })
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node().with_voting_power(10).start().success();
    test.add_node().with_voting_power(10).start().success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: false,
                ..params
            },
        )
        .await
}

#[tokio::test]
#[ignore]
async fn restart_with_byzantine_proposer_1_parts_only() {
    byzantine_proposer_crashes_after_proposing_1(TestParams {
        value_payload: ValuePayload::PartsOnly,
        ..TestParams::default()
    })
    .await
}

#[tokio::test]
#[ignore]
async fn restart_with_byzantine_proposer_1_proposal_and_parts() {
    byzantine_proposer_crashes_after_proposing_1(TestParams {
        value_payload: ValuePayload::ProposalAndParts,
        ..TestParams::default()
    })
    .await
}

async fn byzantine_proposer_crashes_after_proposing_1(params: TestParams) {
    #[derive(Clone, Debug, Default)]
    struct State {
        first_proposed_value: Option<LocallyProposedValue<TestContext>>,
    }

    const CRASH_HEIGHT: u64 = 3;

    let mut test = TestBuilder::<State>::new();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(CRASH_HEIGHT)
        .crash()
        .restart_after(Duration::from_secs(5))
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(CRASH_HEIGHT)
        .crash()
        .restart_after(Duration::from_secs(5))
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node()
        .with_voting_power(10)
        .with_middleware(ByzantineProposer)
        .start()
        .wait_until(CRASH_HEIGHT)
        // Wait until this node proposes a value
        .on_event(|event, state| match event {
            Event::ProposedValue(value) => {
                info!("Proposer proposed block: {:?}", value.value);
                state.first_proposed_value = Some(value);
                Ok(HandlerResult::ContinueTest)
            }
            _ => Ok(HandlerResult::WaitForNextEvent),
        })
        // Crash right after
        .crash()
        // Restart after 5 seconds
        .restart_after(Duration::from_secs(5))
        // Check that we replay messages from the WAL
        .expect_wal_replay(CRASH_HEIGHT)
        // Wait until it proposes a value again, while replaying WAL
        .on_proposed_value(|value, state| {
            let Some(first_value) = state.first_proposed_value.as_ref() else {
                bail!("Proposer did not propose a block");
            };

            if first_value.value == value.value {
                bail!(
                    "Byzantine proposer unexpectedly re-proposed the same value: {:?}",
                    value.value
                );
            }

            info!(
                "As per the test, the proposer just equivocated: expected {:?}, got {:?}",
                first_value.value, value.value
            );

            Ok(HandlerResult::ContinueTest)
        })
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(60),
            TestParams {
                enable_value_sync: true,
                ..params
            },
        )
        .await
}

#[tokio::test]
#[ignore]
async fn restart_with_byzantine_proposer_2_parts_only() {
    byzantine_proposer_crashes_after_proposing_2(TestParams {
        value_payload: ValuePayload::PartsOnly,
        ..TestParams::default()
    })
    .await
}

#[tokio::test]
#[ignore]
async fn restart_with_byzantine_proposer_2_proposal_and_parts() {
    byzantine_proposer_crashes_after_proposing_2(TestParams {
        value_payload: ValuePayload::ProposalAndParts,
        ..TestParams::default()
    })
    .await
}

async fn byzantine_proposer_crashes_after_proposing_2(params: TestParams) {
    #[derive(Clone, Debug, Default)]
    struct State {
        first_proposed_value: Option<LocallyProposedValue<TestContext>>,
        first_vote: Option<SignedVote<TestContext>>,
    }

    const CRASH_HEIGHT: u64 = 3;

    let mut test = TestBuilder::<State>::new();
    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(CRASH_HEIGHT)
        .crash()
        .restart_after(Duration::from_secs(6))
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node()
        .with_voting_power(10)
        .start()
        .wait_until(CRASH_HEIGHT)
        .on_vote(|vote, state| {
            info!("Non-proposer voted");
            state.first_vote = Some(vote);

            Ok(HandlerResult::ContinueTest)
        })
        // Crash right after
        .crash()
        .restart_after(Duration::from_secs(5))
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node()
        .with_voting_power(10)
        .with_middleware(ByzantineProposer)
        .start()
        .wait_until(CRASH_HEIGHT)
        // Wait until this node proposes a value
        .on_event(|event, state| match event {
            Event::ProposedValue(value) => {
                info!("Proposer proposed block: {:?}", value.value);
                state.first_proposed_value = Some(value);

                Ok(HandlerResult::ContinueTest)
            }
            _ => Ok(HandlerResult::WaitForNextEvent),
        })
        // Crash right after
        .crash()
        // Restart after 5 seconds
        .restart_after(Duration::from_secs(5))
        // Check that we replay messages from the WAL
        .expect_wal_replay(CRASH_HEIGHT)
        // Wait until it proposes a value again, while replaying WAL
        .on_proposed_value(|value, state| {
            let Some(first_value) = state.first_proposed_value.as_ref() else {
                bail!("Proposer did not propose a block");
            };

            if first_value.value == value.value {
                bail!(
                    "Byzantine proposer unexpectedly re-proposed the same value: {:?}",
                    value.value
                );
            }

            info!(
                "As per the test, the proposer just equivocated: expected {:?}, got {:?}",
                first_value.value, value.value
            );

            Ok(HandlerResult::ContinueTest)
        })
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.build()
        .run_with_params(Duration::from_secs(60), params)
        .await
}

#[tokio::test]
async fn multi_rounds() {
    wal_multi_rounds(TestParams::default()).await
}

async fn wal_multi_rounds(params: TestParams) {
    const CRASH_HEIGHT: u64 = 1;

    let mut test = TestBuilder::<()>::new();

    test.add_node()
        .with_middleware(PrevoteNil::when(|_, round, _| round.as_i64() <= 3))
        .start()
        .wait_until(CRASH_HEIGHT)
        .wait_until_round(3)
        .crash()
        .restart_after(Duration::from_secs(10))
        .expect_wal_replay(CRASH_HEIGHT)
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.add_node()
        .start()
        .wait_until(CRASH_HEIGHT + 2)
        .success();

    test.build()
        .run_with_params(
            Duration::from_secs(120),
            TestParams {
                enable_value_sync: false,
                ..params
            },
        )
        .await
}

```
---
### `test/tests/unit/certificates/commit.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use malachitebft_core_types::CommitCertificate;

use super::{make_validators, types::*, CertificateBuilder, CertificateTest, DEFAULT_SEED};

pub struct Commit;

impl CertificateBuilder for Commit {
    type Certificate = CommitCertificate<TestContext>;

    fn build_certificate(
        height: Height,
        round: Round,
        value_id: ValueId,
        votes: Vec<SignedVote<TestContext>>,
    ) -> Self::Certificate {
        CommitCertificate::new(height, round, value_id, votes)
    }

    fn verify_certificate(
        ctx: &TestContext,
        signer: &Ed25519Provider,
        certificate: &Self::Certificate,
        validator_set: &ValidatorSet,
        threshold_params: ThresholdParams,
    ) -> Result<(), CertificateError<TestContext>> {
        signer.verify_commit_certificate(ctx, certificate, validator_set, threshold_params)
    }

    fn make_vote(
        ctx: &TestContext,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        validator_address: Address,
    ) -> Vote {
        ctx.new_precommit(height, round, value_id, validator_address)
    }
}

/// Tests the verification of a valid CommitCertificate with signatures from validators
/// representing more than 2/3 of the total voting power.
#[test]
fn valid_commit_certificate_with_sufficient_voting_power() {
    CertificateTest::<Commit>::new()
        .with_validators([20, 20, 30, 30])
        .with_signatures(0..4)
        .expect_valid();

    CertificateTest::<Commit>::new()
        .with_validators([20, 20, 30, 30])
        .with_signatures(0..3)
        .expect_valid();
}

/// Tests the verification of a certificate with signatures from validators
/// representing exactly the threshold amount of voting power.
#[test]
fn valid_commit_certificate_with_exact_threshold_voting_power() {
    CertificateTest::<Commit>::new()
        .with_validators([21, 22, 24, 30])
        .with_signatures(0..3)
        .expect_valid();

    CertificateTest::<Commit>::new()
        .with_validators([21, 22, 24, 0])
        .with_signatures(0..3)
        .expect_valid();
}

/// Tests the verification of a certificate with valid signatures but insufficient voting power.
#[test]
fn invalid_commit_certificate_insufficient_voting_power() {
    CertificateTest::<Commit>::new()
        .with_validators([10, 20, 30, 40])
        .with_signatures(0..3)
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 60,
            total: 100,
            expected: 67,
        });

    CertificateTest::<Commit>::new()
        .with_validators([10, 10, 30, 50])
        .with_signatures(0..2)
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 100,
            expected: 67,
        });

    CertificateTest::<Commit>::new()
        .with_validators([10, 10, 30, 50])
        .with_signatures(0..4)
        .all_vote_nil()
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 0,
            total: 100,
            expected: 67,
        });
}

/// Tests the verification of a certificate containing multiple votes from the same validator.
#[test]
fn invalid_commit_certificate_duplicate_validator_vote() {
    let validator_addr = {
        let (validators, _) = make_validators([10, 10, 10, 10], DEFAULT_SEED);
        validators[0].address
    };

    CertificateTest::<Commit>::new()
        .with_validators([10, 10, 10, 10])
        .with_signatures(0..4)
        .with_duplicate_vote(0) // Add duplicate vote from validator 0
        .expect_error(CertificateError::DuplicateVote(validator_addr));
}

/// Tests the verification of a certificate containing a vote from a validator not in the validator set.
#[test]
fn invalid_commit_certificate_unknown_validator() {
    // Define the seed for generating the other validator twice
    let seed = 0xcafecafe;

    let external_validator_addr = {
        let ([validator], _) = make_validators([0], seed);
        validator.address
    };

    CertificateTest::<Commit>::new()
        .with_validators([10, 10, 10, 10])
        .with_signatures(0..4)
        .with_external_vote(seed)
        .expect_error(CertificateError::UnknownValidator(external_validator_addr));
}

/// Tests the verification of a certificate containing a vote with an invalid signature.
#[test]
fn invalid_commit_certificate_invalid_signature_1() {
    CertificateTest::<Commit>::new()
        .with_validators([10, 10, 10])
        .with_signatures(0..3)
        .with_invalid_signature(0) // Validator 0 has invalid signature
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 30,
            expected: 21,
        });
}

/// Tests the verification of a certificate containing a vote with an invalid signature.
#[test]
fn invalid_commit_certificate_invalid_signature_2() {
    CertificateTest::<Commit>::new()
        .with_validators([10, 10, 10])
        .with_signatures(0..3)
        .with_invalid_signature(0) // Replace signature for validator 0
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 30,
            expected: 21,
        });
}

/// Tests the verification of a certificate with no votes.
#[test]
fn empty_commit_certificate() {
    CertificateTest::<Commit>::new()
        .with_validators([1, 1, 1])
        .with_signatures([]) // No signatures
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 0,
            total: 3,
            expected: 3,
        });
}

/// Tests the verification of a certificate containing both valid and invalid votes.
#[test]
fn commit_certificate_with_mixed_valid_and_invalid_votes() {
    CertificateTest::<Commit>::new()
        .with_validators([10, 20, 30, 40])
        .with_signatures(0..4)
        .with_invalid_signature(0) // Invalid signature for validator 0
        .with_invalid_signature(1) // Invalid signature for validator 1
        .expect_valid();

    CertificateTest::<Commit>::new()
        .with_validators([10, 20, 30, 40])
        .with_signatures(0..4)
        .with_invalid_signature(2) // Invalid signature for validator 2
        .with_invalid_signature(3) // Invalid signature for validator 3
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 30,
            total: 100,
            expected: 67,
        });
}

```
---
### `test/tests/unit/certificates/mod.rs`
*2025-05-18 23:58:49 | 11 KB*
```rust
#![allow(dead_code)]

mod commit;
mod polka;

use std::marker::PhantomData;

pub mod types {
    pub use informalsystems_malachitebft_test::{
        utils, Address, Ed25519Provider, Height, TestContext, Validator, ValidatorSet, ValueId,
        Vote,
    };
    pub use malachitebft_core_types::{
        CertificateError, Context, NilOrVal, Round, SignedVote, SigningProvider,
        SigningProviderExt, ThresholdParams, VotingPower,
    };
    pub use malachitebft_signing_ed25519::Signature;
}

use types::*;

const DEFAULT_SEED: u64 = 0xfeedbeef;

pub fn make_validators<const N: usize>(
    voting_powers: [VotingPower; N],
    seed: u64,
) -> ([Validator; N], [Ed25519Provider; N]) {
    let (validators, private_keys): (Vec<_>, Vec<_>) =
        utils::validators::make_validators_seeded(voting_powers, seed)
            .into_iter()
            .map(|(v, pk)| (v, Ed25519Provider::new(pk)))
            .unzip();

    (
        validators.try_into().unwrap(),
        private_keys.try_into().unwrap(),
    )
}

pub enum VoteSpec {
    Normal {
        validator_idx: usize,
        is_nil: bool,
        invalid_signature: bool,
        invalid_height: bool,
        invalid_round: bool,
    },
    Duplicate {
        validator_idx: usize,
    },
}

pub trait CertificateBuilder {
    type Certificate;

    fn build_certificate(
        height: Height,
        round: Round,
        value_id: ValueId,
        votes: Vec<SignedVote<TestContext>>,
    ) -> Self::Certificate;

    fn verify_certificate(
        ctx: &TestContext,
        signer: &Ed25519Provider,
        certificate: &Self::Certificate,
        validator_set: &ValidatorSet,
        threshold_params: ThresholdParams,
    ) -> Result<(), CertificateError<TestContext>>;

    fn make_vote(
        ctx: &TestContext,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        validator_address: Address,
    ) -> Vote;
}

/// A fluent builder for certificate testing
pub struct CertificateTest<C> {
    ctx: TestContext,
    height: Height,
    round: Round,
    value_id: ValueId,
    validators: Vec<Validator>,
    signers: Vec<Ed25519Provider>,
    vote_specs: Vec<VoteSpec>,
    external_votes: Vec<SignedVote<TestContext>>,
    marker: PhantomData<C>,
}

impl<C> CertificateTest<C>
where
    C: CertificateBuilder,
{
    /// Create a new certificate test with default settings
    pub fn new() -> Self {
        Self {
            ctx: TestContext::new(),
            height: Height::new(1),
            round: Round::new(0),
            value_id: ValueId::new(42),
            validators: Vec::new(),
            signers: Vec::new(),
            vote_specs: Vec::new(),
            external_votes: Vec::new(),
            marker: PhantomData,
        }
    }

    /// Set the height for the certificate
    pub fn with_height(mut self, height: u64) -> Self {
        self.height = Height::new(height);
        self
    }

    /// Set the round for the certificate
    pub fn with_round(mut self, round: i64) -> Self {
        self.round = Round::from(round);
        self
    }

    /// Set the value ID for the certificate
    pub fn for_value(mut self, value_id: u64) -> Self {
        self.value_id = ValueId::new(value_id);
        self
    }

    /// Set up validators with the given voting powers using default seed
    pub fn with_validators<const N: usize>(self, voting_powers: [VotingPower; N]) -> Self {
        self.with_validators_seeded(voting_powers, DEFAULT_SEED)
    }

    /// Set up validators with the given voting powers and seed
    pub fn with_validators_seeded<const N: usize>(
        mut self,
        voting_powers: [VotingPower; N],
        seed: u64,
    ) -> Self {
        let (validators, signers) = make_validators(voting_powers, seed);
        self.validators = Vec::from(validators);
        self.signers = Vec::from(signers);
        self
    }

    /// Specify which validators should sign the certificate
    pub fn with_signatures(mut self, indices: impl IntoIterator<Item = usize>) -> Self {
        for idx in indices {
            if idx < self.validators.len() {
                self.vote_specs.push(VoteSpec::Normal {
                    validator_idx: idx,
                    is_nil: false,
                    invalid_signature: false,
                    invalid_height: false,
                    invalid_round: false,
                });
            }
        }
        self
    }

    pub fn with_invalid_vote_height(mut self, index: usize) -> Self {
        if index < self.validators.len() {
            self.vote_specs.push(VoteSpec::Normal {
                validator_idx: index,
                is_nil: false,
                invalid_signature: false,
                invalid_height: true,
                invalid_round: false,
            });
        }
        self
    }

    pub fn with_invalid_vote_round(mut self, index: usize) -> Self {
        if index < self.validators.len() {
            self.vote_specs.push(VoteSpec::Normal {
                validator_idx: index,
                is_nil: false,
                invalid_signature: false,
                invalid_height: false,
                invalid_round: true,
            });
        }
        self
    }

    /// Add a duplicate vote from the specified validator index
    pub fn with_duplicate_vote(mut self, index: usize) -> Self {
        if index < self.validators.len() {
            self.vote_specs.push(VoteSpec::Duplicate {
                validator_idx: index,
            });
        }
        self
    }

    /// Make all validators vote for nil instead of the value
    pub fn all_vote_nil(mut self) -> Self {
        for spec in &mut self.vote_specs {
            if let VoteSpec::Normal { is_nil, .. } = spec {
                *is_nil = true;
            }
        }
        self
    }

    /// Specify that a validator's signature should be invalid
    pub fn with_invalid_signature(mut self, index: usize) -> Self {
        for spec in &mut self.vote_specs {
            if let VoteSpec::Normal {
                validator_idx,
                invalid_signature,
                ..
            } = spec
            {
                if *validator_idx == index {
                    *invalid_signature = true;
                }
            }
        }
        self
    }

    /// Add a vote from an external validator
    pub fn with_external_vote(mut self, seed: u64) -> Self {
        let ([validator], [signer]) = make_validators([0], seed);
        let vote = signer.sign_vote(C::make_vote(
            &self.ctx,
            self.height,
            self.round,
            NilOrVal::Val(self.value_id),
            validator.address,
        ));
        self.external_votes.push(vote);
        self
    }

    /// Build the certificate based on the configured settings
    fn build_certificate(&self) -> (C::Certificate, ValidatorSet) {
        let validator_set = ValidatorSet::new(self.validators.clone());

        let mut votes = Vec::new();

        // Process each vote specification
        for spec in &self.vote_specs {
            match spec {
                VoteSpec::Normal {
                    validator_idx,
                    is_nil,
                    invalid_signature,
                    invalid_height,
                    invalid_round,
                } => {
                    let value = if *is_nil {
                        NilOrVal::Nil
                    } else {
                        NilOrVal::Val(self.value_id)
                    };

                    let height = if *invalid_height {
                        self.height.increment()
                    } else {
                        self.height
                    };

                    let round = if *invalid_round {
                        self.round.increment()
                    } else {
                        self.round
                    };

                    let mut vote = self.signers[*validator_idx].sign_vote(C::make_vote(
                        &self.ctx,
                        height,
                        round,
                        value,
                        self.validators[*validator_idx].address,
                    ));

                    if *invalid_signature {
                        vote.signature = Signature::test();
                    }

                    votes.push(vote);
                }
                VoteSpec::Duplicate { validator_idx } => {
                    // For a duplicate, we just create another vote from the same validator
                    let vote = self.signers[*validator_idx].sign_vote(C::make_vote(
                        &self.ctx,
                        self.height,
                        self.round,
                        NilOrVal::Val(self.value_id),
                        self.validators[*validator_idx].address,
                    ));

                    votes.push(vote);
                }
            }
        }

        // Add external votes
        votes.extend(self.external_votes.clone());

        let certificate = C::build_certificate(self.height, self.round, self.value_id, votes);
        (certificate, validator_set)
    }

    /// Verify that the certificate is valid
    pub fn expect_valid(self) {
        let (certificate, validator_set) = self.build_certificate();

        for signer in &self.signers {
            let result = C::verify_certificate(
                &self.ctx,
                signer,
                &certificate,
                &validator_set,
                ThresholdParams::default(),
            );

            assert!(
                result.is_ok(),
                "Expected valid certificate, but got error: {:?}",
                result.unwrap_err()
            );
        }
    }

    /// Verify that the certificate is invalid with the expected error
    pub fn expect_error(self, expected_error: CertificateError<TestContext>) {
        let (certificate, validator_set) = self.build_certificate();

        for signer in &self.signers {
            let result = C::verify_certificate(
                &self.ctx,
                signer,
                &certificate,
                &validator_set,
                ThresholdParams::default(),
            );

            assert_eq!(
                result.as_ref(),
                Err(&expected_error),
                "Expected certificate error {expected_error:?}, but got: {result:?}",
            );
        }
    }
}

```
---
### `test/tests/unit/certificates/polka.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use malachitebft_core_types::PolkaCertificate;

use super::{make_validators, types::*, CertificateBuilder, CertificateTest, DEFAULT_SEED};

pub struct Polka;

impl CertificateBuilder for Polka {
    type Certificate = PolkaCertificate<TestContext>;

    fn build_certificate(
        height: Height,
        round: Round,
        value_id: ValueId,
        votes: Vec<SignedVote<TestContext>>,
    ) -> Self::Certificate {
        PolkaCertificate::new(height, round, value_id, votes)
    }

    fn verify_certificate(
        ctx: &TestContext,
        signer: &Ed25519Provider,
        certificate: &Self::Certificate,
        validator_set: &ValidatorSet,
        threshold_params: ThresholdParams,
    ) -> Result<(), CertificateError<TestContext>> {
        signer.verify_polka_certificate(ctx, certificate, validator_set, threshold_params)
    }

    fn make_vote(
        ctx: &TestContext,
        height: Height,
        round: Round,
        value_id: NilOrVal<ValueId>,
        validator_address: Address,
    ) -> Vote {
        ctx.new_prevote(height, round, value_id, validator_address)
    }
}

/// Tests the verification of a valid PolkaCertificate with signatures from validators
/// representing more than 2/3 of the total voting power.
#[test]
fn valid_polka_certificate_with_sufficient_voting_power() {
    CertificateTest::<Polka>::new()
        .with_validators([20, 20, 30, 30])
        .with_signatures(0..4)
        .expect_valid();

    CertificateTest::<Polka>::new()
        .with_validators([20, 20, 30, 30])
        .with_signatures(0..3)
        .expect_valid();
}

/// Tests the verification of a certificate with signatures from validators
/// representing exactly the threshold amount of voting power.
#[test]
fn valid_polka_certificate_with_exact_threshold_voting_power() {
    CertificateTest::<Polka>::new()
        .with_validators([21, 22, 24, 30])
        .with_signatures(0..3)
        .expect_valid();

    CertificateTest::<Polka>::new()
        .with_validators([21, 22, 24, 0])
        .with_signatures(0..3)
        .expect_valid();
}

/// Tests the verification of a certificate with valid signatures but insufficient voting power.
#[test]
fn invalid_polka_certificate_insufficient_voting_power() {
    CertificateTest::<Polka>::new()
        .with_validators([10, 20, 30, 40])
        .with_signatures(0..3)
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 60,
            total: 100,
            expected: 67,
        });

    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 30, 50])
        .with_signatures(0..2)
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 100,
            expected: 67,
        });

    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 30, 50])
        .with_signatures(0..4)
        .all_vote_nil()
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 0,
            total: 100,
            expected: 67,
        });
}

/// Tests the verification of a certificate containing multiple votes from the same validator.
#[test]
fn invalid_polka_certificate_duplicate_validator_vote() {
    let validator_addr = {
        let (validators, _) = make_validators([10, 10, 10, 10], DEFAULT_SEED);
        validators[0].address
    };

    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 10, 10])
        .with_signatures(0..4)
        .with_duplicate_vote(0) // Add duplicate vote from validator 0
        .expect_error(CertificateError::DuplicateVote(validator_addr));
}

/// Tests the verification of a certificate containing a vote from a validator not in the validator set.
#[test]
fn invalid_polka_certificate_unknown_validator() {
    // Define the seed for generating the other validator twice
    let seed = 0xcafecafe;

    let external_validator_addr = {
        let ([validator], _) = make_validators([0], seed);
        validator.address
    };

    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 10, 10])
        .with_signatures(0..4)
        .with_external_vote(seed)
        .expect_error(CertificateError::UnknownValidator(external_validator_addr));
}

/// Tests the verification of a certificate containing a vote with an invalid signature.
#[test]
fn invalid_polka_certificate_invalid_signature() {
    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 10])
        .with_signatures(0..3)
        .with_invalid_signature(0) // Validator 0 has invalid signature
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 30,
            expected: 21,
        });
}

/// Tests the verification of a certificate containing a vote with an invalid signature.
#[test]
fn invalid_polka_certificate_wrong_vote_height_round() {
    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 10])
        .with_signatures(0..2)
        .with_invalid_vote_height(2) // Validator 2 has invalid vote height
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 30,
            expected: 21,
        });

    CertificateTest::<Polka>::new()
        .with_validators([10, 10, 10])
        .with_signatures(0..2)
        .with_invalid_vote_round(2) // Validator 2 has invalid vote round
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 20,
            total: 30,
            expected: 21,
        });
}

/// Tests the verification of a certificate with no votes.
#[test]
fn empty_polka_certificate() {
    CertificateTest::<Polka>::new()
        .with_validators([1, 1, 1])
        .with_signatures([]) // No signatures
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 0,
            total: 3,
            expected: 3,
        });
}

/// Tests the verification of a certificate containing both valid and invalid votes.
#[test]
fn polka_certificate_with_mixed_valid_and_invalid_votes() {
    CertificateTest::<Polka>::new()
        .with_validators([10, 20, 30, 40])
        .with_signatures(0..4)
        .with_invalid_signature(0) // Invalid signature for validator 0
        .with_invalid_signature(1) // Invalid signature for validator 1
        .expect_valid();

    CertificateTest::<Polka>::new()
        .with_validators([10, 20, 30, 40])
        .with_signatures(0..4)
        .with_invalid_signature(2) // Invalid signature for validator 2
        .with_invalid_signature(3) // Invalid signature for validator 3
        .expect_error(CertificateError::NotEnoughVotingPower {
            signed: 30,
            total: 100,
            expected: 67,
        });
}

```
---
### `test/tests/unit/main.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
mod certificates;

```
---
### `wal/Cargo.toml`
*2025-05-18 23:58:49 | 1 KB*
```toml
[package]
name = "informalsystems-malachitebft-wal"
description = "Write-Ahead Log for for the Malachite BFT consensus engine"
version.workspace = true
edition.workspace = true
repository.workspace = true
license.workspace = true
rust-version.workspace = true
publish.workspace = true
readme = "../../../README.md"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[[bench]]
name = "wal"
harness = false

[features]
compression = ["dep:lz4_flex"]
force-compression = ["compression"]

[dependencies]
cfg-if = "1"
advisory-lock = "0.3.0"
bytes = "1.10.0"
crc32fast = "1.4.0"
lz4_flex = { version = "0.11.0", optional = true }

[dev-dependencies]
criterion = "0.5.1"
nix = { version = "0.29.0", features = ["signal"] }
rand = "0.8.5"
tempfile = "3.19.1"
testdir = "0.9.1"

```
---
### `wal/benches/wal.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use std::fs;
use std::path::PathBuf;

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use tempfile::tempdir;

use informalsystems_malachitebft_wal::Log;

/// Benchmark configuration
struct BenchConfig {
    entry_size: usize,
    batch_size: usize,
    sync_interval: usize,
}

impl BenchConfig {
    fn total_size(&self) -> usize {
        self.entry_size * self.batch_size
    }
}

fn wal_benchmarks(c: &mut Criterion) {
    let dir = tempdir().unwrap();

    // Different entry sizes to test
    let entry_sizes = vec![
        64,          // Small entries
        1024,        // 1 KB
        16 * 1024,   // 16 KB
        256 * 1024,  // 256 KB
        1024 * 1024, // 1 MB
    ];

    // Read benchmarks
    let mut read_group = c.benchmark_group("wal_read");

    // Benchmark reading different entry sizes
    for size in &entry_sizes {
        let config = BenchConfig {
            entry_size: *size,
            batch_size: 1000,
            sync_interval: 100,
        };

        read_group.throughput(Throughput::Bytes(config.total_size() as u64));
        read_group.bench_with_input(BenchmarkId::new("sequential_read", size), size, |b, _| {
            let path = get_temp_wal_path(&dir);
            setup_wal_for_reading(&path, &config);
            b.iter(|| bench_sequential_read(&path));
            fs::remove_file(path).unwrap();
        });
    }
    read_group.finish();

    // Write benchmarks
    let mut write_group = c.benchmark_group("wal_write");

    // Benchmark writing different entry sizes
    for size in &entry_sizes {
        let config = BenchConfig {
            entry_size: *size,
            batch_size: 1000,
            sync_interval: 100,
        };

        write_group.throughput(Throughput::Bytes(config.total_size() as u64));
        write_group.bench_with_input(BenchmarkId::new("sequential_write", size), size, |b, _| {
            let path = get_temp_wal_path(&dir);
            b.iter(|| bench_sequential_write(&path, &config));
        });
    }

    // Benchmark different batch sizes
    let batch_sizes = vec![1, 10, 100, 1000, 10000];

    for batch_size in &batch_sizes {
        let config = BenchConfig {
            entry_size: 1024,
            batch_size: *batch_size,
            sync_interval: *batch_size,
        };

        write_group.throughput(Throughput::Bytes(config.total_size() as u64));
        write_group.bench_with_input(
            BenchmarkId::new("batch_write", batch_size),
            batch_size,
            |b, _| {
                let path = get_temp_wal_path(&dir);
                b.iter(|| bench_batch_write(&path, &config));
            },
        );
    }

    // Benchmark different sync intervals
    let sync_intervals = vec![1, 10, 100, 1000];

    for interval in &sync_intervals {
        let config = BenchConfig {
            entry_size: 1024,
            batch_size: 1000,
            sync_interval: *interval,
        };

        write_group.throughput(Throughput::Bytes(config.total_size() as u64));
        write_group.bench_with_input(
            BenchmarkId::new("sync_interval", interval),
            interval,
            |b, &_| {
                let path = get_temp_wal_path(&dir);
                b.iter(|| bench_sync_interval(&path, &config));
            },
        );
    }

    // // Mixed read/write benchmarks
    // let mut mixed_group = c.benchmark_group("wal_mixed");
    //
    // mixed_group.finish();
}

/// Helper function to get a unique WAL path
fn get_temp_wal_path(dir: &tempfile::TempDir) -> PathBuf {
    use std::sync::atomic::{AtomicUsize, Ordering};
    static COUNTER: AtomicUsize = AtomicUsize::new(0);
    let id = COUNTER.fetch_add(1, Ordering::SeqCst);
    dir.path().join(format!("bench_{}.wal", id))
}

/// Benchmark sequential writes
fn bench_sequential_write(path: &PathBuf, config: &BenchConfig) {
    let mut wal = Log::open(path).unwrap();
    let data = vec![0u8; config.entry_size];

    for i in 0..config.batch_size {
        wal.append(&data).unwrap();
        if i % config.sync_interval == 0 {
            wal.flush().unwrap();
        }
    }

    fs::remove_file(path).unwrap()
}

/// Benchmark sequential reads
fn bench_sequential_read(path: &PathBuf) {
    let mut wal = Log::open(path).unwrap();
    black_box(wal.iter().unwrap().collect::<Result<Vec<_>, _>>().unwrap());
}

/// Setup WAL with data for reading benchmarks
fn setup_wal_for_reading(path: &PathBuf, config: &BenchConfig) {
    let mut wal = Log::open(path).unwrap();
    let data = vec![0u8; config.entry_size];

    for i in 0..config.batch_size {
        wal.append(&data).unwrap();
        if i % config.sync_interval == 0 {
            wal.flush().unwrap();
        }
    }
}

/// Benchmark batch writes
fn bench_batch_write(path: &PathBuf, config: &BenchConfig) {
    let mut wal = Log::open(path).unwrap();
    let data = vec![0u8; config.entry_size];

    for _ in 0..config.batch_size {
        wal.append(&data).unwrap();
    }
    wal.flush().unwrap();
    fs::remove_file(path).unwrap();
}

/// Benchmark different sync intervals
fn bench_sync_interval(path: &PathBuf, config: &BenchConfig) {
    let mut wal = Log::open(path).unwrap();
    let data = vec![0u8; config.entry_size];

    for i in 0..config.batch_size {
        wal.append(&data).unwrap();
        if i % config.sync_interval == 0 {
            wal.flush().unwrap();
        }
    }
}

/// Benchmark small writes with frequent syncs
fn bench_small_writes_frequent_sync(c: &mut Criterion) {
    let mut group = c.benchmark_group("small_writes_frequent_sync");
    let dir = tempdir().unwrap();

    group.throughput(Throughput::Bytes(64 * 100));
    group.bench_function("write_sync_every", |b| {
        b.iter(|| {
            let path = get_temp_wal_path(&dir);
            let mut wal = Log::open(&path).unwrap();
            let data = vec![0u8; 64];

            for _ in 0..100 {
                wal.append(&data).unwrap();
                wal.flush().unwrap();
            }
            fs::remove_file(path).unwrap();
        });
    });

    group.finish();
}

/// Benchmark random access patterns
fn bench_random_access(c: &mut Criterion) {
    use rand::Rng;

    let mut group = c.benchmark_group("random_access");
    let dir = tempdir().unwrap();

    group.bench_function("random_sized_writes", |b| {
        b.iter(|| {
            let path = get_temp_wal_path(&dir);
            let mut wal = Log::open(&path).unwrap();
            let mut rng = rand::thread_rng();

            for _ in 0..100 {
                let size = rng.gen_range(64..4096);
                let data = vec![0u8; size];
                wal.append(&data).unwrap();
            }
            wal.flush().unwrap();
            fs::remove_file(path).unwrap();
        });
    });

    group.finish();
}

criterion_group!(
    benches,
    wal_benchmarks,
    bench_small_writes_frequent_sync,
    bench_random_access
);
criterion_main!(benches);

```
---
### `wal/src/ext.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::io::{self, Read, Write};

#[inline(always)]
pub fn read_u8<R: Read>(reader: &mut R) -> io::Result<u8> {
    let mut buf = [0; 1];
    reader.read_exact(&mut buf)?;
    Ok(buf[0])
}

#[inline(always)]
pub fn write_u8<W: Write>(writer: &mut W, value: u8) -> io::Result<()> {
    writer.write_all(&[value])
}

#[inline(always)]
pub fn read_u32<R: Read>(reader: &mut R) -> io::Result<u32> {
    let mut buf = [0; 4];
    reader.read_exact(&mut buf)?;
    Ok(u32::from_be_bytes(buf))
}

#[inline(always)]
pub fn write_u32<W: Write>(writer: &mut W, value: u32) -> io::Result<()> {
    writer.write_all(&value.to_be_bytes())
}

#[inline(always)]
pub fn read_u64<R: Read>(reader: &mut R) -> io::Result<u64> {
    let mut buf = [0; 8];
    reader.read_exact(&mut buf)?;
    Ok(u64::from_be_bytes(buf))
}

#[inline(always)]
pub fn write_u64<W: Write>(writer: &mut W, value: u64) -> io::Result<()> {
    writer.write_all(&value.to_be_bytes())
}

```
---
### `wal/src/file.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::fs::{self, File};
use std::io;
use std::path::Path;

use advisory_lock::{AdvisoryFileLock, FileLockMode};

use crate::storage::Storage;

/// Write-Ahead Log (WAL) backed by a [`File`](std::fs::File)
pub type Log = crate::log::Log<File>;

/// Write-Ahead Log (WAL) entry, backed by a [`File`](std::fs::File)
pub type LogEntry<'a> = crate::log::LogEntry<'a, File>;

/// Iterator over the WAL entries, backed by a [`File`](std::fs::File)
pub type LogIter<'a> = crate::log::LogIter<'a, File>;

impl Storage for File {
    type OpenOptions = ();

    fn open_with(path: impl AsRef<Path>, _: ()) -> io::Result<Self> {
        // Open file with read+write access, create if doesn't exist
        let file = fs::OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .truncate(false) // Don't truncate existing file
            .open(&path)?;

        AdvisoryFileLock::try_lock(&file, FileLockMode::Exclusive).map_err(|e| {
            io::Error::new(
                io::ErrorKind::Other,
                format!("Failed to acquire exclusive advisory lock: {e}"),
            )
        })?;

        Ok(file)
    }

    fn size_bytes(&self) -> io::Result<u64> {
        File::metadata(self).map(|m| m.len())
    }

    fn truncate_to(&mut self, size: u64) -> io::Result<()> {
        File::set_len(self, size)
    }

    fn sync_all(&mut self) -> io::Result<()> {
        File::sync_all(self)
    }
}

```
---
### `wal/src/lib.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
#![cfg_attr(docsrs, feature(doc_cfg))]

//! Write-Ahead Log (WAL) implementation

mod file;
mod storage;
mod version;

pub mod log;

pub use file::{Log, LogEntry, LogIter};
pub use storage::Storage;
pub use version::Version;

// For use in tests
#[doc(hidden)]
pub mod ext;

```
---
### `wal/src/log.rs`
*2025-05-18 23:58:49 | 18 KB*
```rust
//! Write-Ahead Log (WAL) implementation, generic over its backing storage.
//!
//! # Warning
//! Not for regular use, use [`crate::Log`] instead.

use std::io::{self, SeekFrom, Write};
use std::path::{Path, PathBuf};

use cfg_if::cfg_if;

use crate::ext::{read_u32, read_u64, read_u8, write_u32, write_u64, write_u8};
use crate::{Storage, Version};

/// Represents a single entry in the Write-Ahead Log (WAL).
///
/// Each entry has the following format on disk:
///
/// ```text
/// +-----------------|-----------------+----------------+-----------------+
/// |  Is compressed  |     Length      |      CRC       |      Data       |
/// |     (1 byte)    |    (4 bytes)    |   (4 bytes)    | ($length bytes) |
/// +-----------------|-----------------+----------------+-----------------+
/// ```
pub struct LogEntry<'a, S> {
    /// Reference to the parent WAL
    log: &'a mut Log<S>,
}

impl<S> LogEntry<'_, S>
where
    S: Storage,
{
    /// Reads the compression flag of the current entry
    fn read_compression_flag(&mut self) -> io::Result<bool> {
        read_u8(&mut self.log.storage).map(|byte| byte != 0)
    }

    /// Reads the length field of the current entry
    fn read_length(&mut self) -> io::Result<u64> {
        read_u64(&mut self.log.storage)
    }

    /// Reads the CRC field of the current entry
    fn read_crc(&mut self) -> io::Result<u32> {
        read_u32(&mut self.log.storage)
    }

    /// Reads the current entry's data and advances to the next entry.
    /// The entry data is written to the provided writer.
    ///
    /// # Arguments
    /// * `writer` - The writer to output the entry data to
    ///
    /// # Returns
    /// * `Ok(Some(self))` - If there are more entries to read
    /// * `Ok(None)` - If this was the last entry
    /// * `Err` - If an I/O error occurs or the CRC check fails
    pub fn read_to_next<W: Write>(mut self, writer: &mut W) -> io::Result<Option<Self>> {
        let is_compressed = self.read_compression_flag()?;
        let length = self.read_length()? as usize;
        let expected_crc = self.read_crc()?;

        let mut data = vec![0; length];
        self.log.storage.read_exact(&mut data)?;

        #[cfg(not(feature = "compression"))]
        if is_compressed {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Entry is compressed but compression is disabled",
            ));
        }

        #[cfg(feature = "compression")]
        if is_compressed {
            data = lz4_flex::decompress_size_prepended(&data).map_err(|e| {
                io::Error::new(
                    io::ErrorKind::InvalidData,
                    format!("Failed to decompress entry: {e}"),
                )
            })?;
        }

        let actual_crc = compute_crc(&data);

        if expected_crc != actual_crc {
            return Err(io::Error::new(io::ErrorKind::InvalidData, "CRC mismatch"));
        }

        writer.write_all(&data)?;

        let pos = self.log.storage.stream_position()?;
        let len = self.log.storage.size_bytes()?;

        if pos < len {
            Ok(Some(self))
        } else {
            Ok(None)
        }
    }
}

/// Write-Ahead Log (WAL)
///
/// A Write-Ahead Log is a sequential log of records that provides durability and atomicity
/// guarantees by writing changes to disk before they are applied to the main database.
///
/// # Format on disk
///
/// ```text
/// +-----------------+-----------------+-----------------+-----------------+-----------------+
/// |     Version     |     Sequence    |    Entry #1     |       ...       |     Entry #n    |
/// |    (4 bytes)    |    (8 bytes)    |    (variable)   |                 |    (variable)   |
/// +-----------------+-----------------+-----------------+-----------------+-----------------+
/// ```
#[derive(Debug)]
pub struct Log<S> {
    storage: S,
    path: PathBuf,
    version: Version,
    sequence: u64,
    len: usize,
}

const VERSION_SIZE: u64 = size_of::<Version>() as u64;
const SEQUENCE_SIZE: u64 = size_of::<u64>() as u64;
const HEADER_SIZE: u64 = VERSION_SIZE + SEQUENCE_SIZE;

const VERSION_OFFSET: u64 = 0;
const SEQUENCE_OFFSET: u64 = VERSION_OFFSET + VERSION_SIZE;
const FIRST_ENTRY_OFFSET: u64 = HEADER_SIZE;

const ENTRY_LENGTH_SIZE: u64 = size_of::<u64>() as u64;
const ENTRY_CRC_SIZE: u64 = size_of::<u32>() as u64;
const ENTRY_COMPRESSION_FLAG_SIZE: u64 = size_of::<u8>() as u64;
const ENTRY_HEADER_SIZE: u64 = ENTRY_COMPRESSION_FLAG_SIZE + ENTRY_LENGTH_SIZE + ENTRY_CRC_SIZE;

enum WriteEntry<'a> {
    Raw(&'a [u8]),

    #[cfg(feature = "compression")]
    Compressed {
        compressed: &'a [u8],
        uncompressed: &'a [u8],
    },
}

impl WriteEntry<'_> {
    fn data(&self) -> &[u8] {
        match self {
            WriteEntry::Raw(data) => data,

            #[cfg(feature = "compression")]
            WriteEntry::Compressed { compressed, .. } => compressed,
        }
    }

    fn len(&self) -> usize {
        match self {
            WriteEntry::Raw(data) => data.len(),

            #[cfg(feature = "compression")]
            WriteEntry::Compressed { compressed, .. } => compressed.len(),
        }
    }

    fn uncompressed_crc(&self) -> u32 {
        match self {
            WriteEntry::Raw(data) => compute_crc(data),

            #[cfg(feature = "compression")]
            WriteEntry::Compressed { uncompressed, .. } => compute_crc(uncompressed),
        }
    }

    fn is_compressed(&self) -> bool {
        cfg_if! {
            if #[cfg(feature = "compression")] {
                matches!(self, WriteEntry::Compressed { .. })
            } else {
                false
            }
        }
    }
}

impl<S> Log<S>
where
    S: Storage<OpenOptions = ()>,
{
    /// Opens a Write-Ahead Log file at the specified path.
    ///
    /// If the file already exists, it will be opened and validated.
    /// If the file does not exist, a new one will be created.
    ///
    /// # Arguments
    /// * `path` - Path where the WAL file should be created/opened
    ///
    /// # Returns
    /// * `Ok(Wal)` - Successfully opened/created WAL
    /// * `Err` - If file operations fail or existing WAL is invalid
    pub fn open(path: impl AsRef<Path>) -> io::Result<Self> {
        Self::open_with(path, ())
    }
}

impl<S> Log<S>
where
    S: Storage,
{
    /// Opens a Write-Ahead Log file at the specified path.
    ///
    /// If the file already exists, it will be opened and validated.
    /// If the file does not exist, a new one will be created.
    ///
    /// # Arguments
    /// * `path` - Path where the WAL file should be created/opened
    ///
    /// # Returns
    /// * `Ok(Wal)` - Successfully opened/created WAL
    /// * `Err` - If file operations fail or existing WAL is invalid
    pub fn open_with(path: impl AsRef<Path>, options: S::OpenOptions) -> io::Result<Self> {
        let path = path.as_ref().to_owned();

        let mut storage = S::open_with(&path, options)?;

        let size = storage.size_bytes()?;

        // If file exists and has content
        if size > 0 {
            // Read and validate version number
            let version = Version::try_from(read_u32(&mut storage)?)
                .map_err(|_| io::Error::new(io::ErrorKind::InvalidData, "Invalid WAL version"))?;

            // Read sequence number
            let sequence = read_u64(&mut storage).map_err(|_| {
                io::Error::new(
                    io::ErrorKind::UnexpectedEof,
                    "Failed to read sequence number",
                )
            })?;

            // Track current position and entry count
            let mut pos = FIRST_ENTRY_OFFSET; // Start after header
            let mut len = 0;

            // Scan through entries to validate and count them
            while size.saturating_sub(pos) > ENTRY_HEADER_SIZE - ENTRY_CRC_SIZE {
                // Skip over compression flag
                read_u8(&mut storage)?;

                // Read entry length
                let data_length = read_u64(&mut storage)?;

                // Calculate total entry size including CRC
                let Some(entry_length) = data_length.checked_add(ENTRY_CRC_SIZE) else {
                    break; // Integer overflow, file is corrupt
                };

                // Check if enough bytes remain for full entry
                if size.saturating_sub(pos) < entry_length {
                    break; // Partial/corrupt entry
                }

                // Skip to next entry
                pos = storage.seek(SeekFrom::Current(entry_length.try_into().unwrap()))?;
                len += 1;
            }

            // Truncate any partial entries at the end
            storage.truncate_to(pos)?;
            storage.sync_all()?;

            return Ok(Self {
                version,
                storage,
                path,
                sequence,
                len,
            });
        }

        // Creating new WAL file
        let version = Version::V1;

        // Write header: version (4 bytes)
        write_u32(&mut storage, version as u32)?;

        // Write header: sequence (8 bytes)
        write_u64(&mut storage, 0)?;

        // Ensure file is exactly header size
        storage.truncate_to(HEADER_SIZE)?;

        // Ensure header is persisted to disk
        storage.sync_all()?;

        Ok(Self {
            version,
            storage,
            path,
            sequence: 0,
            len: 0,
        })
    }

    /// Writes a new entry to the WAL.
    ///
    /// The entry is appended to the end of the log with length, CRC and data.
    /// If writing fails, the WAL is truncated to remove the partial write.
    ///
    /// If the `force-compression` feature is enabled, all entries will be compressed.
    ///
    /// # Arguments
    /// * `data` - The data to write as a new WAL entry
    ///
    /// # Returns
    /// * `Ok(())` - Entry was successfully written
    /// * `Err` - If writing fails
    pub fn append(&mut self, data: impl AsRef<[u8]>) -> io::Result<()> {
        cfg_if! {
            if #[cfg(feature = "force-compression")] {
                self.write_compressed(data)
            } else {
                self.write_raw(data)
            }
        }
    }

    /// Writes a new entry to the WAL, without compressing it.
    ///
    /// The entry is appended to the end of the log with length, CRC and data.
    /// If writing fails, the WAL is truncated to remove the partial write.
    ///
    /// # Arguments
    /// * `data` - The data to write as a new WAL entry
    ///
    /// # Returns
    /// * `Ok(())` - Entry was successfully written
    /// * `Err` - If writing fails
    pub fn write_raw(&mut self, data: impl AsRef<[u8]>) -> io::Result<()> {
        self.write_entry(WriteEntry::Raw(data.as_ref()))
    }

    /// Writes a new entry to the WAL, compressing it with the LZ4 algorithm.
    ///
    /// The entry is appended to the end of the log with length, CRC and data.
    /// If writing fails, the WAL is truncated to remove the partial write.
    ///
    /// # Arguments
    /// * `data` - The data to write as a new WAL entry
    ///
    /// # Returns
    /// * `Ok(())` - Entry was successfully written
    /// * `Err` - If writing fails
    #[cfg(feature = "compression")]
    #[cfg_attr(docsrs, doc(cfg(feature = "compression")))]
    pub fn write_compressed(&mut self, data: impl AsRef<[u8]>) -> io::Result<()> {
        let data = data.as_ref();
        let compressed = lz4_flex::compress_prepend_size(data);

        // Only use compression if it actually helps
        let entry = if compressed.len() < data.len() {
            WriteEntry::Compressed {
                compressed: &compressed,
                uncompressed: data,
            }
        } else {
            WriteEntry::Raw(data)
        };

        // Rest of write logic...
        self.write_entry(entry)
    }

    fn write_entry(&mut self, entry: WriteEntry<'_>) -> io::Result<()> {
        let pos = self.storage.seek(SeekFrom::End(0))?;

        let result = || -> io::Result<()> {
            // Write compression flag
            write_u8(&mut self.storage, entry.is_compressed() as u8)?;

            // Write length of (compressed) data
            write_u64(&mut self.storage, entry.len() as u64)?;

            // Write CRC of (uncompressed) data
            write_u32(&mut self.storage, entry.uncompressed_crc())?;

            // Write (compressed) entry data
            self.storage.write_all(entry.data())?;

            Ok(())
        }();

        match result {
            Ok(()) => {
                self.len += 1;
                Ok(())
            }
            Err(e) => {
                self.storage.truncate_to(pos)?;
                Err(e)
            }
        }
    }

    /// Returns an the first entry in the WAL if it exists.
    ///
    /// # Returns
    /// * `Ok(Some(WalEntry))` - First entry exists and was retrieved
    /// * `Ok(None)` - WAL is empty
    /// * `Err` - If reading fails or WAL is invalid
    pub fn first_entry(&mut self) -> io::Result<Option<LogEntry<S>>> {
        // IF the file is empty, return an error
        if self.storage.size_bytes()? == 0 {
            return Err(io::Error::new(io::ErrorKind::NotFound, "Empty WAL"));
        }

        // If there are no entries, return None
        if self.len == 0 {
            return Ok(None);
        }

        // Seek to the first entry after the header
        self.storage.seek(SeekFrom::Start(FIRST_ENTRY_OFFSET))?;

        Ok(Some(LogEntry { log: self }))
    }

    /// Returns an iterator over all entries in the WAL.
    ///
    /// # Returns
    /// * `Ok(LogIter)` - Iterator over WAL entries
    /// * `Err` - If reading fails
    pub fn iter(&mut self) -> io::Result<LogIter<S>> {
        Ok(LogIter {
            next: self.first_entry()?,
        })
    }

    /// Restarts the WAL with a new sequence number.
    ///
    /// This truncates all existing entries and resets the WAL to an empty state
    /// with the specified sequence number.
    ///
    /// # Arguments
    /// * `sequence` - New sequence number to start from
    ///
    /// # Returns
    /// * `Ok(())` - WAL was successfully restarted
    /// * `Err` - If file operations fail
    pub fn restart(&mut self, sequence: u64) -> io::Result<()> {
        // Reset sequence number and entry count
        self.sequence = sequence;
        self.len = 0;

        // Seek to start of sequence number
        self.storage.seek(SeekFrom::Start(SEQUENCE_OFFSET))?;

        // Write new sequence number
        write_u64(&mut self.storage, sequence)?;

        // Truncate all entries
        self.storage.truncate_to(HEADER_SIZE)?;

        // Sync changes to disk
        self.storage.sync_all()?;

        Ok(())
    }

    /// Syncs all written data to disk.
    ///
    /// On UNIX systems, this will call `fsync` to ensure all data is written to disk.
    ///
    /// # Returns
    /// * `Ok(())` - Successfully synced to disk
    /// * `Err` - If sync fails
    pub fn flush(&mut self) -> io::Result<()> {
        self.storage.sync_all()
    }

    /// Build a Write-Ahead Log (WAL) from its raw components.
    ///
    /// # Safety
    /// This is a dangerous function that should not be used directly.
    /// It bypasses important initialization and validation checks.
    /// Instead, use `malachitebft_wal::file::Log::open` which properly initializes the WAL.
    ///
    /// This function exists primarily for internal use and testing purposes.
    pub fn from_raw_parts(
        file: S,
        path: PathBuf,
        version: Version,
        sequence: u64,
        len: usize,
    ) -> Self {
        Self {
            storage: file,
            path,
            version,
            sequence,
            len,
        }
    }

    /// Returns the size in bytes of the underlying storage
    pub fn size_bytes(&self) -> io::Result<u64> {
        self.storage.size_bytes()
    }
}

impl<S> Log<S> {
    /// Returns the version of the WAL format.
    pub fn version(&self) -> Version {
        self.version
    }

    /// Returns the current sequence number.
    pub fn sequence(&self) -> u64 {
        self.sequence
    }

    /// Returns the path to the WAL file.
    pub fn path(&self) -> &Path {
        &self.path
    }

    /// Returns the number of entries in the WAL.
    pub fn len(&self) -> usize {
        self.len
    }

    /// Returns whether the WAL is empty.
    pub fn is_empty(&self) -> bool {
        self.len == 0
    }
}

/// Iterator over entries in a Write-Ahead Log (WAL)
pub struct LogIter<'a, F> {
    /// The next entry to be read from the WAL
    next: Option<LogEntry<'a, F>>,
}

/// Iterator over entries in a Write-Ahead Log (WAL)
///
/// Provides sequential access to entries stored in the WAL.
/// Each iteration returns the data contained in the next entry.
impl<F> Iterator for LogIter<'_, F>
where
    F: Storage,
{
    /// Each iteration returns a Result containing either the entry data as a `Vec<u8>`
    /// or an IO error if reading fails
    type Item = io::Result<Vec<u8>>;

    /// Advances the iterator and returns the next entry's data
    ///
    /// # Returns
    /// * `Some(Ok(Vec<u8>))` - Successfully read entry data
    /// * `Some(Err(e))` - Error occurred while reading entry
    /// * `None` - No more entries to read
    fn next(&mut self) -> Option<Self::Item> {
        let mut buf = Vec::new();
        let next = self.next.take()?;

        match next.read_to_next(&mut buf) {
            Ok(Some(entry)) => {
                self.next = Some(entry);
                Some(Ok(buf))
            }
            Ok(None) => Some(Ok(buf)),
            Err(e) => Some(Err(e)),
        }
    }
}

/// Computes the CRC32 checksum of the provided data
///
/// # Arguments
/// * `data` - The bytes to compute the checksum for
///
/// # Returns
/// The CRC32 checksum as a u32 in big-endian byte order
fn compute_crc(data: &[u8]) -> u32 {
    let mut hasher = crc32fast::Hasher::new();
    hasher.update(data);
    u32::from_be_bytes(hasher.finalize().to_be_bytes())
}

```
---
### `wal/src/ops.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::io::{Read, Seek, Write};

pub trait FileOps: Read + Write + Seek {
    fn metadata(&self) -> std::io::Result<std::fs::Metadata>;

    fn set_len(&mut self, size: u64) -> std::io::Result<()>;

    fn sync_all(&mut self) -> std::io::Result<()>;
}

```
---
### `wal/src/storage.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
use std::io::{self, Read, Seek, Write};
use std::path::Path;

/// Operations that the backing storage for the Write-Ahead Log must implement.
///
/// This is mainly used to exercise various failure scenarios in tests,
/// and should otherwise not be used in production code.
///
/// Users are instead encouraged to to use the default [`File`](std::fs::File)-based
/// implementation at [`crate::Log`].
pub trait Storage: Read + Write + Seek + Sized {
    type OpenOptions;

    /// Open the backing storage for the Write-Ahead Log at the given path.
    fn open_with(path: impl AsRef<Path>, options: Self::OpenOptions) -> io::Result<Self>;

    /// Returns the size of the file in bytes.
    fn size_bytes(&self) -> io::Result<u64>;

    /// Truncates the file to the specified size.
    fn truncate_to(&mut self, size: u64) -> io::Result<()>;

    /// Synchronizes all in-memory data to the underlying storage device.
    fn sync_all(&mut self) -> io::Result<()>;
}

```
---
### `wal/src/version.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
/// Version identifier for the Write-Ahead Log (WAL) format
///
/// Currently only supports version 1 (V1) of the format.
#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Version {
    /// Version 1 of the WAL format
    V1 = 1,
}

impl TryFrom<u32> for Version {
    type Error = ();

    /// Attempts to convert a u32 into a WalVersion
    ///
    /// # Arguments
    /// * `value` - The u32 value to convert
    ///
    /// # Returns
    /// * `Ok(WalVersion)` - If the value represents a valid version
    /// * `Err(())` - If the value does not correspond to any known version
    fn try_from(value: u32) -> Result<Self, Self::Error> {
        match value {
            1 => Ok(Self::V1),
            _ => Err(()),
        }
    }
}

```
---
### `wal/tests/it/basic.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
#![allow(clippy::bool_assert_comparison)]

use std::fs::OpenOptions;
use std::path::Path;
use std::sync::LazyLock;
use std::time::Duration;
use std::{fs, io, str};

use testdir::{NumberedDir, NumberedDirBuilder};

use informalsystems_malachitebft_wal::{Log, Version};

static TESTDIR: LazyLock<NumberedDir> =
    LazyLock::new(|| NumberedDirBuilder::new("wal".to_string()).create().unwrap());

macro_rules! testwal {
    () => {{
        let module_path = ::std::module_path!();
        let test_name = ::testdir::private::extract_test_name(&module_path);
        let subdir_path = ::std::path::Path::new(&module_path.replace("::", "/")).join(&test_name);
        TESTDIR.create_subdir(subdir_path).unwrap().join("wal.log")
    }};
}

const ENTRIES_1: &[&str] = &[
    "Hello, world!",
    "Wheeee!",
    "1234567890",
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
    "Done!",
];

const ENTRIES_2: &[&str] = &[
    "Something new",
    "Another thing",
    "And another",
    "Yet another",
];

fn setup_wal(path: &Path, entries: &[&str]) -> io::Result<Log> {
    let mut wal = Log::open(path)?;
    println!("Path: {}", wal.path().display());

    let version = wal.version();
    let sequence = wal.sequence();
    assert_eq!(version, Version::V1);
    assert_eq!(sequence, 0);

    for entry in entries {
        wal.append(entry)?;
    }

    assert_eq!(wal.len(), entries.len());
    assert_eq!(wal.is_empty(), entries.is_empty());

    wal.flush()?;

    Ok(wal)
}

#[test]
fn new_wal() -> io::Result<()> {
    let path = testwal!();
    let wal = Log::open(path)?;
    println!("Path: {}", wal.path().display());

    assert_eq!(wal.version(), Version::V1);
    assert_eq!(wal.sequence(), 0);
    assert_eq!(wal.len(), 0);
    assert_eq!(wal.is_empty(), true);

    Ok(())
}

#[test]
fn open_empty_wal() -> io::Result<()> {
    let path = testwal!();

    let wal = setup_wal(&path, &[])?;
    let version = wal.version();
    let sequence = wal.sequence();
    drop(wal);

    let wal = Log::open(&path)?;
    assert_eq!(wal.version(), version);
    assert_eq!(wal.sequence(), sequence);
    assert_eq!(wal.len(), 0);
    assert_eq!(wal.is_empty(), true);

    Ok(())
}

#[test]
fn write_entries() -> io::Result<()> {
    let path = testwal!();

    setup_wal(&path, ENTRIES_1)?;

    let mut wal = Log::open(&path)?;
    assert_eq!(wal.sequence(), 0);
    assert_eq!(wal.len(), ENTRIES_1.len());
    assert_eq!(wal.is_empty(), false);

    for (actual, &expected) in wal.iter()?.zip(ENTRIES_1) {
        let actual = actual?;

        let text = str::from_utf8(&actual).unwrap();
        println!("Entry: {text}");
        assert_eq!(text, expected);
    }

    Ok(())
}

#[test]
fn restart() -> io::Result<()> {
    let path = testwal!();

    {
        let mut wal = setup_wal(&path, ENTRIES_1)?;
        wal.restart(1)?;

        assert_eq!(wal.sequence(), 1);
        assert_eq!(wal.len(), 0);

        for entry in ENTRIES_2 {
            wal.append(entry)?;
        }

        wal.flush()?;
    }

    let mut wal = Log::open(&path)?;
    assert_eq!(wal.sequence(), 1);

    for (actual, &expected) in wal.iter()?.zip(ENTRIES_2) {
        let actual = actual?;

        let text = str::from_utf8(&actual).unwrap();
        println!("Entry: {text}");
        assert_eq!(text, expected);
    }

    Ok(())
}
#[test]
fn corrupted_wal() -> io::Result<()> {
    let path = testwal!();

    // Create and write some entries
    {
        let mut wal = Log::open(&path)?;
        wal.append(b"entry1")?;
        wal.append(b"entry2")?;
        wal.flush()?;
    }

    // Corrupt the file by truncating it in the middle
    {
        let metadata = fs::metadata(&path)?;
        let truncate_len = metadata.len() / 2;
        let file = OpenOptions::new().write(true).open(&path)?;
        file.set_len(truncate_len)?;
    }

    // Reopen and verify it handles corruption gracefully
    let wal = Log::open(&path)?;

    // Should have fewer entries due to corruption
    assert!(wal.len() < 2);

    Ok(())
}

#[test]
fn empty_wal_operations() -> io::Result<()> {
    let path = testwal!();
    let mut wal = Log::open(&path)?;

    assert!(matches!(wal.first_entry(), Ok(None)));
    assert!(wal.iter()?.next().is_none());

    Ok(())
}

#[test]
fn concurrent_access() -> io::Result<()> {
    use std::thread;

    let path = testwal!();

    // Write in one thread
    let path_clone = path.clone();
    let write_thread = thread::spawn(move || -> io::Result<()> {
        let mut wal = Log::open(&path_clone)?;
        wal.append(b"thread1")?;
        wal.flush()?;
        std::thread::sleep(Duration::from_millis(100));

        Ok(())
    });

    thread::sleep(std::time::Duration::from_millis(50));

    let wal = Log::open(path);

    assert!(wal
        .unwrap_err()
        .to_string()
        .contains("Failed to acquire exclusive advisory lock"));

    write_thread.join().unwrap()?;

    Ok(())
}

```
---
### `wal/tests/it/compression.rs`
*2025-05-18 23:58:49 | 2 KB*
```rust
use std::io;
use std::sync::LazyLock;

use testdir::{NumberedDir, NumberedDirBuilder};

use informalsystems_malachitebft_wal::Log;

static TESTDIR: LazyLock<NumberedDir> =
    LazyLock::new(|| NumberedDirBuilder::new("wal".to_string()).create().unwrap());

macro_rules! testwal {
    () => {{
        let module_path = ::std::module_path!();
        let test_name = ::testdir::private::extract_test_name(&module_path);
        let subdir_path = ::std::path::Path::new(&module_path.replace("::", "/")).join(&test_name);
        TESTDIR.create_subdir(subdir_path).unwrap().join("wal.log")
    }};
}

const ENTRIES: &[&[u8]] = &[
    &[0; 1000],
    &[1; 2000],
    &[2; 3000],
    &[3; 4000],
    &[4; 5000],
    &[5; 6000],
    &[6; 7000],
    &[7; 8000],
    &[8; 9000],
    &[9; 10000],
];

#[test]
fn large_entries() -> io::Result<()> {
    let temp = testwal!();

    let mut no_compression = Log::open(temp.join("no-compression.wal"))?;
    for entry in ENTRIES {
        no_compression.write(entry)?;
    }

    verify_entries(&mut no_compression, ENTRIES)?;

    let mut compression = Log::open(temp.join("compression.wal"))?;
    for entry in ENTRIES {
        compression.write_compressed(entry)?;
    }

    verify_entries(&mut compression, ENTRIES)?;

    let noncompressed_size = no_compression.size_bytes()?;
    let compressed_size = compression.size_bytes()?;

    println!("Non-compressed size: {:>5} bytes", noncompressed_size);
    println!("    Compressed size: {:>5} bytes", compressed_size);

    assert!(compressed_size < noncompressed_size);

    Ok(())
}

fn verify_entries(wal: &mut Log, entries: &[&[u8]]) -> io::Result<()> {
    assert_eq!(wal.len(), entries.len());

    for (actual, &expected) in wal.iter()?.zip(entries) {
        assert_eq!(actual?, expected);
    }

    Ok(())
}

```
---
### `wal/tests/it/corruption.rs`
*2025-05-18 23:58:49 | 7 KB*
```rust
use std::fs::OpenOptions;
use std::io::{self, Seek, SeekFrom, Write};
use std::sync::LazyLock;

use testdir::{NumberedDir, NumberedDirBuilder};

use informalsystems_malachitebft_wal::ext::*;
use informalsystems_malachitebft_wal::{Log, Version};

static TESTDIR: LazyLock<NumberedDir> =
    LazyLock::new(|| NumberedDirBuilder::new("wal".to_string()).create().unwrap());

macro_rules! testwal {
    () => {{
        let module_path = ::std::module_path!();
        let test_name = ::testdir::private::extract_test_name(&module_path);
        let subdir_path = ::std::path::Path::new(&module_path.replace("::", "/")).join(&test_name);
        TESTDIR.create_subdir(subdir_path).unwrap().join("wal.log")
    }};
}

#[test]
fn corrupted_crc() -> io::Result<()> {
    let path = testwal!();

    // Write initial entries
    {
        let mut wal = Log::open(&path)?;
        wal.append(b"entry1")?;
        wal.append(b"entry2")?;
        wal.flush()?;
    }

    // Corrupt the CRC of the second entry
    {
        let mut file = OpenOptions::new().read(true).write(true).open(&path)?;

        // Skip version (4 bytes) + sequence (8 bytes) + first entry
        file.seek(SeekFrom::Start(12))?;
        read_u8(&mut file)?; // Skip compression flag
        let first_entry_len = read_u64(&mut file)?;
        file.seek(SeekFrom::Current(first_entry_len as i64 + 4))?; // +4 for CRC

        // Now at the start of second entry, skip compression flag and length
        file.seek(SeekFrom::Current(1 + 8))?;

        // Write incorrect CRC
        write_u32(&mut file, 0xdeadbeef)?;
    }

    // Reopen and verify
    {
        let mut wal = Log::open(&path)?;
        let mut entries = wal.iter()?;

        // First entry should be readable
        assert!(entries.next().is_some());

        // Second entry should fail CRC check
        match entries.next() {
            Some(Err(e)) => assert_eq!(e.kind(), io::ErrorKind::InvalidData),
            _ => panic!("Expected CRC error for corrupted entry"),
        }
    }

    Ok(())
}

#[test]
fn incomplete_entries() -> io::Result<()> {
    let path = testwal!();

    // Write initial entries
    {
        let mut wal = Log::open(&path)?;
        wal.append(b"entry1")?;
        wal.append(b"entry2")?;
        wal.flush()?;
    }

    // Truncate file in the middle of the second entry
    {
        let mut file = OpenOptions::new().read(true).write(true).open(&path)?;

        // Skip header
        file.seek(SeekFrom::Start(12))?;

        read_u8(&mut file)?; // Skip compression flag
        let first_entry_len = read_u64(&mut file)?;

        // header + compression flag + length + CRC + data + partial second entry
        let truncate_pos = 12 + 1 + 8 + 4 + first_entry_len + 3;

        // Seek to middle of second entry
        file.set_len(truncate_pos)?;
    }

    // Reopen and verify
    {
        let mut wal = Log::open(&path)?;
        let entries: Vec<_> = wal.iter()?.collect::<Result<Vec<_>, _>>()?;

        // Should only have the first entry
        assert_eq!(entries.len(), 1);
        assert_eq!(&entries[0], b"entry1");
    }

    Ok(())
}

#[test]
fn invalid_version() -> io::Result<()> {
    let path = testwal!();

    // Create WAL file with invalid version
    {
        let mut file = OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(&path)?;

        // Write invalid version
        write_u32(&mut file, 0xFFFFFFFF)?;
        write_u64(&mut file, 0)?; // sequence
    }

    // Attempt to open WAL
    match Log::open(&path) {
        Err(e) => {
            assert_eq!(e.kind(), io::ErrorKind::InvalidData);
            // Verify error message contains version information
            assert!(e.to_string().contains("version"));
        }
        Ok(_) => panic!("Expected error when opening WAL with invalid version"),
    }

    Ok(())
}

#[test]
fn invalid_sequence() -> io::Result<()> {
    let path = testwal!();

    // Create WAL with valid version but corrupted sequence
    {
        let mut file = OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(&path)?;

        write_u32(&mut file, Version::V1 as u32)?;

        // Write partial/corrupted sequence number
        file.write_all(&[0xFF, 0xFF])?; // Only write 2 bytes instead of 8
    }

    // Attempt to open WAL
    match Log::open(&path) {
        Err(e) => {
            assert_eq!(e.kind(), io::ErrorKind::UnexpectedEof);
        }
        Ok(_) => panic!("Expected error when opening WAL with invalid sequence"),
    }

    Ok(())
}

#[test]
fn multiple_corruptions() -> io::Result<()> {
    let path = testwal!();

    // Create initial WAL with entries
    {
        let mut wal = Log::open(&path)?;
        wal.append(b"entry1")?;
        wal.append(b"entry2")?;
        wal.append(b"entry3")?;
        wal.flush()?;
    }

    // Introduce multiple types of corruption
    {
        let mut file = OpenOptions::new().read(true).write(true).open(&path)?;

        // Corrupt sequence number
        file.seek(SeekFrom::Start(4))?;
        write_u64(&mut file, u64::MAX)?;

        // Corrupt entry length
        file.seek(SeekFrom::Start(12 + 1))?;
        write_u64(&mut file, u64::MAX - 1)?;

        // Corrupt CRC of another entry
        file.seek(SeekFrom::Start(50 + 1))?;
        write_u32(&mut file, 0xdeadbeef)?;
    }

    // Attempt to open and read
    {
        let mut wal = Log::open(&path)?;
        let entries: Vec<_> = wal
            .iter()?
            .take_while(|r| r.is_ok())
            .collect::<Result<Vec<_>, _>>()?;

        // Should have recovered what it could
        assert!(entries.len() < 3);
    }

    Ok(())
}

#[test]
fn zero_length_entries() -> io::Result<()> {
    let path = testwal!();

    // Create WAL with zero-length entry
    {
        let mut wal = Log::open(&path)?;
        wal.append(b"")?;
        wal.append(b"normal entry")?;
        wal.flush()?;
    }

    // Verify reading
    {
        let mut wal = Log::open(&path)?;
        let entries: Vec<_> = wal.iter()?.collect::<Result<Vec<_>, _>>()?;

        assert_eq!(entries.len(), 2);
        assert_eq!(&entries[0], b"");
        assert_eq!(&entries[1], b"normal entry");
    }

    Ok(())
}

#[test]
#[ignore]
fn max_entry_size() -> io::Result<()> {
    let path = testwal!();

    let mut wal = Log::open(&path)?;

    // Try to write an entry that's too large
    let large_entry = vec![0u8; usize::MAX / 2];
    assert!(wal.append(&large_entry).is_err());

    // Verify WAL is still usable
    wal.append(b"normal entry")?;

    let entries: Vec<_> = wal.iter()?.collect::<Result<Vec<_>, _>>()?;
    assert_eq!(entries.len(), 1);
    assert_eq!(&entries[0], b"normal entry");

    Ok(())
}

```
---
### `wal/tests/it/crashes.rs`
*2025-05-18 23:58:49 | 9 KB*
```rust
use std::fs::{File, OpenOptions};
use std::io::{self, Read, Seek, Write};
use std::path::Path;
use std::process::{Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, LazyLock};
use std::thread;
use std::time::Duration;

use nix::sys::signal::{self, Signal};
use nix::unistd::Pid;
use testdir::{NumberedDir, NumberedDirBuilder};

use informalsystems_malachitebft_wal::log::Log;
use informalsystems_malachitebft_wal::Log as FileLog;
use informalsystems_malachitebft_wal::*;

static TESTDIR: LazyLock<NumberedDir> =
    LazyLock::new(|| NumberedDirBuilder::new("wal".to_string()).create().unwrap());

macro_rules! testdir {
    () => {{
        let module_path = ::std::module_path!();
        let test_name = ::testdir::private::extract_test_name(&module_path);
        let subdir_path = ::std::path::Path::new(&module_path.replace("::", "/")).join(&test_name);
        TESTDIR.create_subdir(subdir_path).unwrap()
    }};
}

macro_rules! testwal {
    () => {{
        testdir!().join("wal.log")
    }};
}

/// Helper struct to simulate failures during writes
#[derive(Debug)]
pub struct FailingFile {
    inner: File,
    fail_after: usize,
    bytes_written: usize,
}

impl FailingFile {
    pub fn new(file: File, fail_after: usize) -> Self {
        Self {
            inner: file,
            fail_after,
            bytes_written: 0,
        }
    }
}

impl Seek for FailingFile {
    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
        self.inner.seek(pos)
    }
}

impl Read for FailingFile {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.inner.read(buf)
    }
}

impl Write for FailingFile {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        if self.bytes_written + buf.len() > self.fail_after {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                "Simulated system failure",
            ));
        }
        let written = self.inner.write(buf)?;
        self.bytes_written += written;
        Ok(written)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

impl Storage for FailingFile {
    type OpenOptions = usize;

    fn open_with(path: impl AsRef<Path>, fail_after: usize) -> io::Result<Self> {
        let inner = <File as Storage>::open_with(path, ())?;
        Ok(Self::new(inner, fail_after))
    }

    fn size_bytes(&self) -> io::Result<u64> {
        self.inner.size_bytes()
    }

    fn truncate_to(&mut self, size: u64) -> io::Result<()> {
        self.inner.truncate_to(size)
    }

    fn sync_all(&mut self) -> io::Result<()> {
        self.inner.sync_all()
    }
}

type FailingLog = Log<FailingFile>;

/// Helper function to verify WAL integrity
fn verify_wal_integrity(path: &Path) -> io::Result<Vec<Vec<u8>>> {
    let mut wal = FileLog::open(path)?;
    let entries = wal.iter()?.collect::<io::Result<Vec<_>>>()?;
    Ok(entries)
}

#[test]
fn system_crash_during_write() -> io::Result<()> {
    let temp_dir = testdir!();

    // Test different crash points
    let crash_points = vec![
        // During header write
        4, // During version write
        8, // During sequence number write
        // During entry write
        14, // During entry length write
        18, // During CRC write
        22, // During data write
    ];

    for crash_point in crash_points {
        let path = temp_dir.join(format!("crash-{crash_point}.wal"));

        // Create an empty normal WAL
        FileLog::open(&path)?;

        // Open WAL with failing file
        let storage = FailingFile::open_with(&path, crash_point)?;
        let mut wal = FailingLog::from_raw_parts(storage, path.clone(), Version::V1, 0, 0);

        // Attempt to write entries
        let result = (|| -> io::Result<()> {
            wal.append(b"entry1")?;
            wal.append(b"entry2")?;
            Ok(())
        })();

        assert!(result.is_err());

        // Drop the WAL to unlock the backing file
        drop(wal);

        // Verify WAL integrity after crash
        let entries = verify_wal_integrity(&path)?;

        // The number of successful entries should be consistent with the crash point
        assert!(entries.len() <= 1);
    }

    Ok(())
}

// Simulate power failure during fsync
struct FailingSync {
    inner: File,
    should_fail: bool,
}

impl Write for FailingSync {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.inner.write(buf)
    }

    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

impl Read for FailingSync {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.inner.read(buf)
    }
}

impl Seek for FailingSync {
    fn seek(&mut self, pos: io::SeekFrom) -> io::Result<u64> {
        self.inner.seek(pos)
    }
}

impl Storage for FailingSync {
    type OpenOptions = bool;

    fn open_with(path: impl AsRef<Path>, should_fail: bool) -> io::Result<Self> {
        let inner = <File as Storage>::open_with(path, ())?;
        Ok(Self { inner, should_fail })
    }

    fn size_bytes(&self) -> io::Result<u64> {
        self.inner.size_bytes()
    }

    fn truncate_to(&mut self, size: u64) -> io::Result<()> {
        self.inner.truncate_to(size)
    }

    fn sync_all(&mut self) -> io::Result<()> {
        if self.should_fail {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                "Simulated power failure during fsync",
            ));
        }

        self.inner.sync_all()
    }
}

type FailingSyncLog = Log<FailingSync>;

#[test]
fn power_failure_simulation() -> io::Result<()> {
    let path = testwal!();

    // Create an empty normal WAL
    FileLog::open(&path)?;

    // Test power failure during sync
    {
        // Use `from_raw_parts` to avoid calling `sync` during initialization
        let storage = FailingSync::open_with(&path, true)?;
        let mut wal = FailingSyncLog::from_raw_parts(storage, path.to_owned(), Version::V1, 0, 0);

        wal.append(b"entry1")?;

        assert!(wal.flush().is_err());
    }

    // Verify recovery after power failure
    let entries = verify_wal_integrity(&path)?;
    assert!(entries.is_empty() || entries.len() == 1);

    Ok(())
}

#[test]
fn process_termination() -> io::Result<()> {
    let path = testwal!();
    let path_str = path.to_str().unwrap();

    // Create a separate process that will be terminated
    let child = Command::new(std::env::current_exe()?)
        .arg("--test")
        .arg("wal_write_test")
        .arg(path_str)
        .stdout(Stdio::piped())
        .spawn()?;

    // Give the child process time to start writing
    thread::sleep(Duration::from_millis(100));

    // Terminate the process
    signal::kill(Pid::from_raw(child.id() as i32), Signal::SIGKILL)?;

    // Wait for the process to exit
    let _ = child.wait_with_output();

    // Verify WAL integrity after process termination
    let entries = verify_wal_integrity(&path)?;

    // The WAL should either be empty or contain complete entries
    for entry in entries {
        assert!(!entry.is_empty());
    }

    Ok(())
}

// Helper binary for process termination test
#[test]
fn wal_write_test() {
    if std::env::args().any(|arg| arg == "--test") {
        if let Some(path) = std::env::args().nth(3) {
            let mut wal = FileLog::open(path).unwrap();
            loop {
                // Continuously write entries until terminated
                wal.append(b"test entry").unwrap();
                wal.flush().unwrap();
                thread::sleep(Duration::from_millis(10));
            }
        }
    }
}

#[test]
fn concurrent_crash_recovery() -> io::Result<()> {
    let path = testwal!();
    let path_clone = path.clone();

    let running = Arc::new(AtomicBool::new(true));
    let running_clone = running.clone();

    // Writer thread
    let writer_handle = thread::spawn(move || -> io::Result<()> {
        let mut wal = FileLog::open(&path_clone)?;

        while running_clone.load(Ordering::SeqCst) {
            wal.append(b"test entry")?;
            wal.flush()?;
            thread::sleep(Duration::from_millis(10));
        }

        Ok(())
    });

    // Crasher thread
    let path2 = path.clone();
    let crasher_handle = thread::spawn(move || {
        for _ in 0..5 {
            thread::sleep(Duration::from_millis(50));

            // Simulate crash by truncating file
            if let Ok(file) = OpenOptions::new().write(true).open(&path2) {
                let _ = file.set_len(12); // Truncate to header size
            }
        }
        running.store(false, Ordering::SeqCst);
    });

    writer_handle.join().unwrap()?;
    crasher_handle.join().unwrap();

    // Verify final WAL integrity
    let entries = verify_wal_integrity(&path)?;

    // The WAL should be in a consistent state
    for entry in entries {
        assert_eq!(&entry, b"test entry");
    }

    Ok(())
}

```
---
### `wal/tests/it/main.rs`
*2025-05-18 23:58:49 | 1 KB*
```rust
pub mod basic;
pub mod corruption;
pub mod crashes;
pub mod stress;

#[cfg(all(feature = "compression", not(feature = "force-compression")))]
pub mod compression;

```
---
### `wal/tests/it/stress.rs`
*2025-05-18 23:58:49 | 5 KB*
```rust
use std::fs;
use std::io;
use std::sync::LazyLock;
use std::time::Instant;

use rand::{thread_rng, Rng};
use testdir::NumberedDir;
use testdir::NumberedDirBuilder;

use informalsystems_malachitebft_wal::*;

static TESTDIR: LazyLock<NumberedDir> =
    LazyLock::new(|| NumberedDirBuilder::new("wal".to_string()).create().unwrap());

macro_rules! testwal {
    () => {{
        let module_path = ::std::module_path!();
        let test_name = ::testdir::private::extract_test_name(&module_path);
        let subdir_path = ::std::path::Path::new(&module_path.replace("::", "/")).join(&test_name);
        TESTDIR.create_subdir(subdir_path).unwrap().join("wal.log")
    }};
}

const KB: usize = 1024;
const MB: usize = 1024 * KB;

/// Test configuration for customizable stress tests
struct StressTestConfig {
    num_entries: usize,
    sync_interval: usize,
}

#[test]
fn large_number_of_entries() -> io::Result<()> {
    let path = testwal!();

    let config = StressTestConfig {
        num_entries: 1_000_000, // 1 million entries
        sync_interval: 1000,    // Sync every 1000 entries
    };

    let start = Instant::now();
    let mut wal = Log::open(&path)?;

    println!("Starting large number of entries test...");

    // Write entries
    for i in 0..config.num_entries {
        let entry = format!("entry-{}", i);
        wal.append(entry.as_bytes())?;

        if i % config.sync_interval == 0 {
            wal.flush()?;
            if i % 100_000 == 0 {
                println!("Wrote {} entries...", i);
            }
        }
    }

    wal.flush()?;

    let write_duration = start.elapsed();
    println!("Write phase completed in {:?}", write_duration);

    // Verify entries
    let start = Instant::now();
    let entries: Vec<Vec<u8>> = wal.iter()?.collect::<io::Result<Vec<_>>>()?;

    assert_eq!(entries.len(), config.num_entries);

    for (i, entry) in entries.iter().enumerate() {
        let expected = format!("entry-{}", i);
        assert_eq!(entry, expected.as_bytes());
    }

    let read_duration = start.elapsed();
    println!("Read phase completed in {:?}", read_duration);

    // Report statistics
    let file_size = fs::metadata(&path)?.len();
    println!("WAL Statistics:");
    println!("  Total entries: {}", config.num_entries);
    println!("  File size: {:.2} MB", file_size as f64 / MB as f64);
    println!(
        "  Write throughput: {:.2} entries/sec ({:.2} MB/sec)",
        config.num_entries as f64 / write_duration.as_secs_f64(),
        file_size as f64 / MB as f64 / write_duration.as_secs_f64()
    );
    println!(
        "  Read throughput: {:.2} entries/sec ({:.2} MB/sec)",
        config.num_entries as f64 / read_duration.as_secs_f64(),
        file_size as f64 / MB as f64 / read_duration.as_secs_f64()
    );

    Ok(())
}

#[test]
#[ignore]
fn entry_sizes() -> io::Result<()> {
    let path = testwal!();

    #[allow(clippy::identity_op)]
    let entry_sizes = vec![
        1 * KB,   // 1 KiB
        10 * KB,  // 10 KiB
        100 * KB, // 100 KiB
        500 * KB, // 500 KiB
        1 * MB,   // 1 MiB
        10 * MB,  // 10 MiB
    ];

    let mut wal = Log::open(&path)?;

    println!("Starting entry sizes test...");

    for &size in &entry_sizes {
        // Create entry with random data
        let entry: Vec<u8> = (0..size).map(|_| thread_rng().gen::<u8>()).collect();

        let start = Instant::now();

        if size >= MB {
            println!("Writing entry of size: {} MB", size / MB);
        } else {
            println!("Writing entry of size: {} KB", size / KB);
        }

        // Write entry
        wal.append(&entry)?;
        wal.flush()?;

        let duration = start.elapsed();
        println!("  Write completed in {:?}", duration);
        println!(
            "  Throughput: {:.2} MB/s",
            size as f64 / MB as f64 / duration.as_secs_f64()
        );
    }

    // Verify entries
    let start = Instant::now();
    let entries: Vec<Vec<u8>> = wal.iter()?.collect::<io::Result<Vec<_>>>()?;

    assert_eq!(entries.len(), entry_sizes.len());

    for (entry, &expected_size) in entries.iter().zip(entry_sizes.iter()) {
        assert_eq!(entry.len(), expected_size);
    }

    println!("Read verification completed in {:?}", start.elapsed());

    Ok(())
}

```
---

## Summary
Files: 339, Total: 1605 KB
Breakdown:
- toml: 48 KB
- rs: 1556 KB
- sh: 1 KB